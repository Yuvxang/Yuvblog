<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>小思考</title>
    <url>/2024/05/20/%E5%B0%8F%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>最近的表达欲直线上升了，可能是因为在读戴爷爷（戴建业老师）的书，作为一名语文老师，他是能够让我体会到古诗中的韵味和古人那种高尚的人生哲学的人，也给我的生活增添了不少的鼓励与趣味。这两天有幸接触到了他的《你听懂了没有》和《我的个天》这两本书，严肃的诗文分析我并不是很喜欢，但是散文能够传达生活的独特感受，一直是我的最爱，它的B站视频也十分有韵味。</p>
<span id="more"></span>

<p>这两天，也因为自己做到了一些能够让自己骄傲的事情，心态好转了不少，没有了像过去那样的自卑，更多的是理性的思考和下一步的行动上的考虑，在很多情况下，我承认自己的行动力确实不足，因为源于习惯的对不确定性的反感，还是更喜欢稳妥能给自己带来好处的行为方式，一如现在的我确实十分的内向，因为人际关系总会因为自己的几句话而发生微妙的变化，微信聊天中的体会让我定义自己为一个聊天太过认真的人，所以我总是倾向于独自思考，思考自己的问题。这篇文章就是我对一些人生问题的思考，或许它们定义了我自己，或许它们是我的某些生活方式的写照，能够把我给描出来。</p>
<p>这篇文章包含若干小文章，有时长，有时短，但一定是经过了思考，欢迎在评论区进行交流。<br>作为学生，就从普遍日程上开始写起吧，</p>
<h2 id="日程篇-学习、作息、生活"><a href="#日程篇-学习、作息、生活" class="headerlink" title="日程篇 (学习、作息、生活)"></a>日程篇 (学习、作息、生活)</h2><h3 id="1-为什么学习"><a href="#1-为什么学习" class="headerlink" title="1. 为什么学习"></a>1. 为什么学习</h3><p>我发觉到自己有这么一种倾向，追求个性，追求变化。很多时候想要产生自己的想法，毕竟很多时候社会都传播着热爱与梦想对于人的价值，但是也总是迫于内卷和对自己的不满，开始尝试（或者说是服从）人家符合早睡早起、好好学习的高中式作息。在高中的时候，我们通常会这样给自己的生活定义——“三点一线”，也就是家、食堂与学校。我确实对这种生活感到十分地厌倦，不仅是每天重复的生活，而且似乎我们生活的目标就只能盯着学习。现在进入大学，我们早已不在意家长口中传播的“上大学就轻松了”，因为我们已经接触到了现实，但现在，或许学习（传统意义上的上课与写作业）不再是我们生活的唯一目标了，可我们是否应该像高中那时候一样重视呢？我的观点是这样：传统的学习可以给生活带来些许成就感，仅此而已，广义的学习是生活的开拓，所以视其对你重要性而定喽。</p>
<p>我知道我们确实通过之前的学习收获了很多，肯定有我没体会到的东西。是这样，但是你不能否认现在的大学课程因为课时进度与难度降低少讲了很多东西，就连英语这种需要终身学习的东西，我们也在心底觉得掌握六级6000个词左右就万事大吉了，而当我们面对实际的问题时，我们现有的知识又是十分匮乏的：要阅读论文，但是英语上大部分专业的词汇都没接触到，要应对生活中多变的问题，但是我们因为课本上没有就不去接触这个算法。工科的知识不够实际，所以必定是需要自学的。像语文、英语这样东西又被刻板印象上降级为只需要背和编的东西。所以我说传统的学习其实并没有给我们带来太多东西，并且很多知识我们学了是不知道用在哪里的，成就感何在？就在学习之后我们应用知识的场景上，比如学科竞赛、考试以及平时做题，有时候还可以得到父母的夸奖，而且学习的生活方式很长时间来被社会所认同，即使生活会因为学习而变得重复，心理上是过得去的。</p>
<p>在高中的时候，我们班主任特别烦有人因为所谓的“自学”、“闭门造车”而请假回家看网课或者上课不听讲，确实这些人在之后并没有像他们想的一样取得比别人更好的成绩。仿佛自学是一件不好的事情。我是这样看的啊，因为老师站在我们学生的实际来讲课，而且讲课是有连贯性（注重知识点之间的迁移运用）的，因而教的效果要更好，在网上寻找课程，你必须要精细化好你的问题，老师会将这个问题抽象成一个简化的模型，然后会告诉你固定的思路，老师给你提供的是一个背景上的框架与框架里的信息，你可以通过看网课对同一个问题产生一些不同的视角，从而更好地解决问题。只看网课的缺点在哪呢，就在它知识点的独立与零碎上，首先是容易忘记，而且出于简单的需要，它将会将知识点做进一步的特殊化与简化，看课是为了做题，而不是对课本概念的理解，从而不能从根本上提高成绩。</p>
<p>什么是自学呢？因为我也是“热爱”与“梦想”这两个词的”忠实粉丝“，因而我也要用这两个词来定义它。自学的动机是源于自己的想法。因而一定是有坚定的热爱才能够坚持下去，没有社会信念的支持，没有别人的支持，是你自己一个人的战斗。自学中没有竞争，只有你对于同一个问题的想法，因为不同的人对于学习有着自己的目标和理念，从根本上也没有什么好竞争的。从这个意义上来说，自学甚至可以看做是个性的一种集中表现，学什么、怎么学、学什么样都是你自己说了算。并且自学，在我看来，是给生活增添变量的过程，内容越多，思考越多，会的越多，能做的事情越多。对于这个世界的认知也越好。</p>
<p>星穹铁道里有个词叫“开拓”，我一直很喜欢这个词，因为它代表着前进与探索，并且在途中收获独属于自己的乐趣与体验。在我看来，自学的旅程也是一样，并且它能够帮助你实现梦想，免除一成不变的生活。从根本上来说，自学的本质才是学习本身，传统学习的目标是应试学习（实际上课本并不是这样要求我们的，课本上的每一句话都是很重要的，需要我们好好理解，但是我们却热衷于背弃课本去寻找其他的学习资料。）学习是人类的本性，是我们进步的方式，所以我认为自学才是一种真正的学习，从师学习，只要是动机出于自身，也是一种自学，所以，我觉得应该更重视自学。</p>
<p>放松一下，我其实是一个挺自卑的人，不论是人际关系还是打游戏可能都不是很强（我或许都没有啥很强的地方），同班的人都能看得见我课课都抬着头好好听课，不管是水课还是专业课，实际上在某种程度上也是在寻找一种认可感与成就感，因为专注这件事其实很不容易做到，又由于我瞬时记忆力比较好，因而可以和老师对答如流，认真学习也是成绩的一种保证。这是我自信的一部分，所以在生活中我其实挺在意传统学习的，最近的HTML学习让我感受到了自学的乐趣，因而作这一篇。</p>
<p><em>May 20th</em> 天气晴</p>
]]></content>
      <tags>
        <tag>心态调整</tag>
      </tags>
  </entry>
  <entry>
    <title>我的新尝试-HTML学习日记</title>
    <url>/2024/05/14/%E6%88%91%E7%9A%84%E6%96%B0%E5%B0%9D%E8%AF%95-HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>有时候觉得把自己努力的过程记录下来，后来回望也知道自己是如何走到现在的结果的，是一个很浪漫的事情。</p>
<span id="more"></span>

<p>近些天空闲的时间是越来越多了，这样的时间最常见的消耗方式，对我来说有俩</p>
<blockquote>
<p> 一是在某些开放世界游戏里过剧情，尤其是你又一直期望着这些剧情会更好，结果真的是快看睡了，<br>或是一天因为自己想抽卡的愿望肝到5-6个小时。<br>抽卡这件事其实并不是多坏的事情，<br>毕竟还有一种解释，既然这种努力是艰难的，那也是一种为自己的目标奋斗的过程。</p>
<p>二是睡觉，在不断寻找自己活着是为啥，在找寻可以做的事情时，一本书启发了我，睡觉是健脑的。<br>因而我肯定不能让闹钟坏了我的好事，尤其是午后时光，一睡就是3个小时。</p>
</blockquote>
<p>平常的课程感觉就这样的状态还是可以应付的过去的。就在这舒适的生活中，一位老友联系上我，让我做一个小程序，<br>咱想着总算有机会可以试试前端开发的水了，我就提出可以试一试，也是给自己一个目标。</p>
<blockquote>
<p>第一，想着自己做一个，一看涉及到vue、js开发，完全从0开始搭建。害，别吓我，还有人做过的模板呢，拿来用不就好。<br>第二，想着找模板，我一看，网上像样的模板搞到了上千块钱，没钱，算了吧.<br>第三，找官方模板，人家说不合要求。<br>所以总算这件事没谈成。</p>
</blockquote>
<p>不过总算是有收获，这就是这次尝试学习三件套的动机，无论是经济收益还是自学经验都是对以后的收益。</p>
<h2 id="5-14-复习之前的知识"><a href="#5-14-复习之前的知识" class="headerlink" title="5&#x2F;14 复习之前的知识"></a>5&#x2F;14 复习之前的知识</h2><p>一个模版，所有用html的都熟悉。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!Doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个HTML页面。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这时我就在想，如何做到在我的博客上能够预览这段代码的结果呢？<br>将预览的HTML页面做成一个集合页面放到左边的栏里不就行了。<br>这样我就可以在这里直接引用这个文件了。<a href="http://moniwarmth.top/html">http://moniwarmth.top/html</a><br>初期的网页十分粗糙，这个网页会随着我的学习不断迭代的，满足各位读者姥爷的期待。</p>
<p>期间也学习了网页与图片在html中的表示，不过单独在此列出有些多余，演示都在左边那个栏里。<br>同时为喜欢学习前端的童鞋们推荐一下编辑器。<br><strong>Vscode</strong>，很早的时候就很喜欢它的主题，只不过配置编译太过复杂一直没用，它在编写HTML时，有一个插件是<code>live preview</code>，可以一边编辑一边看效果，很赞。<br>写这篇文章使用的<strong>sublime text</strong>也很推荐。</p>
<p>这就是今天作的简单复习。</p>
<h2 id="5-17-字体整合表示"><a href="#5-17-字体整合表示" class="headerlink" title="5&#x2F;17 字体整合表示"></a>5&#x2F;17 字体整合表示</h2><blockquote>
<p>多的那些，关于咱具体学到了啥就不说了。<br>首先废话几句，唉，终于到了期待的周末了。<br>我不得不说，学习HTML是一个十分畅快的过程，看看今晚写的小故事吧<br>可能小对话写的不怎么样，不过通过字体变化刻画心理真的挺好玩的哈！</p>
</blockquote>
<p>总共的字体格式，后面可能会再补充吧，就这些<br>大的，小的，下标的，上标的，粗的，斜的，带解释的，代码型的。</p>
<p>另外还有感觉上很好用的一行以及换行符，加上以后感觉页面美观度又升了一级！<br>不过现在也不指望多好看，等到学CSS了必定让它飞跃提升好吧！</p>
<blockquote>
<p>Another Happy Day..</p>
</blockquote>
]]></content>
      <tags>
        <tag>HTML学习</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我的抉择：C++与算法或者数据结构</title>
    <url>/2024/03/09/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84%E6%8A%89%E6%8B%A9%EF%BC%9AC-%E4%B8%8E%E7%AE%97%E6%B3%95%E6%88%96%E8%80%85%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>看过之前这个寒假的博客的应该知道了，<br>我在这个寒假里学了点算法，到现在已经快忘完了（只有插入排序还能想起来一点）。<br>我十分不建议先进行算法的学习，当然对于不同的人有不同的看法，这是我的视角，通过实践的视角。</p>
<span id="more"></span>

<h2 id="算法与数据结构为你提供了什么？"><a href="#算法与数据结构为你提供了什么？" class="headerlink" title="算法与数据结构为你提供了什么？"></a>算法与数据结构为你提供了什么？</h2><p>我们学习计算机的可能自大一就已经知道了算法与数据结构对于解题以及之后的工作应用都挺重要的。</p>
<p>算法，也就是通常意义上人们对于一个问题的解法，因为一种方法能够解决通常来说难以想出思路的问题，或者它的效率特别的高，所以我们使用算法——我们为的是解决实际问题。实际上，我们平时解决问题的时候，也是在设计算法。我想要输出一行“Hello World”，我知道printf（cin）之后我就使用这个函数来达到了要求，这就是一种算法。数据结构，就是存放数据的结构。它与算法相辅相成，有时算法需要特定的数据结构来实现，有时特定的数据结构便于问题的解决，最终的优势就是能够便利地解决问题。并且，很多平台都针对不同的算法给出了题目的分类，如果你学习了某一个算法，你可能当天就可以将它运用到实操之中，加深印象，而且学习算法能够让你的学习有针对性，还时不时能够让你解出高难度的题，这种学习还是有成就感的。</p>
<h2 id="为啥我不建议？"><a href="#为啥我不建议？" class="headerlink" title="为啥我不建议？"></a>为啥我不建议？</h2><p>说实话，学习算法的这些日子里，尽管有上文所说的那些优点，做编程题做得仍然是挺憋屈的，为啥呢？</p>
<blockquote>
<p>首先，你学一种算法，只能解决一种问题，你没有办法在洛谷上随机一道题目。</p>
<p>第二，如果你理解不深刻，运用的就十分拙劣。依靠固有的算法写法，到头来也就只是记下来了写法而已，而且十分容易忘记。<br>然后是理解，深刻的算法有如分治法，涉及到了渐进数学中的知识，描述递归方程的式子也挺复杂的，我们没接触过，理解起来也有困难。<br>而且所谓的分治法只是一种思维结构，你靠着这个还得自己进行二次设计，最后的算法还得自己想。</p>
<p>第三，并不是所有算法都可以当天实现，除非你的学习资料为你写好了，一些算法甚至无法用程序语言写，一些算法需要你去学习数据结构才能写。</p>
</blockquote>
<p>归根到底，算法是死的，实际问题是活泛的，算法是很多零碎的知识，像是可以适用于哪些题目，像是实现方法，都是拼记忆力。</p>
<h2 id="为啥要学习C"><a href="#为啥要学习C" class="headerlink" title="为啥要学习C++"></a>为啥要学习C++</h2><p>说实话，我刚开始学习C++的时候，也没觉出来C++与C有啥不同，除了面向对象之外也就是把C语言的那些东西用其他的方式又写了一遍嘛。<br>而且专业名词还要多，啥内联函数，啥引用类型，感觉不太好学的样子。</p>
<p>但是抱着两条路一定得走一条的想法，我就看着网上的C语言教程，一啃就是半个月。<br>到头来，我基本学习完了C++中的基础概念，然后按照学长的建议，开始学习C++ STL，其实建议很大一部分也是因为这个。<br>就是因为这半个月以来的努力，我得以开始学习STL，而这已经为我现在的编程学习提供了十足的便利。</p>
<p>STL为我提供了什么呢？</p>
<blockquote>
<p>第一，数据结构，你可能知道一道题需要啥数据结构。比如说去重，你可以使用集合，但是自己实现确实不太容易。这时直接使用set即可。<br>（很多数据结构确实不好实现，如树、映射，表示也挺繁琐）<br>第二，简便操作，一些数据结构可能原来就有，比如数组、比如字符串，但是STL中的平替物比原来的好用太多，而且用来操作的函数（sort排序、reverse倒序、find查找、count数元素出现几次）不需要自己实现，十分便利，省去了解题时间，而且也减少了错误率，另外遍历在C++14中有很简便的写法（如下）。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设想你有一个数组，或者字符串等等，名字叫做a</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ele : a)</span><br><span class="line">	cout &lt;&lt; ele &lt;&lt; endl;</span><br><span class="line"><span class="comment">//ele是你对输出元素的命名，不重要</span></span><br></pre></td></tr></table></figure>

<p>另外，C++中新增的数学函数以及语言特性（比如说cin不必管缓冲区的事情，cout不需要有格式化符）都提供了很大的便利，<br>使用这种语言我认为是更适合于现在即将参加蓝桥杯的局势的。</p>
<p>最后，选择这件事是看自己的感受的，不是盲从其他人，希望看过这篇文章的你能够根据自己的情况选择。<br>提醒你一下，C++虽然明面上和C差不多，但是还是有很大的区别的，学完类、学完重载你就知道了。</p>
<blockquote>
<p>End…</p>
</blockquote>
]]></content>
      <tags>
        <tag>C++学习</tag>
      </tags>
  </entry>
  <entry>
    <title>我的心态调整指南</title>
    <url>/2024/03/04/%E6%88%91%E7%9A%84%E5%BF%83%E6%80%81%E8%B0%83%E6%95%B4%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<blockquote>
<p>这篇文章收录在了我的obsidian仓库中的“我的未来”板块，如有同学观看，愿共勉且尊重。</p>
</blockquote>
<p>从这历经磨难的大一上走过来，经过了一个寒假，只不过是学会了一条道理，完完全全地颠覆了之前的大部分焦虑。</p>
<span id="more"></span>

<p>在上一年，在我还刚入学的时候。看着来来往往的人群，我感到的是陌生与激动，激动属于是“应激反应”了，因为我习惯上看到青年来来往往的样子就会想象他们在努力追梦的样子。那时候，我还是啥都不懂，但心比天高。陌生是透到骨子里的陌生了，当时是自己坚持说要去外省，但是刚开始的时候感觉到的却是无依无靠的感觉，另外因为上大学办保险、办校园卡、买日用品、来河南花了家里不少的钱……种种不切实际与负面的情绪压抑着我。</p>
<blockquote>
<p>那个时候，当年级里很多人在C语言群里交流算法或者C语言语法的时候，我还是才从班长口中得知要学C语言的小萌新，所以刚进学校，一阵巨大的压力就扑面而来，这种压力跟随了我一整个学期，如同我学习编程就是为了赶上C语言群里的人们（但他们学得太快太专一，自卑）。</p>
<p>那个时候，学校里厉害的人很多，当时其实并没有对于未来形成一个明确的要往哪走的目标，只不过是想要做大多数人做不到的事情，而且尽量是在大一做，只是因为牛逼。报过两套课程，一个教如何成为一个牛逼的大学生，一个教IP（就是抖音的视频号，B站的UP主）的。两个东西占据了很多学习的时间，到头来学习与课外都没有兼顾好，一天做不了啥有实际意义（给自己带来优越感）的事情，阴郁的心情困扰着我。</p>
<p>那个时候，耳机里每天听的是英语歌，歌曲里几乎都是歌唱恋爱与激励勇气拼搏的。每天都心心念念着美好的恋爱却迟迟不敢行动，不知道喜欢是啥感觉，不知道如何交流，看到别人也老是会自卑。听到拼搏热血的歌曲，只不过是在心里给自己讲理而已，但在一个人有情绪的时候，你觉得讲理分析有用吗？</p>
<p>那个时候，我的爱好并不与同学们重合，我喜欢的是听音乐，他们可以做运动，编程等等。他们常说的那些游戏也基本都是萌新，刚刚接触而已。和舍友也说不上啥话。习惯了带有戒备心（或者说所谓的“礼貌用语”）讲话，因而几乎不能与人交心，与所有人都挺“远”的，只是憧憬着之前和同学们一起玩得开心的样子，但与以前的同学说话也被告诉“你现在说话怎么这个样子，都不像你了”。</p>
<p>……</p>
</blockquote>
<p><img src="/img/pic1.jpg" alt="军训时候"></p>
<p>如果这篇文章是在上学期写的，我可能会反观这些故事，感觉自己的“事迹”不合群，感觉根本不会有人和我有重合的地方，因而直接放弃这篇文章，并且感觉我自己真惨（笑哭）。</p>
<p>读到这里你可能会有与我重合的地方，作为一个计算机专业的学生，未来的方向尚未明确，整天愤世嫉俗，有不如别人的地方就自卑，这对于高中内卷环境走来的人来说也挺正常的（希望没有冒犯到谁），在高中的时候，我也会因为严苛的竞争环境而充满阴郁。但如果要把自己奋斗的目标设立为超过目之所及的所有人，你不累才怪哩。另外，我也是挺内向的一个人，即便到现在也是，我不认为内向是一个负面的性格，即便很多人可能和你说过沟通能力很重要。相信我，强行改变自己的态度或者行为会碰壁的，而且会让你的自信心大打折扣。</p>
<blockquote>
<p>于是，有这么多情绪在你心里，你上学期为啥活过来了呢？你可能会问。</p>
</blockquote>
<p>是，我上学期确实找到了一些方法，但是究其根本，还要以“我将生命看得很重要”作为铺垫。我自很小的时候就意识到人是会死的，这曾经让年少的我长达一个星期害怕着死亡。看到孩子挺年轻就因为事故失去了自己或者双亲的场景，看到因为压力中学生自杀，我会觉得冷，身体发抖，我不太会流泪，但是这可能也是我感觉到伤心的一个标志吧。我不想看到谁因为自己的某些情绪，某些外物放弃自己的生命或者伤害他人的生命。现在的我并不害怕死亡，因为死亡是几乎平等的，因为每个人都会迎来生命的尽头，万物亦然，重要的是要保护好自己，在有限的生命里找到自己想做的事情，并将它做好，但我仍然尊重生命，因为生命意味着一个人的全部，我们无权伤害、夺去。</p>
<p>然后就是方法了，从”做一个牛逼的大学生“的浪前课程里，我学到了“虚拟思维”这件为我现在的心态保底的道理（别急呢，还没到文首提到的那个道理）。可以试想一下如果这个世界是虚拟的，除了你全是由计算机推演得到的一个游戏，你的身体（容器）每一天都会更换。每天早晨我们都被注入上一天的记忆，接受着我们固有的“人格设定”，那么你要达成的，不过是一些数据，如果达不到就继续玩呗，一定会有完美结局。你在做事之中形成的烦恼、压力，其实都是游戏设计者为了限制你的发展，将各个人的命运导引到固定的结果的工具。因而借助这些想法，可以合理地接受过去，可以忘却阻力奔向未来。但我认为这个道理还没有完全地解决我的问题，遇到烦恼在脑子里说”是虚拟的“这件事效力会随着你使用的次数以及焦虑的程度上升而下降，而且明白这个道理的时间也忒晚点。另外跑步也是我的方法之一，我们都会跑校园跑（有规定的），尝试放开自己的我曾经一两个月在操场上唱着自己喜欢的歌跑步，这是疏解情绪的好办法，尝试过的人都知道。因为自己瘦下来了也挺有成就感。最后就是自己确实挺喜欢出去骑自行车的，尤其自己出去淋雨，很自由很解脱。</p>
<p><img src="/img/pic.jpg" alt="一次骑自行车拍的"></p>
<p>我仍然没有解决完毕这个问题，因为上文的两种方法都是“瞬时性地”解决你的焦虑烦恼。我的核心问题还没有解决：目标在哪里，我要做什么，我为啥不需要和同学们卷。</p>
<p>而这里也就引出了我们文首提到的那个道理：<strong>区分事实与观点</strong>。</p>
<p>你可能不会觉得这个道理很高大上，挺短的说实话。但是在实践之中，这个道理的使用效力没有一丝的改变，在目标规划的辅助之下，它是我的强大心态后盾。</p>
<p>何为区分事实与观点呢？就是在规划的基础上，对来自外界以及自己对自己的怀疑，清晰的认识到这些都是观点，而不能作为你判定自己状态的思考。如果进入了消极的状态，想想自己是因为哪种想法进入的，想想这个想法是事实还是观点，是事实，就努力行动，解决问题；是观点，往往是自己骗自己，不要管它。在生活中，将好的与正能量的东西视为事实，向自己提醒。借助这个道理，我逃出了内卷的漩涡，逃出了自我的内耗束缚，正向地生活着。</p>
<p>我开始规律地洗漱与睡眠，因为它能够让我身体健康。开始与人们交流自己的真实感受，我发现自己能够与人们产生共鸣了。我开始觉得合群并不重要，它并不是一个需要你自卑的东西。我也深刻认识到，只要有梦想，我们的方向真的不一样，内卷与内耗都十分的不必要。我开始规划自己的学习，实现自己想要的效果。所以现在我恒久地走在自己的路上，看着自己的目标一点点实现。期待在路上遇到不同的人…</p>
<p>最后想和你说：一个明确的规划，一个不需要顾及别人观点的理由，足以让你专注于自己的事情。<br>足以让你显露出自己的个性，你也终将找到自己的梦想，没必要将他人作为自己的目标。</p>
<p><img src="/img/scheme1.png" alt="整体规划的一角"></p>
<p><img src="/img/scheme2.png" alt="学习规划的一角"></p>
<p>最后，加油，希望你能够早日走出阴霾！</p>
<blockquote>
<p>End…</p>
</blockquote>
]]></content>
      <tags>
        <tag>心态调整</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习：快速幂 以及 这几天搞机心得</title>
    <url>/2024/01/26/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%B9%82-%E4%BB%A5%E5%8F%8A-%E8%BF%99%E5%87%A0%E5%A4%A9%E6%90%9E%E6%9C%BA%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>随着自己学习的进行，感觉需要尝试的东西越来越多了。<br>比如C++的学习、HTML学习，以及算法与数据结构。<br>感觉又得重新规划一下了，不过我能挺过去的。<br>等到开学我会变得大不一样的。</p>
<span id="more"></span>

<h2 id="1-快速幂"><a href="#1-快速幂" class="headerlink" title="1.快速幂"></a>1.快速幂</h2><p>今天尝试写完了乘方的程序，也就是补齐了负数次方的结果，但是还是通不过，因为时间耗费太长，看到leetcode上还有这样的结果：样例全部通过了，但时间耗费太长，所以判未通过。。这与我们的OJ判法还是有点差别的。</p>
<p>看过题解之后，我又学会了一个之前听过的算法，它叫做快速幂。<br>实际上就是上一次讲的算法，只不过我理解的有偏差，所以在实现上它的次数降落并不与算法中一样，计算起来还是有重复的步数（比如5次方不是偶数了，于是就直接开始按照老方法算了，更别说更大的奇数了）。</p>
<p>所以下面为快速幂的代码展示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">quickpower</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">double</span> result = quickpower(x, n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span> ? result * result : result * result * x; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">compute</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> N = n;</span><br><span class="line">    <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickpower(x, N) : (<span class="number">1.0</span>) / quickpower(x, -N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的次数只需要算一遍，<br>而且次数的个数也比之前少了很多。<br>时间复杂度O(logn).</p>
<h2 id="2-AndroidX86-9-0-试用心得"><a href="#2-AndroidX86-9-0-试用心得" class="headerlink" title="2.AndroidX86 9.0 试用心得"></a>2.AndroidX86 9.0 试用心得</h2><blockquote>
<p>我还是挺喜欢搞机的，一个平平无奇的机子，<br>一开始研究其中底层的东西一切都变得有趣起来了。</p>
</blockquote>
<p>曾经尝试过使用系统进程唤起的方式一个一个打开系统进程，这个过程真的还有不少有趣的东西，我也不知道在找什么，但是就是很能给人新奇与发现的感觉，那时候第一次做也是心怀着上网与安装应用的目的，去找寻系统能不能有办法恢复出厂设置（当时学生平板给安了一个拥有超级用户权限的学习软件控制着的，不准恢复出厂设置），找到了点恢复出厂设置的那个按键，点之后什么都没发生，不过那之后还是很乐于做这件事。</p>
<p>现在找老机子就是纯属发掘里面的潜能了。<br>我一般就是看美观、干净的程度以及使用的便利程度</p>
<p>三年级的时候买的？或者更早，那台机子已经在我们家很多年了，这几天看到了<code>AndroidX86</code>，在虚拟机上的清晰度太差了，而且声音也不达标，断断续续的。感觉在电脑上安装安卓系统还挺好玩的，要是再安点软件没准能够让它重新焕发生机，一向喜欢这种事的我今天捣鼓了一天，但过程也是异常的艰辛，之前的文件对于现在没用的很多了，都需要删除来给新系统腾空，更别说因为各种广告垃圾软件系统贼卡。</p>
<p>下午，利用U盘刷机，安上了想要的AndroidX86系统，甚至没有按照教程，一通乱点（实际上应该是一开始点错了，然后它没有退出选项。。）。安上了又觉得哪里都看不上眼，输入法没有中文，很多软件好像是因为架构的原因安不上，而且联网还有问题，你必须断网情况下才能过第一次使用的引导程序。另外因为一开始点错了，内存只有可怜的4个G，可用的只有700多M。而且因为是老机子，也是很卡，这接二连三的错误劝退了我，不太想弄了，弄完已经是下午5点了。不过除此之外还把之前老系统刷回了Win7，现在正常使用是一点问题没有的，也挺快的，可以当个巨型U盘来用嘿嘿。</p>
<p>要不是初三因为安装了应用平板被老爸摔了，<br>害，现在还能用那个平板呢，<br>感觉屏幕比现在用的大多了，而且自定义性也高，应该能做得不错。</p>
<p>一天下来确实是挺累的，看着之前下过的游戏与之前的照片，花了大概是一上午的时间全部“检阅”了一遍吧，挺多的游戏现在仍然还在玩着，不过以前的时候也是挺爱尝试的，电脑里也有其他已经忘记的，回顾一遍也能想起来那时候玩游戏的开心，想起那个时候照片中的自己，是如何一步一步地成长为现在的我的。</p>
<p>反思过后，我可能就是那种丝毫不愿看着事情变得极坏极坏的人，如果一样东西只是因为年岁原因而被抛弃，或者被人们因为其他局限的观点而全盘否定，我会很反对，我想要发现它们中间的其他闪光点，我想让他们重新好起来。</p>
<p>我也是个怀旧的人，之前使用过的很多东西包括APP，我还是不厌其烦地看看他们现在是啥样子了，有的真的是随着时间而变得无人问津，举几个例子吧：小猿搜题、作业帮一课（其实作业帮本身也不太提起了），一起作业，手机乐园（之前可以与酷安以及应用汇抗衡的应用商店），7723游戏盒（这个知道的可能比较少，我从初中开始用，里面有个氛围挺好的资源交流论坛，但是现在已经关闭了，因为严格的审核政策。）不少改变还挺令人唏嘘的，这也是所谓的以史为鉴吧，看前几天发现的雨纸app，有时候还能够挖到宝呢！</p>
<p>所谓的记忆，流光。。</p>
<blockquote>
<p>End…</p>
</blockquote>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>搞机心得</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习：分治法的其他例子</title>
    <url>/2024/01/23/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%88%86%E6%B2%BB%E6%B3%95%E7%9A%84%E5%85%B6%E4%BB%96%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<p>今天也是挺多事的一天，主要的生活重心集中在编程与游戏上<br>编程上努力学习算法以及Javascript，把博客搞得更好看更有料<br>游戏最近很被崩坏三的剧情吸引，时间就上去了。</p>
<span id="more"></span>

<p>今天博客本来想要试试butterfly主题的，开了一天，实在是太多Bug<br>我这才想起之前删掉这个主题包的缘由。<br><code>_config.yml</code>文件是真的有点烦人，<br>改了一大通，但是因为其他主题文件中的问题以及node的很多问题<br>CSS渲染不出来，改了全没用，一点不带变的。</p>
<p>而且网上再怎么搜都是魔改教程，就有点，反衬。害。。</p>
<p>另外将之前学习的斐波那契数列的输出方式以及pow函数的正数部分给写完了。<br>想不到斐波那契数列还有这么多方式来输出，而且还与矩阵有关系。<br>但矩阵这个算法因为牵扯到浮点数与黄金比，在计算机上实现不了。<br>现在暂时就是中午想出来的递归以及线性版本。</p>
<h2 id="1-Pow函数-半成品"><a href="#1-Pow函数-半成品" class="headerlink" title="1.Pow函数(半成品)"></a>1.Pow函数(半成品)</h2><p>虽然Pow函数在C语言里可以直接用，<br>在其他语言中也有对乘n次方的表示<br>但是它的算法是确实可以优化的。</p>
<!--之所以说是半成品，是因为它只能算正数次幂-->

<p>说到乘方，我们一般会直接使用一个n次的循环来对基数乘n次方。<br>也就是下面的写法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">ntimesa_naive</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> time = n;</span><br><span class="line">    a -= <span class="number">1</span>; <span class="comment">//如果0到a的话实际是a+1次。</span></span><br><span class="line">    <span class="keyword">while</span>(a--)</span><br><span class="line">        n *= time;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，实际上我们可以将这个O(n)的算法进行改进，<br>因为有一些计算的过程其实是可以省去的。</p>
<p>还是以分治法的思路，我们可以将这个问题的规模降到n&#x2F;2或更小吗？<br>答案是肯定的。具体就是下面的式子了。</p>
<blockquote>
<p>如果次数n为偶数，那么就等于n&#x2F;2次乘n&#x2F;2次<br>如果次数n为奇数，那么就直接使用上方的算法运算即可。</p>
</blockquote>
<p>如此就可以使用递归的方式实现了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">ntimesa_recursion</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> time = n;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ntimesa_recursion(a / <span class="number">2</span>, n) * ntimesa_recursion(a / <span class="number">2</span>, n);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            a -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(a--)</span><br><span class="line">                n *= time;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数还需要进一步的完善，因为之前试着实现了一下负数的部分。<br>发现在应对leetcode的题目的时候还是会时间超限。<br>我感觉有些数应该对基数讨论，这样应该会更好一些。<br>比如算1的2147932478(Whatever)次方，结果是1.</p>
<p>今天试着进一步实现一下吧。</p>
<h2 id="2-斐波那契数列"><a href="#2-斐波那契数列" class="headerlink" title="2.斐波那契数列"></a>2.斐波那契数列</h2><p>1.<strong>定义递归法</strong></p>
<ul>
<li><p>算法展示<br>  我们都已经知道这个数列是如何递推出来的了。<br>  也就是这个式子 F(n) &#x3D; F(n - 1) + F(n - 2)<br>  现在只需要将这个式子补充一些条件其实就可以直接使用了。<br>  首先得知道第一项0与第二项1，<br>  这样第三项及之后的项才能够推出来。<br>  这样我们也就可以开写了。</p>
</li>
<li><p>代码展示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Fibonacci_Recursion</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Fibonacci_Recursion(n - <span class="number">1</span>) + Fibonacci_Recursion(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这样也就是不断地执行减1与减2的操作，直到这个数变成1或者0.<br>但是这样在n特别大的时候是特别慢的。</p>
<blockquote>
<p>想一想，对于中间的每一个数字，都需要两个数字来算出来，<br>这个结果已经是2的指数次方级别的了</p>
</blockquote>
<p>指数这就很可怕了，但是其中肯定有些明显可以优化的地方。<br>    比如，我们在算n-1项的时候其实已经算完了n-2项，<br>    但是两边却是完全独立的，<strong>数据的复用性很差。</strong></p>
<p>那么有什么办法能够算出第n项呢？<br>我们可以从第一项推到第n项。<br>虽然这个办法也快不到哪里去，但比之前的指数级别的速度可要强多了。<br>我们这一次直接将它的时间复杂度降到了<strong>O(n)</strong>.</p>
<p>2.<strong>线性递推法</strong></p>
<ul>
<li>算法展示<br>同样，我们仍然要给以后的计算提供条件，<br>但是我们计算的基础单位变成了an，an-1，an-2这三个数，<br>要提供三个数据。<br>由这三个数，我们是可以从1推到无穷大的（笑，如果计算机的储存空间允许的话）。</li>
</ul>
<p>出个小思考题</p>
<blockquote>
<p>如果现在an-2，an-1，an分别是1 2 3<br>如何编程将它们都推到下一项(an-2 &#x3D; 2 an - 1 &#x3D; 3 an &#x3D; 5)？</p>
</blockquote>
<p>其实可以这样想，对于新an，an其实是an-1，an-1其实是an-2.<br>往前也是一样的，又an-2 &#x3D; an - an-1。<br>全都推出来了。</p>
<ul>
<li>代码展示<br>于是我们就可以这样写了<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Fibonacci_Linear</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> anmin2 = <span class="number">1</span>, anmin1 = <span class="number">1</span>, an = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            an += anmin1;</span><br><span class="line">            anmin1 += anmin2;</span><br><span class="line">            anmin2 = an - anmin1;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> an;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注：其中的n为第n项，这里的数列也许不标准，因为第一项并不是0而是1。</p>
<p>然后就是有关于矩阵以及矩阵运算的内容了。<br>里面涉及的算法有些复杂，涉及的运算也很多，可以在算法导论这本书中查找到。<br>而且这里就不细讲了。</p>
<p><img src="/img/recursionsquaring.png"></p>
<p><img src="/img/stlssalgo.png"></p>
<p>今晚从kmjj那里得到了一些对html文本的理解，<br>我起初是想解决输出换行的问题。<br>没成想反思下自己的这个想法其实不太好，<br>因为这并不是一个编程语言。<br>你要不换行直接写一行里就行。</p>
<p>过两天花点时间尝试换一下C++，<br>使用一些库以及数据结构。<br>回到面向对象语言。</p>
<p>这就是这一天学习的内容了，<br>因为实现原因内容并不多，明天要继续努力了。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript学习：一个新起点</title>
    <url>/2024/01/22/Javascript%E5%AD%A6%E4%B9%A0%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%96%B0%E8%B5%B7%E7%82%B9/</url>
    <content><![CDATA[<p>今天过的是真的开心啊，<br>不仅与之前的好朋友聊了聊，还学习了我一直都想要学习的东西，那就是前端制作网站。<br>想起之前玩趣站 (<a href="http://www.youquhome.com/">www.youquhome.com</a>) 的时候，那个时候真的是见了不少新奇的网站设计<br>有在夜空中放烟花的，有像云朵的时钟，还有各种H5小游戏。<br>那时候其实就已经有点心思想学H5、CSS以及JS了，<br>嘿嘿，还是之前上外网经历给我的加成，甚至那时候我已经接触过几个JS命令了。</p>
<span id="more"></span>

<p><img src="/img/Chathappy.jpg" alt="嘿嘿"></p>
<p>你要是一路看到这里肯定说：“于，你咋变心这么快，前几天不还好好学着算法的吗?”。<br>要怪也怪我的博客，要怪也怪我，今天的轨迹也是十分离谱（哈哈哈）。</p>
<p>今天看着自己这几天写过的博客，还有总体的博客页面突发奇想。<br>“我是不是也能像kmjj那样自己对于主题进行二次加工？”<br>于是上网上找hexo主题的开发教程，需要node.js基础，找到了教程。<br>然后跳到了自己之前几天在搞的Windows中的LinuxWSL系统<br>想在里面安个浏览器，之后就能一直在Terminal环境下js编程了，而且界面也挺干净的<br>安了半天实在是没搞定，能安上，但是打不开。<br>最后听人家官方说：“我们还不支持软件安装，只能运行命令行下的软件”<br><strong>果断放弃，害，浪费时间！</strong></p>
<p>因为nodejs使用的是JS文件编程，之前用的Sublime Text不能编译运行，<br>我又去网上找资料配置好了错误百出的VsCode。<br>最终在终端上成功运行了自己的第一条JS指令。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>呼，到这一步，已经是上午的12点了，<br>不过接触到一个新世界，我的热情还没有退下。<br>于是继续在 (<a href="http://www.liaoxuefeng.com/">www.liaoxuefeng.com</a>) 上学NodeJS。<br>直到有些概念感觉迷迷糊糊，才知道它需要一些JS的基础。<br>在下午充好电之后，我开始了JS的探索。</p>
<p>在这其间，还发生了一件给我动力的事情。<br>无意刷手机的时候注意到了平板上的一个app<br>也是我比较怀旧吧，这个app的动态壁纸还挺有说法的，<br>模拟雨的效果真的是我见过的最顶的了。</p>
<p><img src="/img/Rainpaper.jpg" alt="必应搜雨纸或Rainpaper可能能搜到"></p>
<p>效果如下：</p>
<p><img src="/img/Raining.jpg" alt="绝美！"></p>
<p>这的雨滴的大小与降水概率以及雾度还有后面的图片都是可以改的。<br>就真的很干净很好看，于是我想找到这个app的源码，<br>借着自己现在知道的编程知识，想实现一下这个效果。<br>但是也可叹啊，这个软件已经很久了，它的github源码已经被删的干干净净了。<br>我能找到的就只有一个提供这个雨滴效果的网站。<br>因为它的效果是用WebGL渲染的，我们的任务又回到了JS上。</p>
<p>于是今晚又一通学就搞到了现在，做出了一个HTML文件。<br>它的源码就在下面了！</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>MY First HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;h1&gt;Moniwarmth&lt;/h1&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;p&gt;And his little cute icon!:)&lt;/p&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">clickfunction</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">&#123;</span></span><br><span class="line"><span class="language-javascript">    x = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;Greetings&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span>(x == <span class="literal">null</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;Oops! We don&#x27;t find the expected text!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">else</span> </span></span><br><span class="line"><span class="language-javascript">    &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">alert</span>(<span class="string">&quot;Hahaha, any problems?&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      x.<span class="property">innerHTML</span> = <span class="string">&quot;Hello Js World!!&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">changeImage</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">&#123;</span></span><br><span class="line"><span class="language-javascript">    element=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myimage&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (element.<span class="property">src</span>.<span class="title function_">match</span>(<span class="string">&quot;sit&quot;</span>))</span></span><br><span class="line"><span class="language-javascript">    &#123;</span></span><br><span class="line"><span class="language-javascript">        element.<span class="property">src</span>=<span class="string">&quot;girl.jpg&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">else</span></span></span><br><span class="line"><span class="language-javascript">    &#123;</span></span><br><span class="line"><span class="language-javascript">        element.<span class="property">src</span>=<span class="string">&quot;girlsit.gif&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span> = <span class="string">&quot;Greetings&quot;</span>&gt;</span></span><br><span class="line">  Hello, this is the first step of my webplaying.</span><br><span class="line">  Hope that I can stick to it!!</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;myimage&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;changeImage()&quot;</span> <span class="attr">src</span>=<span class="string">&quot;girl.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;180&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button_type</span> = <span class="string">&quot;button&quot;</span> <span class="attr">onclick</span> = <span class="string">&quot;clickfunction()&quot;</span>&gt;</span>点我!(本来在HTML中可以点图片出现一张动态图, 这里被覆盖了 ToT)<span class="tag">&lt;/<span class="name">button_type</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;gifgirl&quot;</span> <span class="attr">src</span> = <span class="string">&quot;girlsit.gif&quot;</span> <span class="attr">width</span> = <span class="string">&quot;180&quot;</span> <span class="attr">height</span> = <span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>嘿嘿, 这是我的第一个HTML文件,Javascript学习的第一步!! <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>嘿嘿，就一个小网页，还是有点复杂的吧，不过做出来当即就能传到网站上，挺有成就感的呢！</p>
<p>今天做的事情真的很让我找到了热爱的感觉。–一直学习，直到电脑没电，充电之后继续学。<br>今天当即就做出了一个HTML小页面，你可能也注意到了在左边的小栏里有一个“创作”。<br>那里我还暂时不知道要放什么，于是先写了点欢迎语，放了两张小图片。<br>这个页面的内容就是我制作的HTML文件。</p>
<p>算法的学习还是不会轻易放弃的，JS的学习也不会结束，一切都自热爱与感动而起！<br><strong>继续奋斗，终会把路越走越宽！</strong></p>
]]></content>
      <tags>
        <tag>JS学习</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习：分治法中的二分查找</title>
    <url>/2024/01/21/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%88%86%E6%B2%BB%E6%B3%95%E4%B8%AD%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>今天本应学习的是分治法，但今天的轨迹就是有点奇怪（哈）<br>我看着老师讲着讲着讲到了我可能接触过的算法了，并且Leetcode上还能够练题。<br>于是看完老师演示分治法的例子：归并排序、二分查找、求平方。<br>然后就开始不由自主地想要实现它，想了半天没有搞出来，查找网上才学会的。</p>
<span id="more"></span>

<p>今天也在Leetcode上练了几道有关于二分查找的题目，<br>开始的时候感觉 - 害，不就一个查找吗，直接当成函数，还能给我出什么题？！<br>尝试了一个困难难度的题根本做不出来（悲）<br>于是从简单题做起了，感觉知道了二分查找的很多不同的用法。</p>
<p>现在卡在了一道统计二叉树节点的题目上。<br>问题的关键是我现在不知道我这个想法对不对，<br>如果都是从1开始的话，那么其实不需要结构体与指针<br>其实就是在统计元素个数。<br>感觉想得过分简单了。</p>
<p><img src="/img/BinaryTreenum.png" alt="题目"></p>
<p>分治法还是一个挺笼统的概念，它不是一个算法，而是一个设计算法的方法。<br>主要可以分为三步：分、治以及组合。</p>
<p>老师使用了一个奇怪的比喻：<br>先将一块地分开成几个小部分，<br>分别统治它们，就相当于统治了这个总体。<br>不过还挺形象的。<br>我想起了函数的使用目的，也是为了拆分问题。</p>
<p>分也就是将一个问题划分成若干个小问题的过程。<br>治就是对于每一个问题进行解决的过程。<br>组合就是将这些小问题的答案组合形成最终的答案。<br>分治法衍生出的算法可能很多，但是它们的递归式基本都是相似的形式<br>也就是相似于主方法范式的那种。</p>
<blockquote>
<p>比如 归并的 T(n) &#x3D; 2 * T(n&#x2F;2) + Θ(n)<br>二分的T(n) &#x3D; T(n&#x2F;2) + Θ(1)</p>
</blockquote>
<p>接着就是上文讲到的那几个举例，也是我一天的轨迹转折的地方。</p>
<p>归并排序感觉现在已经不太想写了，<br>毕竟这个代码量与细节都挺复杂的，用qsort也挺好。<br>现在能够熟背的就是这个n^2的插入排序。<br>但是为了之后的效率我得尝试记忆一下更快的了</p>
<p>所以现在就说说二分查找吧，这是今天另一个值得讲的话题。</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>1.算法演示</p>
<p>还是给出一个<strong>有序的</strong>数组，我们想要在这个数组中查找一个数字。<br>一般来说我们肯定最朴素的想法是一个n的循环遍历数组找这个数<br>但是这个算法真的挺快的，它的时间复杂度是Θ(logn)</p>
<p><img src="/img/BinarySearch.gif" alt="来自于一个Python学习网站 www.penjee.com"></p>
<p>用分治法的思路来想这个问题，</p>
<blockquote>
<p>1.分 将一个数组分为大于中间数与小于中间数两部分。<br>2.治 如果搜索数小于中间数，去左边继续找<br>如果大于，去右边找。<br>3.混合，没啥操作。</p>
</blockquote>
<p>在图中我们看到是通过low与high这两个变量来控制mid这个变量，<br>进而来确定我们数组的左边与右边。<br>%%说实话我刚开始就是卡在了这里，<br>我想用数组长度n来限定，想了很久没想出来右边怎么搞。%%</p>
<p>那么分别根据递归与它的定义，我们可以写出两种表示的形式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BinarySearch_Concept</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> low = <span class="number">0</span>, high = n - <span class="number">1</span>, mid;</span><br><span class="line">	<span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">	&#123;</span><br><span class="line">		mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(x &lt; a[mid])</span><br><span class="line">			high = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(x &gt; a[mid])</span><br><span class="line">			low = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BinarySearch_Recursion</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(low &gt; high) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//可以这样写 int mid = ((right - left) &gt;&gt; 1) + left;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(x == a[mid]) <span class="keyword">return</span> mid;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x &gt; a[mid])</span><br><span class="line">	&#123;</span><br><span class="line">		low = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> BinarySearch_Recursion(a, low, high, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; a[mid])</span><br><span class="line">	&#123;</span><br><span class="line">		high = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> BinarySearch_Recursion(a, low, high, x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注 Concept为概念，Recursion为递归。</span></span><br></pre></td></tr></table></figure>

<p>实际上只是一个思路两种写法而已，<br>这两种情况的执行时间应该是差不多的。</p>
<p>今天就是套这个模版然后改了点代码，<br>有的时候还超过了不少做过这道题的人。<br>空间复杂度上或者有时在时间复杂度上。<br>官方题解也不少可以学习的地方。</p>
<p>期望明天的学习，期望明天能够做出更多的题目，自己能够思考更多。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习：解递归式以及渐进符号</title>
    <url>/2024/01/20/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%A7%A3%E9%80%92%E5%BD%92%E5%BC%8F%E4%BB%A5%E5%8F%8A%E6%B8%90%E8%BF%9B%E7%AC%A6%E5%8F%B7/</url>
    <content><![CDATA[<p>事情变得有趣起来了，今天讲的是关于离散数学的内容，没有涉及纯粹的算法。<br>今天的课程内容属实是有点挑战性了，不管是能不能听下去还是理解成本。</p>
<span id="more"></span>
<p>今天的生活状态总体来说不太好，听完课就不太知道干啥了，<br>尤其是这样不涉及编程，不能支撑做题的，<br>课上的内容消化已经耗能较高，我就懒得做更多的探究。<br>在家里就容易活在固定模式里。<br>出去也找不到玩的，复读的同学好像也还没放假，找其他人有点胆怯，<br>总感觉离开家成本太大，在家里还得看妹妹。<br>玩游戏吧，开放世界或者沙盒的那种总感觉玩了特容易上瘾，而且后劲很大。<br>对于时间还是挺吝啬的，玩不开心，总是活在欲望与爆发希望之中。<br>感觉玩个游戏都有些功利化了，要是没有啥固定的结果就是个while(1)循环了一样。<br>家里的东西并不一定比那里好吃，特别是姥姥姥爷在家的时候（笑）。</p>
<p>要是想破局的话，学做饭、尽兴做事与玩游戏，并且敢于走出去，<br>我不确定自己能不能行动起来，不过写这篇也就是对我的一个提醒了。</p>
<p>今天是彻底地对于之前还挺模糊的<strong>渐进符号</strong>下了精确的数学定义，所以这一篇也要像人家老师说的，纯粹是数学的讨论（但也是思维的挑战）。</p>
<p>昨天见过了几种常用的渐进符号，也就是O, Ω, Θ, 实际上除此之外还有o，ω，分别与对应的大小关系构成“严格关系”（比如O表示小于等于，o表示严格小于）</p>
<p>对于这些符号，现在给出定义</p>
<blockquote>
<p>1.O </p>
</blockquote>
<p>我们用f(n) &#x3D; O(g(n))形式来使用这个符号，<br>它的意义是，存在适当的c与n0，<br>使得对于所有的n &gt;&#x3D; n0, 满足0 &lt;&#x3D; f(n) &lt;&#x3D; c(g(n))</p>
<p>这里的O(g(n))符号表示的并不是另一个函数，而是一个集合，<br>所以这里的等于号就相当于一个属于符号∈<br>这里就如同一个原函数与原函数集的关系。</p>
<p>在昨天学习中已经接触到了这些符号都是有渐进的观点的，<br>也就是省去低阶项与系数，所以除去对于f(n)非负的假设<br>右边部分表示的是f(n) &lt;&#x3D; c(g(n)).<br>也即O表示小于等于的一个集合，这个小于等于包含很多含义。<br>有参数，阶次更低等等。</p>
<p>在表达式中，它可以与函数一起使用（如O(g(n)）<br>被用来替代一个抽象函数<br>如f(n) &#x3D; n^3 + O(n ^ 2) 这个表达式表达一个“小于等于n^2的函数h(n)”<br>满足上面的函数关系。</p>
<p>那么已经有了上文的O的例子，其他符号理解起来也就简单一些了。</p>
<p><strong>Ω</strong>相当于<strong>渐进上</strong>的”<strong>大于等于</strong>“，<br><strong>o</strong>相当于<strong>渐进上</strong>的“<strong>小于</strong>”，ω相当于<strong>渐进上</strong>的“<strong>大于</strong>”。<br><strong>Θ</strong>只有大写，之前写错了，相当于O与Ω的交集，<br>可以理解成<strong>渐进上</strong>的”<strong>相等</strong>“。<br>相当于给最高项加上系数或者加一个至几个低阶项。</p>
<p>前提是对于足够大的n，<br>因为当n为一个常数的时候，这些符号的n都是Θ(1)。<br>而f(n)需要大于等于0，后面如果有低阶项的话需要保证n足够大<br>（这里的大也不一定是更大，我想是大小的意思，需要一个合适的大小）.</p>
<p>接着就是严格的部分了。<br><strong>解递归式</strong></p>
<p>就和定积分一样，它没有固定的方法，<br>我们需要学习很多的方法，然后看看哪一种更适合</p>
<blockquote>
<p>方法有三种<br>    1.代换法<br>    2.递归树法<br>    3.主方法</p>
</blockquote>
<p>主方法并不是主要的方法，只是用它是更为方便与固定的一条路。</p>
<h2 id="一-代换法"><a href="#一-代换法" class="headerlink" title="一. 代换法"></a>一. 代换法</h2><p>先听一下它的要求哈：</p>
<blockquote>
<p>第一步，猜答案，而且必须猜对它，<br>（但是你可以不知道常数系数，但是它的形式必须对）</p>
</blockquote>
<p>还是有点离谱哈，但是其实还行，给个例子就知道了。<br>实际上是根据自变量与函数值关系的变化来推，而且不需要管低阶项，</p>
<blockquote>
<p>T(n) &#x3D; 4 * T(n&#x2F;2) + n<br>（先看看，过会再和你说是如何猜的）</p>
</blockquote>
<p>我们一般是求上界，下界有时也会求。</p>
<p>假设我们猜想它是一个O(n^3)<br>那么自然T(k) &lt;&#x3D; k ^ 3 而且k &lt; n</p>
<p>展开原式然后小于等于右边式子即可，推出C &gt;&#x3D; 1时，<br>O(n^3)是一个上界<br>实际上这里只是一个比较宽的上界，就好像说它是小于n的10次方也可以<br>但是不准确。</p>
<p>下面就是猜的方法了，</p>
<blockquote>
<p>可以看出T(n)是T(n&#x2F;2)的四倍，然后n是n&#x2F;2的两倍，<br>是不是与n^2类似？<br>所以按照O(n^2)假设，类似做法一直改进假设即可。<br>想看解法，如下</p>
</blockquote>
<p><img src="/img/Processes.png"></p>
<p>但是这种方法往往太过于理论化（哈），我在面对这些式子的时候常常走神，写到一半就不知道自己的思路去哪里了，相比于第一种方法，第二种方法还是更直观一些。</p>
<h2 id="二-递归树法"><a href="#二-递归树法" class="headerlink" title="二. 递归树法"></a>二. 递归树法</h2><p>所以又是我们昨天见过的，看起来挺复杂，听上去也挺吓人的递归树。<br>它有时是不太严谨的，但是它是万能的，<br>可以用它来猜正确答案，然后再用第一种方法来做。</p>
<blockquote>
<p>出一个例子：<br>T(n) &#x3D; T(n&#x2F;4) + T(n&#x2F;2) + n^2<br>（灵魂画手预警！！）</p>
</blockquote>
<p><img src="/img/Treeexample.png"></p>
<p>分支总数也就是分到最后Θ(1)的数量。–<br>虽然估测不出来，但是一定小于n<br>树高度就是这个递归树总共有几层。 – log2n<br>然后一层一层地找规律并求和。</p>
<blockquote>
<p>第一层求和为 n^2<br>第二层求和为5&#x2F;16n ^ 2<br>第三层求和为25&#x2F;256n ^ 2</p>
</blockquote>
<p>这样我们发现这个求和的结果是按照几何级数递减（小数等比）的，<br>所以我们就直接等比数列求和，或者也不用求和，<br>结果一定是与n^2有关的式子，而且系数一定是大于1小于2的。<br>就是O(n ^ 2)(这里有点存疑，我还得问问。)</p>
<h2 id="3-主方法"><a href="#3-主方法" class="headerlink" title="3.主方法"></a>3.主方法</h2><p>它被称为“主”，是因为<br>它只能够被用到特定形式的递归式中 – 符合T(n) &#x3D; aT(n&#x2F;b) + f(n)<br>系数需要符合标准 – a必须&gt;&#x3D; 1 b&gt;1<br>而且还得满足三种情况的其中一种（如下三种）。</p>
<p>对于每一种情况都有一个渐进的定理，<br>这些定理都可以使用递归树证明出来。</p>
<p><strong>定理情况</strong><br>比较f(n) 与 n^logba的相对大小</p>
<ul>
<li>当f(n) &#x3D; O(n^（logba - ε）），对于大于0的ε<br>  T(n) &#x3D; Θ(n^logba)</li>
<li>2.当f(n) &#x3D; Θ(n^logba*(log2n)^k) k&gt;&#x3D;0<br> T(n) &#x3D; Θ(n^logba * log2n^(k+1))</li>
<li>3.当f(n)比n^logba增长的快<br>  f(n) &#x3D; Ω(n^(logba+ε)) ,对于大于0的ε<br>  而且f(n)要不断变小(af(n&#x2F;b) &lt;&#x3D; (1 - ε’)f(n) ε’ &gt; 0<br>  递归树的下一层要严格小于上一层<br>  T(n) &#x3D; Θ(f(n))</li>
</ul>
<p>这就是今天学习的递归树以及渐进符号内容，今天这样说来也收获了不少的东西呢！继续加油。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习：归并排序以及插入排序</title>
    <url>/2024/01/20/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E4%BB%A5%E5%8F%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>今天是大学第一个寒假的第一天，昨天玩了半天。</p>
<span id="more"></span>
<p>到了晚上临时起志：<br>既然上个暑假啥都没学精，那么这个寒假还是集中一个目标尽力往前进吧。<br>于是在B站上翻视频，一直到了23点。</p>
<p>今天找到了点生活的奔头，看了MIT学院的算法课程，又学习了两种排序方法，<br>虽然不像之前那么多事情了，如果有啥别的重要的话再说嘛，现在才第一天。<br>心里也想着，既然生活又有希望起来了，期待下学期的精彩旅途。<br>因为我一直都在说着：放假了就快开学了，<br>这样只看起点终点就很给人压迫，所以我还是喜欢去把每一天过得尽量好。</p>
<p>今天学习了归并排序（Merge Sort）与插入排序（Insertion Sort）<br>经过1-2小时的代码编辑，两种算法都已经以C语言实现完毕了，<br>这里就再复盘一下自己今天学习过的内容。<br>看到应该已经是第二天了，不过都一样。</p>
<h2 id="1-算法分析"><a href="#1-算法分析" class="headerlink" title="1. 算法分析"></a>1. 算法分析</h2><p>对于一个算法，注重的是它的性能，性能并不是最重要的，<br>但在软件设计过程中，它充当着一种货币，可以通过损失性能来换取其他的特性。</p>
<p>一般来说，分析算法有三种方式：<br>    1.最坏情况分析<br>    2.平均值分析<br>    3.最好情况分析</p>
<p>这里的情况指的是对于不同数据的运行时间，<br>我们认为时间T(n)与输入的数组大小n是一个相关映射。</p>
<p>最坏情况分析就是对于(1, n)下所有的输入中的时间最大值。<br>最好情况分析就是同理的最大值，但是并不一定反映程序运行的一般情况。</p>
<p>平均值严谨来说应该是时间期望，也就是每种情况的时间乘发生概率求和。<br>概率无从可知，所以我们需要假设一些概率分布模型。</p>
<h2 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h2><ol>
<li>算法演示<blockquote>
<p>代码毕竟只是表达它而已，理解它能够让我们自己写出它来。</p>
</blockquote>
</li>
</ol>
<p>设想一个序列，我们用连续的小方格表示。<br><img src="/img/InsertionSort.png" alt="插入排序"><br>从2开始遍历数组（假定下标从1开始），然后对于每一个元素进行上图的操作。<br>上图的操作，就好像是移动前面的元素，使得中间空出一个合适的位置，<br>然后将这个拿出来的<code>key</code>插入这个位置一样。</p>
<ol start="2">
<li>代码表示<br> 对于一个下标从1到n的数组a<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">	key = a[j];</span><br><span class="line">	i = j - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(a[i] &gt; key &amp;&amp; i &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i + <span class="number">1</span>] = a[i];</span><br><span class="line">		i = i - <span class="number">1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	a[i + <span class="number">1</span>] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>实现的方法极其易懂，想记住打几遍代码也可以<br>道理就与上图中讲的类似。</p>
<p>当然，我们在C语言中的下标是从0开始的，<br>这样我们可以将<code>j</code>的初始值改变为<code>1</code>，将i的限定条件改为<code>i &gt;= 0</code><br>就可以对平常的C语言数组使用了。</p>
<ol start="3">
<li>算法分析</li>
</ol>
<p>一般来说，比较性能有两种方式：<br>    一个是不同机器相同算法的相对速度<br>    一个是不同算法相同机器的绝对速度</p>
<p>描述时间复杂度的符号有O、θ或者Ω，它们叫做渐进符号。<br>渐进分析是算法中的一个伟大的观点，<br>因为它不仅能够反映相对速度的大小，还能反映绝对速度的大小。<br>这些符号如何使用呢？</p>
<p>步骤<br>    1.将一个式子中的低阶项去掉。<br>    2.将最高阶的参数去掉。</p>
<p>比如一个式子 y &#x3D; 3 * x^3 + 2 * x^2 （x^2即为x的平方）<br>    去掉低阶项，则为y &#x3D; 3 * x^3<br>    去掉最高阶参数，则为θ(x^3).<br>（这个式子，是通过对于程序所有语句执行的次数累加的结果）</p>
<p>这就是我们说的时间复杂度刻画方式，实际上复杂度阶数大的时间并不一定大，<br>只是增长过程中一定能够找到超过复杂度阶小的时间的点，之后就一直比它大。<br>这是个临界点。</p>
<ul>
<li>最坏情况分析<br>  对于这个算法，它的最坏情况即为完全逆序的情况，需要排序与移动项数n次，假设运行每一个语句的时间都是相等的常数C。</li>
</ul>
<p>首先是一个2~n的循环，然后是一个从j - 1到0的循环</p>
<blockquote>
<p>(j 2<del>n)ΣjC C是一个常数，从1到n - 1.<br>这样jC也就是θ(j)，所以就变成了 (j 2</del>n)Σθ(j)<br>因为每一项都是j * θ(j)，一共有n项，所以相当于θ(n ^ 2)</p>
</blockquote>
<p>说实话，我不觉得排序是很高端的算法，甚至都不算算法。<br>至少在很久之前只知道选择与冒泡的时候是这样想的。<br>只觉得那些听不懂的，比如最短路径的迪杰斯特拉、二分查找、广度优先搜索这些才是。<br>实际上，面对这些较为简单的算法，我们反而更轻松地学习对于一个算法如何分析。</p>
<h2 id="3-归并排序"><a href="#3-归并排序" class="headerlink" title="3. 归并排序"></a>3. 归并排序</h2><ol>
<li>算法演示</li>
</ol>
<p><img src="/img/MergeSort.png" alt="归并排序"></p>
<p>这个算法看起来并不是很难，但是实现起来实在不容易，我这里是写了约90行代码。<br>它的道理就是，如果总共只有一个元素，那么就返回这个元素。<br>如果不是，就是两边先排序再归并，<br>归并方式就是挨个比，然后移除元素，直到所有元素都被移到排序后表。<br>实际上可以使用函数递归，这里还用的不熟练。</p>
<ol start="2">
<li>代码演示</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> l = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//i为a的下标，j位b的下标，l为c也就是排序后表的下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//在表的最后一个元素没有被去掉的时候</span></span><br><span class="line">	<span class="keyword">if</span>(i != (n / <span class="number">2</span>) &amp;&amp; j != n - (n / <span class="number">2</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i] &gt; b[j])</span><br><span class="line">		&#123;	</span><br><span class="line">			c[l] = b[j];</span><br><span class="line">			j += <span class="number">1</span>;</span><br><span class="line">			l += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a[i] &lt; b[j])</span><br><span class="line">		&#123;</span><br><span class="line">			c[l] = a[i];</span><br><span class="line">			i += <span class="number">1</span>;</span><br><span class="line">			l += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a[i] == b[j])</span><br><span class="line">		&#123;</span><br><span class="line">			c[l] = a[i];</span><br><span class="line">			l += <span class="number">1</span>;</span><br><span class="line">			c[l] = b[j];</span><br><span class="line">			i += <span class="number">1</span>;</span><br><span class="line">			j += <span class="number">1</span>;</span><br><span class="line">			l += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//左表的最后一个元素被去掉</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(i == n / <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(;j &lt; n - (n / <span class="number">2</span>);j++)</span><br><span class="line">			c[l++] = b[j];</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//右表的最后一个元素被去掉</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(j == n - (n / <span class="number">2</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(;i &lt; n / <span class="number">2</span>;i++)</span><br><span class="line">			c[l++] = a[i];</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>算法分析<br>对于这个算法，课程使用了递归树的模型<br> 对于两个表的排序，需要两个T(n&#x2F;2)的时间，<br> 对于最后的归并，因为只是对于n个元素的操作，所以为θ(n)的时间。</li>
</ol>
<p>最后的时间就是T(n) &#x3D; 2 * T(n&#x2F;2) + θ(n)</p>
<p><img src="/img/RecursionTree.png" alt="递归树"></p>
<p>递归树还没有整体学习，现在需要知道的就是，这个递归树的高度是log2n，最后的节点数是θ(n).<br>总共加起来等于θ(n) + logn * θ(n) 省去第一项就是θ(n * logn)，这样的话在性能上是优于插入排序的，而且它的临界点只在30左右，这也就是说归并排序在大多数情况下都是更快的。</p>
<p>开了个好头，总之希望好运，希望寒假快乐。</p>
<blockquote>
<p>End…</p>
</blockquote>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用结构体</title>
    <url>/2024/01/04/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<p> 结构体，是构造类型的一种，也就是由基本类型构造的类型。<br> 构造类型：结构体struct、联合体union、枚举类型enum。</p>
<h2 id="1-定性："><a href="#1-定性：" class="headerlink" title="1. 定性："></a>1. 定性：</h2><p>新的“数据类型”。</p>
<h2 id="2-意义："><a href="#2-意义：" class="headerlink" title="2. 意义："></a>2. 意义：</h2><p>有些信息的组成数据并不止一种，<br>囊括我们想要描述的大多数数据。(复合类型信息)。<br>数据形成一体。</p>
<h2 id="3-定义方式："><a href="#3-定义方式：" class="headerlink" title="3. 定义方式："></a>3. 定义方式：</h2><h3 id="1-类型定义（注意最后的分号）"><a href="#1-类型定义（注意最后的分号）" class="headerlink" title="1. 类型定义（注意最后的分号）"></a>1. 类型定义（注意最后的分号）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体类型名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	类型名 成员名;</span><br><span class="line">&#125;;<span class="comment">//别忘了分号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最近学到的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> 结构体类型名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	类型名 成员名;</span><br><span class="line">&#125; 你想要的简化名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> 类型名 简化名;</span><br><span class="line"><span class="comment">//typedef就是为了给类型起别名用的</span></span><br></pre></td></tr></table></figure>

<p>内部的单个变量类型叫做<strong>成员</strong>。<br><strong>主要创建在主函数外部</strong>。</p>
<h3 id="2-变量定义"><a href="#2-变量定义" class="headerlink" title="2. 变量定义"></a>2. 变量定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//变量定义方式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> 结构体类型名 变量名;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义并赋初值（初始化）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> 结构体类型名 变量名 =</span> &#123;常量<span class="number">1</span>, 常量<span class="number">2.</span>..&#125;;</span><br><span class="line"><span class="comment">//常量的顺序对应定义类型的顺序。</span></span><br></pre></td></tr></table></figure>

<h2 id="4-数据存储与读取"><a href="#4-数据存储与读取" class="headerlink" title="4. 数据存储与读取"></a>4. 数据存储与读取</h2><p>使用索引对应成员的运算符： -&gt;(指针，左边是地址，右边是成员名) &#x2F; .（左边，索引成员名）<br>其他一样</p>
<blockquote>
<p>额外提醒: 数组不能用&#x3D;，结构体可以。–数组是类型不是地址。</p>
</blockquote>
<h2 id="参考-典型例子"><a href="#参考-典型例子" class="headerlink" title="参考-典型例子"></a>参考-典型例子</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// 结构体。</span></span><br><span class="line"><span class="comment">//构造类型：结构体struct、联合体union、枚举类型enum。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stud</span>;</span></span><br><span class="line"><span class="comment">//typedef 给类型起别名。</span></span><br><span class="line"><span class="comment">//typedef 已经存在的名 新类型名;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n, minage;</span><br><span class="line">	stud stu1;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="type">char</span> minname[<span class="number">55</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>,stu1.name, &amp;stu1.age);</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">strcpy</span>(minname, stu1.name);</span><br><span class="line">			minage = stu1.age;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(stu1.age &lt; minage)</span><br><span class="line">		&#123;</span><br><span class="line">			minage = stu1.age;</span><br><span class="line">			<span class="built_in">strcpy</span>(minname, stu1.name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, minname);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般在一个东西的多个方面给予数据，用这些数据来排序比大小等等。</p>
]]></content>
      <tags>
        <tag>C语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串函数</title>
    <url>/2024/01/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>下为老师上课时讲过的字符串函数。</p>
<h1 id="字符串函数"><a href="#字符串函数" class="headerlink" title="&gt;&gt;字符串函数"></a>&gt;&gt;字符串函数</h1><blockquote>
<p>#include &lt;string.h&gt; 这是一个前提</p>
</blockquote>
<ol>
<li><p><code>strlen()</code>,求字符串长度。<br>与<code>sizeof</code>有区别，它不算<code>&#39;\0&#39;</code>这个字符。</p>
</li>
<li><p><code>strcpy(s1, s2)</code>，将s2拷贝到s1 (%% s1 &#x3D; s2 %%) 。<br>用赋值运算符<code>=</code>不行，编译错误，数组名为地址常量，不能被赋值。<br>挨个覆盖直到结束符，然后后面的依然保存，<br>但因为结束符的存在而，提早输出。</p>
</li>
<li><p><code>strcmp(s1, s2)</code> 字符串比较</p>
<p> 逐字符比较，<br> <code>s1 &lt; s2</code>就返回<code>-1</code>。<br> <code>s1 &gt; s2</code>返回<code>1</code><br> 相等返回<code>0</code>.</p>
</li>
</ol>
<blockquote>
<p>一般用来判断字符串是否相等。</p>
</blockquote>
<ol start="4">
<li><p><code>strrev(s1)</code> 字符串反置<br> 会修改原字符串。<br> 我们的OJ不支持，PTA支持（有待商榷）。<br> 自己写。</p>
</li>
<li><p><code>strcat(s1, s2)</code> 字符串连接，把s2连到s1后。</p>
</li>
</ol>
<blockquote>
<p>两个参数总是第一个被修改。</p>
</blockquote>
<ol start="6">
<li><p><code>strchr(s1, ch)</code> 查找第一次出现的位置。<br>位置是指针。通过寻址符。<br>没有的话，返回地址为空NULL。<br>减去首元素地址（数组名）就可以得到下标。<br><code>strchr(s1, ch) - s1</code></p>
</li>
<li><p><code>strstr(s1, s2)</code> 在一个字符串中找另一个字符串。</p>
</li>
</ol>
<blockquote>
<p>在s1中找s2（s2为字符串）<br>    找到返回地址，找不到返回NULL。<br>    则显示字符串第一次出现的第一个字符地址，<br>    减去d，则是它的下标。</p>
</blockquote>
]]></content>
      <tags>
        <tag>C语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C-premier-plus-Chapter-3</title>
    <url>/2023/12/22/C-premier-plus-Chapter-3/</url>
    <content><![CDATA[<h1 id="第三章-数据处理"><a href="#第三章-数据处理" class="headerlink" title="第三章 数据处理"></a>第三章 数据处理</h1><blockquote>
<p>你会在这一章学到下面的东西：</p>
<ol>
<li>关键字<br>&#96;int,short,long,unsigned,char,float,double,_Bool,_Complex</li>
<li>运算符<br><code>sizeof</code></li>
<li>函数<br><code>scanf()</code></li>
<li>整型与浮点型的区别</li>
<li>书写常量与声明这些类型的变量</li>
<li>如何使用<code>printf()</code>与<code>scanf()</code>函数来读写不同类型的值</li>
</ol>
</blockquote>
<p>程序依靠数据来工作。你会向电脑输入数字、字母或者单词，然后期望它能够利用这些数据做些事情。例如，你可能想要电脑去计算支付利润或者展示一个排过序的酒商列表。在这一章，你将会不只阅读数据，而且练习着去操纵数据，那是挺有趣的一件事。</p>
<p>这一章还会让你了解到两大类数据类型：整数与浮点数。C语言提供了这些类型的几种变体。这一章会告诉你类型是什么，如何声明它们并且如何利用它们。而且，你会发现变量与常量之间的区别，作为额外奖励，你的第一个交互式的小程序就要诞生了！</p>
<span id="more"></span>

<h2 id="3-1-一个例子"><a href="#3-1-一个例子" class="headerlink" title="3.1 一个例子"></a>3.1 一个例子</h2><p>再一次，我们还是从一个样例程序来开始，像以往一样，你会发现一些不熟悉的东西，我们待会就会为你解释。程序的总体目的应该清晰，那么就尝试把图3.1中的源码编译运行下吧。<br>为了节省时间，你可以省略注释。</p>
<p><img src="/img/Listing3.1.png" alt="图3.1"></p>
<p><img src="/img/ErrandWarn.png" alt="错误与警告"><br>【错误与警告】<br>如果你把程序的某些部分打错了，还有，比如说，遗漏了一个分号，编译器就会给予你一条语法错误信息。即使你没打错，编译器也有可能给予你一条警告信息，“Warning-conversion from ‘double’ to ‘float’ , possible loss of data.” 错误信息指的是你有可能把某些事做错了，它阻止程序的编译。警告，意思是你写的代码是合法的但是有可能做的并不是你想的那样。警告并不会阻止编译过程。上文中的这条信息就会在C语言在处理像770.0这样的数时出现，但并不是这个例子的问题，这一章过会会解释这条警告。</p>
<p>当你在打字写这个程序的时候，你有可能会把<code>770.0</code>改成这种珍贵金属的当前价格。但是不要改变14.5833，那代表着一磅对应的盎司数。（盎司金衡制，是对于贵重金属使用的，常规衡制是给人们使用的，不论是珍贵的物品或是其他的东西。）</p>
<p>需要注意的是“输入”你的体重意味着把你的体重打字写入电脑，并且敲下Enter或者Return键（不要输入完了你的体重就等着。）按下Enter键这个动作告诉了电脑你已经完成了你的应答。这个程序想要你输入一个数字，如<code>150</code>而不是单词，比如<code>too much</code>，如果你写的是字母而不是数字，那是会导致问题的，而这个问题需要之后学习的<code>if</code>语句来解决。（第七章，“C语言控制语句：分支结构与跳跃结构”会讲到），所以请先平静一些，输入一个数字，这里就是一个简单的输出示例。</p>
<p><img src="/img/Olist3.1.png" alt="输出"></p>
<h3 id="3-1-1-例子中的新知识"><a href="#3-1-1-例子中的新知识" class="headerlink" title="3.1.1 例子中的新知识"></a>3.1.1 例子中的新知识</h3><p>在这个C语言程序中有这么几个新接触的要素。</p>
<ul>
<li>可以注意到的是，代码在变量声明中使用了新的数据类型，前面提到的例子只使用了十进制整数类型(<code>int</code>)，但是现在的这个例子使用了一个浮点类型的变量类型，这样的话你就可以处理更大范围的数据了。<code>float</code>类型就可以保存含有十进制小数点的数字。</li>
<li>这个程序给出了书写常量的一些更新的方式，你现在可以书写浮点型的常量了。</li>
<li>为了对程序提供输入信息，你需要使用<code>scanf()</code>函数，<code>%f</code>命令<code>scanf()</code>从键盘输入中读入一个浮点数，<code>&amp;weight</code>告知了<code>scanf()</code>函数把输入的值赋给名字叫做<code>weight</code>的变量，<code>scanf()</code>函数会用<code>&amp;</code>符号来寻找在哪里可以找到叫做<code>weight</code>的变量，下一章我们会进一步地阐述<code>&amp;</code>符号，现在，只需要相信我们你需要在这里添加一个<code>&amp;</code>符号。</li>
<li>可能最突出的新特性就是程序变为交互性的了。电脑会要求你输入信息，并使用你输入的数值。一个交互性的程序是比不能交互的更有趣的。更重要的是，交互的方法让程序更加的灵活。举个例子，样例程序就可以用于所有合理的体重了，而不只是150磅，你不需要换一个人就再把程序重写一遍。<code>scanf()</code>函数会从键盘中获取数据，并把数据传递到你的程序，<code>printf()</code>函数会从程序中获取数据，然后把数据传递到你的屏幕上。这两个函数在一起就可以让你建立电脑与你的双向联系（见图3,1），这就让电脑使用更加有趣了。</li>
</ul>
<p>我们会在这一章讲述这些新特点中的前两条，后面的三条内容会在第四章-字符串与格式化输入输出完整地讲到，但是这一章还是会少量地使用<code>print()</code>与<code>scanf()</code>函数。</p>
<p><img src="/img/Figure3.1.png" alt="输入输出函数的工作"></p>
<h2 id="3-2-变常类型"><a href="#3-2-变常类型" class="headerlink" title="3.2 变常类型"></a>3.2 变常类型</h2><p>一台电脑，在程序的指导之下，可以做到很多的事情。可以做加法，可以给名称排序，可以指示讲话者或者屏幕的演出顺序，可以计算彗星的轨道，可以编排你的邮寄列表，拨叫电话号码、画出由小棒组成的人物，得出结论或者其他你可以想象到的可以被创造的东西。为了完成这些任务，程序需要处理<em><strong>数据</strong></em>，也就是你使用的保存在程序中的所有数字与字符信息。一些数据类型需要在程序使用之前进行预设，而且保证它们的值是不变的，这些就是<em><strong>常量</strong></em>。其他的数据类型的值或许会随着程序运行改变或者被赋给，这些就是<em><strong>变量</strong></em>。在这个样例程序中，<code>weight</code>就是一个变量，而<code>14.5833</code>就是一个常量。那么<code>770.0</code>呢？虽然铑金属在真实生活中的价格并不是个常量，但是这个程序把它作为一个常量来处理。变量与常量的区别就在值可不可以随着程序运行发生改变上。</p>
<h2 id="3-3-数据类型关键字"><a href="#3-3-数据类型关键字" class="headerlink" title="3.3 数据类型关键字"></a>3.3 数据类型关键字</h2><p>讲完了变量与常量的区别之后，我们需要了解一下不同数据<em><strong>类型</strong></em>之间的区别。一些数据是数字形式，一些是字母，或者更加普遍的，它们是字符。电脑需要一种方式来确定与使用这些不同的类型。C语言通过对于基本的数据类型的定义完成了这个工作。如果数据是一个常量，编译器通常是可以通过它看起来的样子来区分它的。<code>42</code>是一个十进制整数，<code>42.100</code>是一个浮点数，在另一面，变量就需要声明语句来声明它的类型。随着学习进行下去，你会了解到关于声明变量的更多细节。但是还是让我们首先先研究一下C语言可以识别的基本类型，K&amp;R C确立了有关于类型的七个关键字，C90标准增加了两个，C99标准又增加了三个。（见表3.1）<br><img src="/img/Table3.1.png" alt="表3.1"></p>
<p><code>int</code>关键字提供了C语言中基本的十进制整数类型，下面的三个关键字(<code>long, short, unsigned</code>)还有ANSI添加的<code>signed</code>提供了基本类型的变体。接着，<code>char</code>关键字指明了用于字母与其他字符的类型，如<code>%, $, #</code>等，<code>char</code>类型还可以被用来代表大于0与小于10的十进制整数。然后是<code>float</code>与<code>double</code>，还有两者的混合<code>long double</code>是用来代表带有十进制小数点的数字的。<code>_Bool</code>类型是为布尔类型提供的(<code>true</code>和<code>false</code>)，最后是分别代表着复数与虚数的<code>_Complex</code>与<code>_Imaginary</code>.</p>
<p>由这些关键字创造的类型又可以基于在电脑中的储存类型分为两种，<em><strong>十进制整数类型</strong></em>与<em><strong>浮点数类型</strong></em>。</p>
<p><img src="/img/storingtypes.png" alt="Bits, Bytes and Words"><br>【Bit（位）、字节与字】</p>
<p><em>bit</em>、<em>字节</em>与<em>字</em>可以被用来描述电脑的数据单元或者内存单元。我们会集中于第二种用法。</p>
<p>内存的最小单元叫做<em><strong>bit</strong></em>，它可以保存<code>0</code>与<code>1</code>之间的其中一种数值（或者你可以说，这个字节被设为“关”或者“开”）你并不能在一个bit中储存太多的信息，但是电脑可以储存很多的字节，bit就是电脑内存的基础组成模块。</p>
<p><em>字节</em>是电脑内存的一般单元。对于大多数的机器来说，一个字节是8个bi，那是标准的定义，至少当测量内存的时候（C语言有不同的定义，我们会在“使用字符：<code>char</code>类型”这一节讲到）因为一个bit不是0就是1，那么在8位的字节中，就可以有256种可能（2的8次方），这些可能的模式就可以被用作比如代表0到255的数字或者代表一系列的字符。在二进制代码下，这种一对一的映射是可以被建立的，而且使用0与1来代表数字也使机器便利的。（在第15章-位运算，会讲述二进制代码，但是如果你想的话现在就可以去读一下）。</p>
<p><em>字</em>是电脑固定设计下的内存自然单元，对于8位的微型计算机，比如原来的苹果电脑来说，一个字就只是8个bit。早期的IBM兼容器使用的80286处理器是16位的机器，这也就是说他们把字长增加到了16bit。还有例如以Pentinum为基础的计算机，还有Mactonish PowerPC的字长是32bit。还有更强大的电脑的字长是64位的或者更大。</p>
<h3 id="3-3-1-整型与浮点型"><a href="#3-3-1-整型与浮点型" class="headerlink" title="3.3.1 整型与浮点型"></a>3.3.1 整型与浮点型</h3><p>整型？浮点型？如果你感觉这些词非常不熟悉以至于干扰了你的阅读进度，我们这就要简要描述它们的意义了。如果你对位、字节还有字还是不熟悉的话，你可能需要阅读一下最近描述过的附加栏。你真的需要了解所有的细节吗？并不是，不只了解内燃机驱动车子的工作原理，而多了解一些电脑或者引擎内部发生的事情有时候可以帮到你。</p>
<p>对于一个人来说，整型与浮点型的区别体现在它们是怎么被写下的。对于电脑来说，那就体现在它们是怎么被储存的。让我们依次来研究一下这两种类型。</p>
<h3 id="3-3-2-整数类型"><a href="#3-3-2-整数类型" class="headerlink" title="3.3.2 整数类型"></a>3.3.2 整数类型</h3><p><em><strong>整型</strong></em>是没有小数部分的数字。在C语言中，整型是没有小数点的数字。比如说-2、-23还有2456。像3.14, 0.22, 还有2.00这些数就不是整型。整型是以二进制数字的形式被储存起来的。比如7就是被储存为二进制数111的。因此，为了在8位字节中储存这个数字，会把前五个位设置为0，然后把后三个位设置为1。    </p>
<p><img src="/img/Figure3.2.png" alt="用二进制码储存7"></p>
<h3 id="3-3-3-浮点数类型"><a href="#3-3-3-浮点数类型" class="headerlink" title="3.3.3 浮点数类型"></a>3.3.3 浮点数类型</h3><p><em><strong>浮点</strong></em>数多多少少是对应着数学概念中的<em><strong>实数</strong></em>，实数包含着整数之间的这些数字，浮点数基本是这些样子：2.75、3.16E7、7.00、2e-8，需要注意的是，只要有小数点就会把整型数字转换为浮点数，比如7.00是一个浮点数，而7就是一个十进制整数。很明显，书写浮点数的方式不止一种，我们会在之后更充分地讨论用e符号表示的形式。但是简单来说，3.16E7的表示方式意思就是3.16乘10的7次方，也就是1后面添7个0，7也就是10的<em><strong>指数</strong></em>。</p>
<p>关键就是储存浮点数的方式与整数不一样。浮点数的表示涉及到把一个数字分开为小数部分与整数部分，然后分别储存。因此，7.00这个数字不会与整数7同样储存，即使它们的值都是一样的。十进制类比起来也就是把7.0写为0.7E1。这里，0.7就是小数部分，1就是指数部分，图3.3展示了浮点数储存的另一个例子。一台电脑当然会使用二进制数与二进制而不是十进制来储存。你会在第十五章了解关于这个话题的更多信息。现在我们先集中精力于在实用上区别吧。</p>
<ul>
<li>整型没有小数部分，浮点数可以有小数部分。</li>
<li>浮点数比整数代表的数字更多，可以看一下这一篇结尾的图表3.3。</li>
<li>对于一些算术运算符，比如一个数减去另一个数，浮点类型的精确度会有更大可能下降。</li>
<li>因为在任何一个范围之间都有着无数的浮点数，比如在1.0与2.0之间，电脑就不能完全地代替这些值，它用实数的大概值来估计浮点数的值。比如7.0有可能被储存为6.99999的<code>float</code>值，过会会讲到更多有关于精确度的知识。</li>
<li>浮点运算符的优先级通常是比整型运算符要低的，然而用来处理浮点运算的特殊微型处理器已经可用了，这个问题也就得到了解决。</li>
</ul>
<p><img src="/img/Figure3.3.png" alt="十进制浮点储存方式"></p>
<p>现在就让我们研究一下C语言中各种数据类型的特点吧。对于每一种类型，我们会描述如何声明一个变量，如何用变量代表一个常量，还有一些特殊的用法。一些年代较早的C语言编译器可能不能支持下文全部的类型，所以你可以查看一下你的编译器的说明书，看一看哪些数据类型是可用的。</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="3-4-1-int类型"><a href="#3-4-1-int类型" class="headerlink" title="3.4.1 int类型"></a>3.4.1 <code>int</code>类型</h3><p>C语言提供了很多的整数类型，你可能想知道为什么只有一种还不够，答案就是这样C语言就可以让你将特定的变量用在特定的地方。具体来说，C语言的各个整数类型不同在值域的大小与是否含有负数上。<code>int</code>是最基本的整数类型，但是你要是为了满足机器任务的特定需求的话，其他的类型也都是可用的。</p>
<p><code>int</code>类型是一种有符号的整数类型，有符号意味着<code>int</code>类型的整数可以是正数、也可以是负数，或者是0。<code>int</code>类型的值域是取决于计算机系统的，通常一个<code>int</code>类型的整数的大小就是内存的一个字长。因此，旧版的16位IBMPC适配器，就可以使用16个位来储存整数，也就是从-<strong>32768</strong>到<strong>32767</strong>。现在的个人电脑一般是使用32位的整数大小，在这张结尾的表3.3可以看到一些个例子。现在个人电脑产业也正在向64位处理器发展，那样也就可以使用更大的整数了。ISO&#x2F;ANSI C语言特别指出<code>int</code>的最小范围应该是-<strong>32767</strong>到<strong>32767</strong>，通常系统会专门拿出一个位来保存符号，第十五章描述这种了一般的方法。</p>
<h4 id="3-4-1-1-声明int类型"><a href="#3-4-1-1-声明int类型" class="headerlink" title="3.4.1.1 声明int类型"></a>3.4.1.1 声明<code>int</code>类型</h4><p>正像你在第二章看到的，关键字<code>int</code>可以用来声明一个基本的整型变量。声明，首先是<code>int</code>，然后是变量的名称，最后是一个分号。要是声明多个变量的话，可以分别声明，也可以用逗号分隔，把一系列的变量名列出来，下面的声明方法都是合法的。</p>
<p><img src="/img/valid_declaration.png"></p>
<p>你可能已经使用过分别声明变量的方法了，或者你已经尝试在一行中声明全部的变量了。效果都是一样的：就是对四个<code>int</code>大小的变量分配空间并与变量名相联系。</p>
<p>这些声明语句创造了变量，但并没有给它们赋值，变量要如何得到值呢？你已经见过两种方法了，第一种是赋值语句</p>
<p><img src="/img/assignments.png"></p>
<p>第二，变量也可以使用函数来赋值，比如说<code>scanf</code>函数。<br>现在我们来了解一下第三种方法吧。</p>
<h4 id="3-4-1-2-变量初始化"><a href="#3-4-1-2-变量初始化" class="headerlink" title="3.4.1.2 变量初始化"></a>3.4.1.2 变量初始化</h4><p>对变量进行<em><strong>初始化</strong></em>也就是给变量赋起始值，或者初值。在C语言中，这可以作为声明的一部分，只需要在变量名后加上赋值运算符还有你想要赋给这个变量的值就可以了。下面是一些例子。</p>
<p><img src="/img/initialization.png"></p>
<p>在最后一行，只有<code>cats</code>被初始化了，速读一遍，你有可能觉得dogs也会被赋值为94，所以还是最好避免把未赋值与已赋值的变量放在一行之中吧。</p>
<p>简单来说，这些声明会为变量创造空间，并为它们贴上变量类型的标签，而且还可以给赋变量起始值。（见图3.4）</p>
<p><img src="/img/DefinenInitial.png" alt="图3.4"></p>
<h4 id="3-4-1-3-int型常量"><a href="#3-4-1-3-int型常量" class="headerlink" title="3.4.1.3 int型常量"></a>3.4.1.3 <code>int</code>型常量</h4><p>在上一个例子中各种各样的整数（21、32、14、94等），就是整型常量。当你书写一个没有十进制小数点并且没有指数的数时，C就会将这个数认作整型常量。因此，22与-44都是十进制整型常量，但是<code>22.0</code>与<code>2.2E1</code>就不是。C语言会把大多数整型认作<code>int</code>类型常量。但很大的数会有区别。看最后对于long常量与long long常量的描述就知道了。</p>
<h4 id="3-4-1-4-打印int值"><a href="#3-4-1-4-打印int值" class="headerlink" title="3.4.1.4 打印int值"></a>3.4.1.4 打印<code>int</code>值</h4><p>你可以使用<code>printf()</code>函数来打印<code>int</code>类型的值，正像你在第二章看到的，%d符号可以在十进制整数被打印出来的地方作为占位符。%d的名称叫格式化符，因为它声明了<code>printf()</code>打印值的类型每一个在格式化字符串中的每一个<code>%d</code>都代表着一个<code>int</code>类型的值，它就在字符串后面的列表中。那个值可以是一个<code>int</code>类型变量代表的，也可以是一个<code>int</code>类型常量代表的，或者任何有<code>int</code>值的表达式。这样，你就有责任让格式化符与之后的列表中的值一致了，编译器并不会报出这种错误。图3.2就表示了一个初始化并且打印变量值，常量的值，还有简单表达式的值的程序，它也提示了你如果你不小心的话会发生什么。</p>
<p><img src="/img/Listing3.2.png" alt="图3.2"></p>
<p>编译完运行这个程序的结果是这样的。</p>
<p><img src="/img/result1.png"></p>
<p>第一行输出，第一个<code>%d</code>代表着一个<code>int</code>类型变量<code>ten</code>第二个代表着常量2，第三个呈现的是<code>ten</code> - <code>two</code>的值。但第二行，使用的是<code>ten</code>这个变量代替了第一个<code>%d</code>但是之后的值全都是随机的，是从最近的两个内存空间中获取的值！（你回去的值有可能与这里显示的值相差很多，不仅内容不一样，而且不同的编译器对于这些内存区的管理方法也不一样。）</p>
<p>你有可能对编译器为啥并不会捕捉到这个很明显的错误，还是怪<code>printf()</code>函数的原始设计吧。大多数函数都会获取一个值作为参数，编译器可以检查出来你使用的值是不是恰当，但是<code>printf()</code>可以获取一个、两个、三个或者更多的参数，那就让编译器无法使用常用的错误检测方法了。记住，一定要检查格式化符是不是与被显示的值匹配。</p>
<h4 id="3-4-1-5-八进制与十六进制"><a href="#3-4-1-5-八进制与十六进制" class="headerlink" title="3.4.1.5 八进制与十六进制"></a>3.4.1.5 八进制与十六进制</h4><p>通常来说，C语言会认为整型常量是十进制数。但是八进制与十六进制也受到许多编程人员的欢迎。因为8与16都是2的幂，但10并不是，这些进制系统有时会为与计算机相关的值的表达提供便利。例如，数字65536经常会出现在16位的机器中，它只是10000的十六进制数，十六进制数中的每一位数都对应着实际的四个位。例如，十六进制数3就对应着0011，5就对应着0101，所以35就对应着0011 0101，53就对应着0101 0011。这种对应就会使十六进制与二进制的转换非常简单。但是电脑是怎么判断10000是什么进制的数字的呢？在C语言中，数字不同的前缀就显示了不同的进制，0x（0X）就意味着你正在使用十六进制值，所以16在十六进制下会被写作0x10或0X10。相似地，前缀0就表示你正在使用的是八进制值。例如，十进制数16在八进制数中就写为020，在15章我们会更加充分地讨论不同的数制。</p>
<p>要知道的是不同的数制系统是为你提供便利的，它并不会影响数值的储存方式，也就是说，你可以写16、020或者0x10，这个数还是会以二进制的方式储存起来。</p>
<h4 id="3-4-1-6-展示八进制与十六进制数"><a href="#3-4-1-6-展示八进制与十六进制数" class="headerlink" title="3.4.1.6 展示八进制与十六进制数"></a>3.4.1.6 展示八进制与十六进制数</h4><p>正像C语言能够让你以三种方式书写数字一样，它也可以让你以三种方式的任意一种展示数字。展示一个八进制整数可以使用%o，十六进制使用%x，如果你想显示前缀，你可以使用修饰符#，比如<code>%#o</code>，<code>%#x</code>，<code>%#X</code>，有了它们你就可以在数字前面显示0，0x，0X前缀。图3.3给出了一个小小的例子（想到你有可能必须加上一个<code>getchar()</code>，它会在一些IDE中防止程序立即关闭）。</p>
<p><img src="/img/Listing3.3.png" alt="图3.3"></p>
<p>编译运行过后结果是这样的。</p>
<p><img src="/img/result2.png"></p>
<p>你可以看到相同的数字被以三种不同的数制打印出来了，<code>printf()</code>函数可以实现这种转化。<br>注意前缀只有加上#时才会出现。</p>
<h3 id="3-4-2-其他整型"><a href="#3-4-2-其他整型" class="headerlink" title="3.4.2 其他整型"></a>3.4.2 其他整型</h3><p>当你正在学习C语言时，<code>int</code>类型有可能已经满足了你大部分的整型需求了。但为了内容的完整，我们会研究其他的类型。如果你喜欢的话，你可以只大体浏览一下这一部分，然后跳到对于<code>char</code>类型那一部分，然后如果有啥需要的可以再回来复习。</p>
<p>C语言使用三个形容词关键字来修饰基本整型：<code>short, long, unsigned</code>下面是需要记住的一些点。</p>
<ul>
<li><code>short int</code>类型，或者直接<code>short</code>，会比<code>int</code>使用的内存更少，由此也就可以在只使用小的数字的时候节省一些空间。像<code>int</code>一样，<code>short</code>为有符号类型。</li>
<li><code>long int</code>类型，或者直接写<code>long</code>，占用的内存会比<code>int</code>更多，因此可以让你表示更大范围的数字，像<code>int</code>一样，<code>long</code>为有符号类型。</li>
<li><code>long long int</code>类型，或者<code>long long</code>（都是在C99标准下被引入的），会比<code>long</code>类型占用的内存更多，也就让你可以使用比<code>long</code>范围更大的数字。像<code>int</code>一样，<code>long long</code>是一个有符号的类型。</li>
<li><code>unsigned</code>类型，或者写成<code>unsigned</code>，是为非负的变量而设置的，这种类型改变了可储存数字的范围，例如，16位的<code>unsigned int</code>可以表示0-65535的数字，就不是-32768-32767了，用来表示符号的那一位在无符号类型这变成了另一个可以表示数字的位，也就让数字的表示范围扩大了。</li>
<li><code>unsigned long int</code>类型，或者<code>unsigned long</code>还有<code>unsigned short int</code>，或者<code>unsigned short</code>，在C90标准下都是可以被识别的，在C99标准下又添加了<code>unsigned long long int</code>类型，或者<code>unsigned long long</code>。</li>
<li>为了让你的意图明显，关键字<code>signed</code>可以被用在任何有符号类型上，例如<code>short</code>, <code>short int</code>, <code>signed short</code>,<code>signed short int</code>都是一种类型。</li>
</ul>
<h4 id="3-4-2-1-声明其他整型"><a href="#3-4-2-1-声明其他整型" class="headerlink" title="3.4.2.1 声明其他整型"></a>3.4.2.1 声明其他整型</h4><p>其他整型与<code>int</code>类型的声明方式是相似的，<br>下面就展示了一些例子。<br>并不是所有的编译器都能识别最后三种类型，最后一个例子是C99标准新加进去的。</p>
<p><img src="/img/othertypes.png" alt="其他整型"></p>
<h4 id="3-4-2-2-为什么要用多种整型？"><a href="#3-4-2-2-为什么要用多种整型？" class="headerlink" title="3.4.2.2 为什么要用多种整型？"></a>3.4.2.2 为什么要用多种整型？</h4><p>为什么说<code>long</code>与<code>short</code>与<code>int</code>相比会使用不同的内存呢？因为C语言会确保<code>short</code>不会长过<code>int</code>，<code>int</code>也不会长过<code>long</code>，主要的目的就是为了适应不同类型的机器。例如在运行着Windows 3.1的IBM PC上，<code>int</code>与<code>short</code>都是16位的，而<code>long</code>是32位的，而在Mactonish Power PC上，<code>short</code>类型是16位的，而<code>int</code>和<code>long</code>类型是32位的。PowerPC G3&#x2F;G4中的Pentium芯片的字长是32位，因为这就可以让整型超过20亿（见表3.3），C语言在处理器&#x2F;操作系统的实现没有必要超出这个数值。因此，<code>long</code>与<code>int</code>大小是一样的。对于许多的使用过程，那个大小的整数是不需要的，所以节省内存的<code>short</code>就被创造了。但另一方面，原本的IBM PC只有16位的字长，那就意味着需要更长的<code>long</code>类型。</p>
<p>现在64位的处理器都变得很常见了，比如IBM Itantium，AMD Opteron，还有PowerPC G5。因为64位整型的需要，<code>long long</code>类型也就应运而生。</p>
<p>现在最常见的实践是把<code>long long</code>设置为64位，把<code>long</code>设置为32位，把<code>short</code>设置为16位，把<code>int</code>设置为16位或者32位，它的大小取决于电脑的自然字长。原则上，这四种类型可以代表四种不同的大小。</p>
<p>C语言标准为确定每一种基本数据类型的最小尺寸提供了指引。<code>short</code>与<code>int</code>的最小范围是从-32,767到32,767，对应着16位的单元，而<code>long</code>类型的最小范围是-2,147,483,647到2,147,483,647，对应着32位的单元。（注意，为了易读，我们使用了逗号分开，但是C语言代码是不能写成这样的）。对于<code>unsigned short</code>与<code>unsigned int</code>，最小的范围是0到65535，而<code>unsigned long</code>的最小范围是0-4,294,967,295&#x2F;,<code>long long</code>类型为了迎合64位的需求，它的最小范围很大，是-9,223,372,036,854,775,807到9,223,372,036,854,775,807，而<code>unsigned long long</code>就是0到18,446,744,073,709,551,615.（对于那些检查写的对不对的人，下面是它的英文表示，但是谁要计数呢？）</p>
<p><img src="/img/nonsense.png" alt="(一脸认真)"></p>
<p>你会在什么时候使用这些不同的<code>int</code>类型呢？第一，考虑<code>unsigned</code>类型，使用它们计数是很好的，因为你不需要负数，而且<code>unsigned</code>类型比<code>signed</code>类型的范围更大，可以得到更大的整数范围。</p>
<p>如果你需要处理超过了<code>int</code>类型的范围的数字，使用<code>long</code>类型，但是在<code>long</code>比<code>int</code>长的系统中，使用<code>long</code>会让计算变慢，所以没必要的话就不要用<code>long</code>，进一步说，如果你正在一个<code>int</code>与<code>long</code>类型长度一样的系统上写代码，而你又需要32位的整数，你就需要使用<code>long</code>而不是<code>int</code>了，那样程序才可以在转到16位机的时候正常运转。</p>
<p>相似地，如果你需要64位整型数的时候就使用<code>long long</code>吧，一些电脑已经使用着64位的处理器，而且并且正在服务器、工作站甚至桌面的64位处理也正在变得越来越普遍。</p>
<p>如果你需要节省内存空间的话，使用<code>short</code>来节省内存空间，比如如果你在一台<code>int</code>类型是32位的机器上，需要16位的值这种情况。通常只有当你的程序使用整型数组这种与系统的可用内存极其相关的情况下节省内存才是必须的。另一个使用<code>short</code>的原因是它有可能与被电脑的特定部分使用的硬件寄存器的大小相同。</p>
<blockquote>
<p><img src="/img/overflow.png"><br>整型溢出。<br>当一个整型相对于它的类型太大了会怎么样呢？让我们把一个整型变量设置到它可能的最大值，并用它加一些数，看看会发生什么。<code>unsigned</code>与<code>	signed</code>类型都可以试试（<code>unsigned int</code>的格式化符是<code>%u</code>）<br>这就是系统给出的结果<br><img src="/img/flowresult.png"><br><code>unsigned</code>类型好像汽车的里程计一样，当它到达了最大值，它就会返回到它的最小值，变量i也很相似，主要的区别是<code>unsigned</code>类型的<code>j</code>	是以0开始的，但是<code>int</code>类型的<code>i</code>是以-2147483647开始的。<br>注意的是，你如果没有被告诉这个数据已经溢出了，你还是会不断地在这个问题上打转。<br>这里描述的行为是由C语言<code>unsigned</code>类型的规范控制的，标准并不规定<code>signed</code>应该行为如何，这里展示的行为也是通常会发生的，但是你以后会找到不一样的东西的。</p>
</blockquote>
<h4 id="3-4-2-3-long常量与long-long常量"><a href="#3-4-2-3-long常量与long-long常量" class="headerlink" title="3.4.2.3 long常量与long long常量"></a>3.4.2.3 <code>long</code>常量与<code>long long</code>常量</h4><p>一般地，当你在代码中使用2345这样的数字时，它会被储存为一个<code>int</code>类型的常量。那么如果你使用1000000这样不能被<code>int</code>储存下来的数字呢？编译器就会将它识别为<code>long int</code>，如果认为这个类型已经足够大了的话。如果比<code>long</code>类型的最大值还要大的话，C语言会将它当做<code>unsigned long</code>类型，如果那还不够的话，它就会把它当做<code>long long</code>类型或者<code>unsigned long long</code>，如果这些类型可以满足要求的话。</p>
<p>八进制与十六进制的常量会被认作<code>int</code>类型，除非这个值太大，然后还是以上文的顺序依次递加。</p>
<p>有些时候你有可能想让编译器把一个小点的数储存为<code>long</code>类型。如果你在编程的过程中需要外显地使用内存地址，例如在IBM PC上，就有可能有这样的问题。而且，一些基本的C语言函数是需要<code>long</code>类型的值的，你可以在数值加上后缀<code>l</code>或者<code>L</code>，第二种方式更好，因为看起来不像数字<code>1</code>。因此，一个有着16位大小的<code>int</code>与32位大小的<code>long</code>，会将<code>7</code>这个数储存在16位中，而将<code>7L</code>储存为32位中，而且这两个后缀对于八进制与十六进制都是适用的，像是020L与0x10L。</p>
<p>相似地，在那些有<code>long long</code>类型的系统中，你就可以使用<code>ll</code>或者<code>LL</code>后缀，比如<code>3LL</code>，而且还可以使用<code>u</code>或者<code>U</code>来表示<code>unsigned long long</code>类型，就像<code>5ull</code>或者<code>10LLU</code>或者<code>9Ull</code>。</p>
<h4 id="3-4-2-4-打印short-long-long-long与unsigned类型"><a href="#3-4-2-4-打印short-long-long-long与unsigned类型" class="headerlink" title="3.4.2.4 打印short, long, long long与unsigned类型"></a>3.4.2.4 打印<code>short, long, long long</code>与<code>unsigned</code>类型</h4><p>要打印一个<code>unsigned int</code>类型的数字，只需使用<code>%u</code>符号，<code>long</code>类型可以使用<code>%ld</code>，但如果你的机器中<code>int</code>与<code>long</code>是大小一致的，那<code>%d</code>就可以了，但是代码有可能在别的系统中就不能正常运作了，所以对<code>long</code>来说最好还是使用<code>%ld</code>吧，对于<code>x</code>与<code>o</code>都可以在前面加上<code>l</code>。因此对于十六进制的<code>long</code>类型数你会使用<code>%lx</code>，类似在八进制会使用<code>%lo</code>，需要注意的是即时C语言提供了大写的<code>L</code>后缀，但是在格式化符中，只能使用小写。</p>
<p>C语言有几种额外的<code>printf()</code>格式，首先，你可以在使用<code>short</code>类型时在<code>%d</code>的<code>d</code>前加<code>h</code>来表示十进制的<code>short</code>整型，同理<code>%ho</code>也是可以的，而且<code>h</code>与<code>l</code>是可以再加上<code>u</code>表示无符号的。例如，你会使用<code>%lu</code>符号表示<code>unsigned long</code>类型，图3.4就提供了一个例子。支持<code>long long</code>的系统也可以使用<code>%lld</code>或者<code>%llu</code>分别表示有符号与无符号的<code>long long</code>整型，第四章会对格式化符进行更充分的阐述。</p>
<p><img src="/img/Listing3.4.png" alt="图3.4"></p>
<p>这是系统的输出：</p>
<p><img src="/img/result3.png"></p>
<p>这个例子就显示出了使用错误的格式化符会有意想不到的后果。第一，注意到对于变量<code>un</code>使用的<code>%d</code>格式化符结果输出了一个负值，原因就是无符号与有符号数实际上是以相同的二进制排列被储存起来的（第15张会更详细地谈论这种属性），所以如果你告诉<code>printf()</code>函数这个数是没有符号的，与告诉它这个数是有符号的输出结果是不一样的。这种行为常会在你输入一个超限的数值时出现。小的整数，在两种格式化符之下都是一样的。</p>
<p>第二，注意到无论你告诉<code>printf()</code>是<code>short</code>还是<code>int</code>类型，<code>short</code>变量<code>end</code>都是可以打印出正常值的。这就是因为当向函数输入一个参数的时候会自动将它转化为<code>int</code>类型，那么你就会问了:1.为什么这种转化会发生？2.<code>h</code>修饰符的用处在哪里？第一个问题的答案是<code>int</code>类型可以被电脑更加高效地处理。所以在<code>short</code>与<code>int</code>类型大小不同的机器上，有可能传递一个<code>int</code>值会更快。第二个问题的答案是你可以看看一个更加长的整型数如果被缩短为<code>short</code>类型了会看起来怎样。第三行的输出也为这一点提供了例证，当65537被写为32位二进制数时，它看起来是<code>00000000000000010000000000000001</code>这样子的，使用<code>%hd</code>格式化符会迫使<code>printf()</code>只看向最后的16个位，因此它会只打印<code>1</code>，相似的，最后一行的<code>verybig</code>使用<code>%ld</code>就会只看向最后的32位，而不是完全的位数。</p>
<p>早些时候你已经了解标识符的数量与显示数字的数量匹配的重要性了，现下你也知晓了标识符的种类也要匹配。</p>
<p><img src="/img/matchup.png"></p>
<p>匹配<code>printf()</code>函数的格式化符<br>记着要去检查一下你是不是对于每一个要在<code>printf()</code>中打印的值都给予了一个格式化符，并检查是不是每一个的格式化符都与显示的值的类型相互对应。</p>
<h3 id="3-4-3-字符-char"><a href="#3-4-3-字符-char" class="headerlink" title="3.4.3 字符 char"></a>3.4.3 字符 char</h3><p><code>char</code>类型是用来储存像字母、标点符号这样的字符的，但是严格来讲它其实是一个整数类型。为什么？<code>char</code>这个类型实际上储存的是整数而不是字符，为了处理字符，电脑会使用数字编码来让某一个整数代表某一个字符。在美国最常用的字符编码表是ASCII编码表，它已经在书的前封的背面给出来了，是这本书使用的编码表。举些例子，<code>65</code>在ASCII码表中代表的是大写的<code>A</code>，所以如果需要储存字母<code>A</code>，只需要储存数字<code>65</code>即可，（许多IBM主机用的是不一样的编码系统，它叫做EBCDIC，但是准则都是一样的。但在美国以外的计算机系统使用的编码表有可能是完全不同的。）</p>
<p>基础的ASCII码是从0到127的，这个范围小到一个字节就可以保存下来，<code>char</code>类型通常会被定义成8位的内存单元，所以它不仅仅可以储存下来基础的ASCII码。许多系统，如IBM PC与苹果公司的Macintosh，可以提供更大的ASCII码表（这两个系统是不一样的），但是还是在8位范围之内。更加普遍的，C语言会确保<code>char</code>类型的大小是足够储存系统中C语言实现的需要的基础字符的。</p>
<p>许多的字符集会有不只127而是255分值，例如日本的kanji字符集，商业的Unicode协议为代表全世界的各种字符创造了一个系统，现在已经有96000个字符了。ISO（国际标准组织）与IEC（国际电子委员会）为字符集创造了ISO&#x2F;IEC10646标准。幸运的是，Unicode标准与ISO&#x2F;IEC10646标准是始终协调的。</p>
<p>使用这些字符集的平台有可能会使用16位或者32位的<code>char</code>类型代表，C语言定义下<code>char</code>的长度是1个字节，现在在C语言的记录中，一个字节会是16位或者32位，而不是那些系统上的8位。</p>
<h4 id="3-4-3-1-定义char类型变量"><a href="#3-4-3-1-定义char类型变量" class="headerlink" title="3.4.3.1 定义char类型变量"></a>3.4.3.1 定义<code>char</code>类型变量</h4><p>正像你会期望的，<code>char</code>类型变量与其他变量的定义方式相同，这里就是一些例子。</p>
<p><img src="/img/chardef.png"></p>
<p>这几行代码创造了三个<code>char</code>类型的变量：<code>response</code>，<code>itable</code>与<code>latan</code>。</p>
<h4 id="3-4-3-2-字符常量及其初始化"><a href="#3-4-3-2-字符常量及其初始化" class="headerlink" title="3.4.3.2 字符常量及其初始化"></a>3.4.3.2 字符常量及其初始化</h4><p>假定你想要初始化一个字符常量为大写字母A，电脑语言是要让事情变得简单起来的，你不需要记忆ASCII码，你也不会，你可以直接以下面的方式给<code>grade</code>变量赋值<code>&#39;A&#39;</code></p>
<p><img src="/img/charassign.png"></p>
<p>被双单引号框定的单一字符就是C语言中的<em><strong>字符常量</strong></em>，当编译器看到了<code>&#39;A&#39;</code>，它会将A字符转化成相应的字符编码值，单引号是必须的，下面就是例子。</p>
<p><img src="/img/chardeclare.png"></p>
<p>如果你遗漏了引号，那么编译器就会认为<code>T</code>是一个变量名，如果你使用双引号的话，它会认为你正在使用字符串，我们会在第四章讲解字符串。</p>
<p>因为字符确实是以数字的形式被储存起来的，你还是可以使用数字编码为<code>char</code>类型变量赋值。</p>
<p><img src="/img/numassign.png"></p>
<p>在这个例子中<code>65</code>是一个<code>int</code>类型的，但是因为这个值是小于最大的<code>char</code>类型值的，所以可以无误地赋给<code>grade</code>变量，因为65对应着ASCII码中的字母<code>A</code>，所以<code>A</code>就被赋给了<code>grade</code>变量。但注意，这个例子只是为了表示系统用的是ASCII码系统，但用<code>65</code>与<code>&#39;A&#39;</code>都是一样的，因此，使用字符常量要比使用数字编码是要好的。</p>
<p>有点奇怪的是，C语言会将字符常量当做<code>int</code>类型常量而不是<code>char</code>来看待。例如，在32位使用ASCII字符编码，<code>char</code>类型为8位的系统中，这一行代码：</p>
<p><img src="/img/gradeb.png"></p>
<p>就会将<code>&#39;B&#39;</code>呈现为66这个值储存起来，但是<code>grade</code>是以8位单元储存的66，这种特点就会使字符常量不能存放多个字符，像<code>&#39;FATE&#39;</code>这样，因为4个单独的ASCII码被储存在32位的单元中，但是试图将这样一个字符常量赋给<code>char</code>类型变量会导致只有最后的8位被使用，也就是变量被赋给的是<code>&#39;E&#39;</code>。</p>
<h4 id="3-4-3-3-不会被打印出来的字符"><a href="#3-4-3-3-不会被打印出来的字符" class="headerlink" title="3.4.3.3 不会被打印出来的字符"></a>3.4.3.3 不会被打印出来的字符</h4><p>单引号对符号、数字还有标点符号都是适用的，但是如果你浏览过这本书前封里的那张表，你会看到一些ASCII字符是打印不出来的。例如，一些代表着回车或者跳到下一行，又或是会让终止铃响的符号，这些符号是怎么被表示的呢？C语言提供了三种方法：</p>
<p>第一种方法就是我们已经提到过的，使用ASCII表编码的方法。例如，蜂鸣符对应的值就是7，所以你可以这样写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> beep = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<p>表示这些字符的第二种方法是使用特殊的符号序列，它们叫做<em><strong>转义序列</strong></em>，表3.2给出了转义序列与它们的含义。</p>
<p><img src="/img/Table3.2" alt="表3.2"></p>
<p>在赋值给字符常量的时候，转义序列必须要由单引号框定，例如，你可以这样赋值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> nerf = <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>然后打印变量<code>nerf</code>，打印器或者屏幕上的行就会往前一行（回车）。</p>
<p>现在我们可以看看每一个转义序列是做什么的，警告符<code>\a</code>是在C90标准中添加的，它会生成一条有声有色的警告，警告的类型因硬件而定，一般蜂鸣声是最常见的（在有些系统中，警告符是没有用的。）ANSI标准规定了警告符是不能改变活跃位置的。活跃位置这个概念指的是在显示设备（如屏幕、电报机、打印机等等）上下一个字符会出现的地方。简单来说，它就是屏幕上你已经用惯了的光标的总称。在程序中使用警告符最终只会发出蜂鸣声，但并不会移动屏幕上的光标。</p>
<p>然后，是<code>\b, \f, \n, \r, \t</code>还有<code>\v</code>这些转义序列，它们都是常见的输出设备的控制符，它们在影响活跃位置上很出色，回车(<code>\b</code>)，会将活跃位置往前挪一个空格。换页符(<code>\f</code>)会将活跃位置转移到下一页的开头。换行符(<code>\n</code>)会将活跃位置切换到下一行的开始，(<code>\r</code>)，回车符(<code>\r</code>)会让活跃位置回到一行的开头位置，水平制表符(<code>\t</code>)会将活跃位置向右移动一个<code>Tab</code>键的位置（通常，这些是以字符位置1、9、17、25这样的格式），垂直制表符(<code>\v</code>)，会让活跃位置移动到下一个垂向的<code>tab</code>位置。</p>
<p>这些转义序列并不一定在所有的显示设备中起作用。例如，换页符与垂直制表符在电脑屏幕上只会打印出来一个奇怪的字符，并没有任何光标的移动。但是如果在打印机上使用就可以按照描述工作了。</p>
<p>最后的三个转义序列（<code>\\, \&#39;, \&quot;</code>），能够以字符常量的形式让你使用<code>\, &#39;, &quot;</code>（因为这些符号是作为<code>printf()</code>函数的一部分用来定义字符常量的，如果你要把它们字面上打印出来，那将会非常令编译器困惑。）假设你想要打印下来下面的这一行字。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Gramps sez, <span class="string">&quot;a \ is a backslash.&quot;</span></span><br></pre></td></tr></table></figure>

<p>就需要用下面代码的形式来写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Gramps sez, \&quot; a \\ is a backslash.\&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>最后的两种形式（<code>\0oo, \xhh</code>）是ASCII码的特殊标识，是要以八进制ASCII码的形式来代表字符，在前面需要加上<code>\</code>然后用单引号来框定整个字符，例如，如果你的编译器不能识别警告符，你就可以使用下面的ASCII码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">beep = <span class="string">&#x27;\007&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>你也可以省略前面的0，所以<code>&#39;\07&#39;</code>与<code>&#39;\7&#39;</code>都是可以的。这个符号会让数字被理解成八进制，尽管前面没有0。</p>
<p>从C90开始，C语言提供了第三种选择，使用十六进制的字符常量，这样说来，斜杠后面是<code>x</code>或者<code>X</code>与1到3位的十六进制数。例如，Ctrl+P符号在ASCII十六进制符码里就是10（十进制下就是16），所以它是可以被表达为<code>&#39;\x10&#39;</code>或者<code>\&#39;x010&#39;</code>的，图3.5展示了一些整型的代表。</p>
<p><img src="/img/Figure3.5.png" alt="图3.5"></p>
<p>当你使用ASCII码的时候，要注意数字与字符之间的差异。例如，字符4在ASCII中的值是52,<code>&#39;4&#39;</code>是一个符号而不是一个数字。</p>
<p>现下，你可能有这几个问题：</p>
<ul>
<li><em><strong>为什么转义序列在最后一个例子中没有用单引号括起来？</strong></em><br>（<em><strong>最后一个例子<code>printf(&quot;Gramps sez, \&quot; a \\ is a backslash.\&quot;\n&quot;);</code><em><strong>）。<br>  只要是一个字符，不管它是不是转义字符，当它是字符串的一部分的时候，都是需要用双引号框起来的，而不是单引号，但单个字符是无一例外由单引号括起来的。由双引号括起来的是</strong></em>字符串</strong></em>。（第四章会讲到）相似地，不属于转义字符的数字会被当做一般字符打印出来（如<code>printf(&quot;Hello!7\n&quot;);</code>打印出来的是<code>Hello7</code>，但<code>printf(&quot;Hello!\007&quot;);</code>输出的是一行<code>Hello！</code>加上一声警告）。</li>
<li><em><strong>我应该什么时候使用转义序列？什么时候使用对应的ASCII码？</strong></em><br>  如果你需要使用其中一个转义序列，比如说<code>&#39;\f&#39;</code>，或者作为替代的<code>&#39;\014&#39;</code>，最好使用前者。首先，这种表示方法更容易记忆：其次，它更容易在机器之间转移，如果其他系统不适用ASCII码，<code>&#39;\f&#39;</code>还是可以使用。</li>
<li>如果我需要使用数字变啊，为什么使用的是<code>&#39;\032&#39;</code>而不是<code>032</code>？<br>  第一，使用转义字符的方式会让阅读你代码的人轻松地知道这是一个字符编码。第二，如<code>\037</code>这样的转义序列是可以内嵌于C语言字符串的（？[就像<code>\007</code>一样])。</li>
</ul>
<h4 id="3-4-3-4-打印字符"><a href="#3-4-3-4-打印字符" class="headerlink" title="3.4.3.4 打印字符"></a>3.4.3.4 打印字符</h4><p><code>printf()</code>函数可以使用格式化符<code>%c</code>表示一个字符将要在这个位置被打印。你想到字符常量是1位的整型值，因此你也可以用<code>%d</code>符号，那样的话你就会得到一个整数，<code>%c</code>格式化符会告诉<code>printf()</code>函数来打印那个编码值对应的字符，例3.5就以两种方式展示了<code>char</code>类型变量。</p>
<p><img src="/img/Listing3.5.png" alt="例3.5"></p>
<p>尝试运行，输出是这样的。</p>
<p><img src="/img/C67.png"></p>
<p>当你使用程序的时候，不要忘记在写完了字符之后按下回车键。<code>scanf</code>函数会接收你写下的字符，然后取地址符(<code>&amp;</code>)会将字符赋给字符变量<code>ch</code>。接下来，<code>printf()</code>函数会打印两次<code>ch</code>这个变量，第一次是以字符的形式打印的（使用<code>%c</code>格式化符的效果），第二次是以十进制整数的形式（同理，<code>%d</code>的效果）。需要注意，<code>printf()</code>的标识符会决定数据被如何呈现，呈现方式与数据的储存方式没有关系。</p>
<p><img src="/img/Figure3.6.png" alt="数据储存与输出"></p>
<h4 id="3-4-3-5-有符号还是无符号？"><a href="#3-4-3-5-有符号还是无符号？" class="headerlink" title="3.4.3.5 有符号还是无符号？"></a>3.4.3.5 有符号还是无符号？</h4><p>有的C语言实现里会使<code>char</code>是一个有符号的类型，那也就意味着<code>char</code>可以接受从-128到127的值。其他的C语言实现会让<code>char</code>是一个无符号的类型，那么它的范围就变成了0到255，你的编译器的使用手册应该会告诉你<code>char</code>是什么类型，或者你可以看看<code>limits.h</code>头文件，下一章会讲述。</p>
<p>在C90标准下，C语言允许你使用关键字<code>unsigned</code>与<code>signed</code>来修饰<code>char</code>，那样的话不管原本的<code>char</code>是有符号还是无符号。你都可以任意变化它们的类型。它们在处理小范围的十进制整数时是很有用的。要是只是为了使用字符，只使用<code>char</code>就可以了。</p>
<h3 id="3-4-4-Bool类型"><a href="#3-4-4-Bool类型" class="headerlink" title="3.4.4 _Bool类型"></a>3.4.4 <code>_Bool</code>类型</h3><p><code>_Bool</code>类型是C99标准添加的，它们是被用来代表布尔值的，也就是逻辑上的<code>true</code>与<code>false</code>。因为C语言是使用0表示<code>false</code>，用1表示<code>true</code>的，所以布尔类型实际上只是一个整型，但是只需要一位的内存，因为要储存0与1一位就足够了。</p>
<p>程序会使用布尔值来选择下一步运行哪个代码，代码执行会在第六章（C语言控制语句：循环）与第七章（C语言控制语句：分支结构与跳跃结构）更详细地讲到，所以我们到那个时候再讨论这个问题。</p>
<h3 id="3-4-5-可转移的类型：inttypes-h"><a href="#3-4-5-可转移的类型：inttypes-h" class="headerlink" title="3.4.5 可转移的类型：inttypes.h"></a>3.4.5 可转移的类型：<code>inttypes.h</code></h3><p>还有更多的整数类型吗？没有了，但是还有更多你可以使用与已经存在的类型的名字。你或许会认为你已经看到的整型名已经很多了，但是原本的名字确实存在问题。知晓一个变量是<code>int</code>并不会让你了解它会占用多少内存，除非你检查了系统的描述文件。为了解决这个问题，<code>int16_t</code>可以声明一个16位的有符号整型，<code>uint32_t</code>声明了一个32位的无符号类型。</p>
<p>要让这些名字可用，你需要包含一个<code>inttypes.h</code>头文件（注意在这一版时候已经有了，但是一些编译器上还不支持这个功能），这个文件使用了<code>typedef</code>（第一次讲到是在第五章：运算符、表达式与语句），来创造新的类型名。例如，它会让<code>uint32_t</code>成为基本类型的一种别名或者同义替换，有可能是<code>unsigned int</code>也有可能是<code>unsigned long</code>。你的编译器会提供一个与你的计算机系统协调的头文件，这些新的设计被称为<em><strong>精确长度类型</strong></em>，例如，<code>int_least8_t</code>会是最小的类型，它可以承载8位的有符号整型值。如果某个系统上最小的类型是8位的。<code>int8_t</code>类型是不会被定义的，但<code>int_least8_int</code>是可以被定义的，或许会被实现为16位的整型。</p>
<p>当然，一些编程人员会更关心速度而不是空间。对于它们，C99定义了允许快速计算的一系列类型，它们被称为<em><strong>最快最小长度类型</strong></em>，例如，<code>int_fast8_t</code>会被定义为你的系统上能够最快运算的8位有符号值。</p>
<p>最后，对于其他的编程人员，只有系统上最大的一些整型才有用，<code>intmax_t</code>就代表了那种类型，它可以储存任何合法的有符号整型值，同样，<code>uintmax_t</code>会代表可用的最大的无符号类型。这些类型有时是比<code>long long</code>或者<code>unsigned long</code>还要长的，因为C语言实现是准许定义超过需要的类型的。</p>
<p>C99不仅提供了这些新的而且可运输的类型名，它还有有利于输入输出的符号表示。比如说，<code>printf()</code>对于每一种类型都需要特别的修饰符，所以你要打印<code>int32</code>，你要使用的是<code>%d</code>还是<code>%ld</code>？不同的机器的标识符并不一样，但没问题，C99标准下是有字符串宏命令来打印这些值的，我们会在第四章详细讲述的。例如，<code>inttype.h</code>头文件会将字符中的<code>PRId16</code>作为对于不同对应的类型的合适的格式化符。（例如hd（<code>short</code>）或者d），例3.6是一个讲述了如何使用可运输类型与相对应的格式化符的简单的例子。</p>
<p><img src="/img/Listing3.6.png" alt="例3.6"></p>
<p>在最后的<code>printf</code>语句中，<code>PRId16</code>被<code>inttypes.h</code>对<code>hd</code>的类型定义替换了，把这一行代码变成了这个样子。</p>
<p><img src="/img/turning1.png"></p>
<p>但是C语言需要连贯的字符串，所以引号需要是连续的，然后这一行就变成了这个样子。</p>
<p><img src="/img/turning2.png"></p>
<p>这就是输出，注意这个例子也使用了<code>\&quot;</code>转义字符来打印双引号。</p>
<p><img src="/img/out3.png"></p>
<p>参考单元VI“更多的整型”提供了<code>inttypes.h</code>头文件添加的内容的完整解释，也列举了所有的格式化宏。</p>
<p><img src="/img/C99sup.png"><br>【C99支持】<br>编译器供应商已经开始以不同的速度与顺序开始实现C99的新特性了，但在这本书出来的时候，一些编译器还没有实现<code>inttypes.h</code>的头文件与特征。</p>
<h3 id="3-4-6-float-double与long-double类型"><a href="#3-4-6-float-double与long-double类型" class="headerlink" title="3.4.6 float, double与long double类型"></a>3.4.6 <code>float, double</code>与<code>long double</code>类型</h3><p>对于大多数的软件开发项目来说，这些多种多样的整型已经能够很好地满足要求了。但是，对于财务或者面向数学的程序，我们通常会使用<em><strong>浮点数值</strong></em>，在C语言中，这些数字就对应着<code>float, double, long double</code>这几种类型，对应着FORTRAN与Pascal语言中的<code>real</code>类型。使用浮点数，正像上文所说，能够让你呈现更大范围的数字。包括十进制小数值。浮点数值的表示与<em><strong>科学计数法</strong></em>是很相似的，那是科学家用来表示非常大或者非常小的数字的一种体系。</p>
<p>在科学计数法中，数字会被表示成十进制数乘10的整数幂，这里就是一些例子。</p>
<p><img src="/img/sciennotation.png"></p>
<p>第一列是通常的表示方法，第二列是科学计数法的表示，第三列是质数的表示方法，或者说是<em><strong>e - notation（e表示法）</strong></em>，通常是给计算机或者计算机写的，在e的后面是10的指数，图3.7展示了更多的浮点表示法。</p>
<p>C语言标准规定了<code>float</code>类型应该至少能够代表6位有效数字并且范围在10的-37次方到37次方。第一个要求的意思是，比如一个<code>float</code>必须要精确地表示至少前六位有效数字，就像33.333333。如果你喜欢使用较大或者较小数字（2.0e30（太阳质量）或1.6e-19（元电荷））的话，第二条要求会为你提供方便。通常，系统会使用32位类储存一个浮点类型的数字，8位用来给予指数值与符号，24位来表示非指数部分，叫尾数或者有效数字与它的符号。</p>
<p><img src="/img/Figure3.7.png" alt="一些浮点数表示"></p>
<p>C语言也有一个<code>double</code>（双（double）精度）浮点型，<code>double</code>类型与<code>float</code>类型需要的最小值是一样的，但是它把最小值的有效数字位数拓展到了10位。通常的<code>double</code>表示会使用64位而不是32位，一些系统会使用32个位来表示非指数部分，这也就增加了数字有效的有效数字位数，减少了取整错误。其他的系统会使用一些位储存更大的指数，这也就增加了可以容纳数字的范围。每一张方法都至少有13位的有效数字，不只能满足最小标准的要求。</p>
<p>C语言还允许你使用一种浮点类型：<code>long double</code>，目的就是进一步增加<code>double</code>类型的准确度。但是C语言只保证<code>long double</code>至少与<code>double</code>类型的精度是一样的。</p>
<h4 id="3-4-6-1-声明浮点变量"><a href="#3-4-6-1-声明浮点变量" class="headerlink" title="3.4.6.1 声明浮点变量"></a>3.4.6.1 声明浮点变量</h4><p>浮点变量与它们的整型兄弟的声明与定义的方式相似，这里是一些例子，</p>
<p><img src="/img/floatdeclare.png"></p>
<h4 id="3-4-6-2-浮点常量"><a href="#3-4-6-2-浮点常量" class="headerlink" title="3.4.6.2 浮点常量"></a>3.4.6.2 浮点常量</h4><p>当你书写一个浮点常量时，你会有很多的选择，形式是很多，有符号的一串数字。包括十进制的小数点，或是由e或者E跟着的10的指数。这里是两个合法的声明浮点类型的例子。。</p>
<p><img src="/img/twoexam.png"></p>
<p>你可以遗漏正号，没有关系（2E5）或者可以遗漏指数部分（19.28），但是并不能同时存在。你可以遗漏小数部分或者整数部分，但也不能全都没有（那也不剩什么了。）下面是更多的合法的浮点常量。</p>
<p><img src="/img/morevalid.png"></p>
<p>在使用浮点常量的时候，不要乱添加空格。</p>
<p><img src="/img/nospaces.png" alt="错的"></p>
<p>一般来说，编译器会认为浮点常量都是<code>double</code>精度的，假设<code>some</code>是一个<code>float</code>类型的变量，并且你有下面的一行代码。</p>
<p><img src="/img/codeline.png"></p>
<p><code>4.0</code>与<code>2.0</code>都是以<code>double</code>类型储存起来的，一般每一个使用64位，结果是使用浮点运算获得的，而且只有结果转换成了正常的<code>float</code>大小范围内才可以使用<code>float</code>。这也就为运算提供了准确度，但是会让你的程序变慢。</p>
<p>C语言还是你能够超越默认方法，你可以使用f或者F后缀来让编译器把一个浮点常量储存为<code>float</code>类型，比如<code>2.3f</code>与<code>9.11E9F</code>还有<code>l</code>或者<code>L</code>后缀，可以储存为<code>long double</code>类型，例如<code>54.3l</code>，<code>4.23e4L</code>。注意的是，比起<code>l</code>，<code>L</code>更不容易被看成<code>1</code>，如果浮点数没有后缀，它的类型就是<code>double</code>。</p>
<p>C99添加了表示浮点数的另一种方式，它是使用十六进制来表达的（0x或者0X加上十六进制数）。那样指数就是<code>p</code>或者<code>P</code>而不是<code>e</code>或者<code>E</code>了，指数是2的，也不再是10的了。这就是数字看起来的样子。</p>
<p><img src="/img/lookslike.png"></p>
<p><code>a</code>是十进制的10，<code>.1f</code>是1&#x2F;16加上15&#x2F;256，然后<code>p10</code>是2的10次方，或者1024，用十进制表示这就是10364.0。</p>
<p>并不是所有的编译器都已经支持C99的特性了。</p>
<h4 id="3-4-6-3-打印浮点数值"><a href="#3-4-6-3-打印浮点数值" class="headerlink" title="3.4.6.3 打印浮点数值"></a>3.4.6.3 打印浮点数值</h4><p><code>printf()</code>函数会使用<code>%f</code>格式化符来打印<code>float</code>与<code>double</code>类型的数值，这个符号使用的是十进制小数符的表示方法，还可以使用<code>%e</code>来使用指数表示法来打印它们，如果你的系统支持C99中提供的小数的十六进制格式，你就可以使用<code>a</code>或者<code>A</code>代替<code>e</code>与<code>E</code>。<code>long double</code>类型是以<code>%Lf</code>或者<code>%Le</code>与<code>%La</code>标识符来分别使用这三种方式的。需要注意的是，<code>float</code>与<code>double</code>都可以使用<code>%f, %e, %a</code>标识符来输出。这是因为当一个<code>float</code>类型的变量作为语句传递到任何函数时，C语言会自动把它转化成<code>double</code>类型，而不是它本来的类型，比如说<code>printf()</code>函数就是一个例子。例3.7说明了这种行为。</p>
<p><img src="/img/Listing3.7" alt="例3.7"></p>
<p>这里是输出：</p>
<p><img src="/img/out1.png"></p>
<p>这个例子说给出了默认的输出，下一章会讨论如何通过设置输出域长度与十进制的位权数，控制输出的外形。</p>
<h4 id="3-4-6-4-浮点上溢与下溢"><a href="#3-4-6-4-浮点上溢与下溢" class="headerlink" title="3.4.6.4 浮点上溢与下溢"></a>3.4.6.4 浮点上溢与下溢</h4><p>可能最大的<code>float</code>类型就是值大概是3.4E38，然后你执行了下面的代码。</p>
<p><img src="/img/toobig.png"></p>
<p>输出（个人测试）</p>
<p><img src="/img/INF.png"></p>
<p>发生了什么？这就是<em><strong>溢出</strong></em>的一个例子-运算得出的结果大到无法表示。对于这种情况，这种行为之前是没有被定义的，但是现在C语言指定<code>toobig</code>是一个几乎代表<em><strong>无限</strong></em>的数字，<code>printf()</code>就会显示<code>inf</code>（infinity）（或者那个样子的一些变体）</p>
<p>那么如果是要分辨非常小的数字呢？这是会遇到更多的情况。你可以记起<code>float</code>是以指数部分与数字部分（或尾数）来储存的。如果会有一个数字有着最小的指数与最小的值，而且仍然可以使用所有可以使用的位来表达尾数，在<code>float</code>的精度范围内表示，这就是<code>float</code>类型下的最小值。现在我们把它除2，一般地，这会减少指数，但是指数也是能够表达的最小值了。所以就要到尾数的空余位那里减了，把第一位清空，然后丢掉最后的二进制值，类比一下就是，用四位有效数字的10进制值，比如<code>0.1234E-10</code>，除10，结果就是<code>0.01234E-10</code>，你就可以得到答案了，但是你会在这个过程中丢掉一个数字。这种情况就叫做下溢，C语言对于失去完全精度的浮点数值叫做<em><strong>subnormal</strong></em>（反常值）。所以把最小的正常浮点值除2就会有反常值。如果你除了一个太大的数字，你就会失去所有的精度，最后只剩下0，C语言库现在提供了函数来检查是否你的运算产生了反常数值。</p>
<p>这里还有另一种特别的浮点值，<code>NaN</code>。例如你给予<code>asin()</code>函数一个名字它会返回所给数值的sin值，但是sin的数值并不能大于1，所以函数对于大于1的数值是未定义的，在这种情况下函数就会返回<code>NaN</code>值，那会被<code>printf</code>打印为<code>nan</code>、<code>NaN</code>或者相似的东西。</p>
<p><img src="/img/drop4in5.png" alt="四舍五入问题"><br>拿一个数字，加1，然后减去原来的数，你会得到几？肯定是1是吧？像下面的浮点运算给予了你不同的答案。</p>
<p>输出是这个样子的：</p>
<p><img src="/img/alldevices.png"></p>
<p>这三种奇怪的结果的原因是电脑并不能够跟踪需要多少十进制空间来进行恰当的运算，2.0e20是2后面跟着20个0，通过加1的操作，你要改变这个数字的第21位数字，要正确地执行这个操作，程序需要能够储存21位数字的类型，<code>float</code>类型数通常只是六位或者七位数带着指数这个范围（最后的一位只能是0，不能改变）所以这种尝试在劫难逃。另一方面，如果你使用2.0e4的话你就可以得到正确的结果，因为你改变的是第5位数，<code>float</code>类型的精度允许你这样做。</p>
<h3 id="3-4-7-复数与虚数类型"><a href="#3-4-7-复数与虚数类型" class="headerlink" title="3.4.7 复数与虚数类型"></a>3.4.7 复数与虚数类型</h3><p>许多科学与工程运算会使用复数与虚数，C99为这些数提供了支持，（with some reservations），它是一个独立的实现，就像内置预处理命令一样，不需要其他类型的支持。（VCR芯片很可能并不需要复数来工作）。并且，更一般地。虚数类型是可选择的。简单来说，有三种复数类型，<code>float_Conplex，_Complex</code>与<code>long double _Complex</code>，举个例子，一个<code>float _Complex</code>变量，会包含两个<code>float</code>类型的值，一个代表复数的实部，另一个代表虚部。相思地，有三种虚数类型，它们叫做<code>float _Imaginary, double _Imaginary</code>与<code>long double _Imaginary</code>。</p>
<p>包含<code>complex.h</code>头文件可以使你把<code>_Complex</code>与<code>_Imaginary</code>分别更换为<code>complex</code>与<code>imaginary</code>。而且还能够让你使用I来代表-1的平方根。</p>
<h3 id="3-4-8-超越基本类型"><a href="#3-4-8-超越基本类型" class="headerlink" title="3.4.8 超越基本类型"></a>3.4.8 超越基本类型</h3><p>这样我们已经讲完了一系列基本的数据类型了，对于你们其中一些人来说，数据类型可能很多，还有一些人可能会想着还需要其他的类型，比如说字符串类型。但C语言并没有。但是还是能够很好的处理字符串，你会在第四章第一次见到字符串。</p>
<p>C语言确实有其他的类型，他们是从基本类型中衍生出来的。这些类型包括数组、指针、结构体、联合体。即使它们都是后面章节才要讲到的，我们已经在这一章的例子中已经偷摸添加了一些关于指针的东西了。（指针会指向变量或者其他数据对象的地址，<code>scanf()</code>中使用的<code>&amp;</code>前缀就会创造一个指针，他会告诉<code>scanf()</code>在哪储存信息）</p>
<p><img src="/img/basicdata.png"><br><strong>总结：基本数据类型</strong><br>    <strong>关键字</strong>：<br>    基本的数据类型是由11个关键字组成的：<code>int, long, short, unsigned, char, float, double, signed, _Bool, _Complex, _Imaginary</code><br>    <strong>有符号整型</strong>：<br>    可以是整数值也可以是负值<br>    1. <code>int</code>- 系统给定的基本整型。C语言保证<code>int</code>至少有16位。<br>    2. <code>short</code>或<code>short int</code> - 最大的短整型不大于最大的<code>int</code>，并有可能更小，C语言保证<code>short</code>类型至少有16位。<br>    3. <code>long</code>或<code>long int</code> - 能够保存至少<code>int</code>的最大值大小的数，可以更大。C语言会确保<code>long long</code>类型至少有32位。<br>    4. <code>long long</code>或<code>long long int</code> - 这个类型至少能够保存<code>long</code>类型数的最大范围，可以更大，<code>long long</code>类型最小64位。</p>
<p>通常，<code>long</code>类型是比<code>short</code>类型更短的，<code>int</code>会与他们之中的一个一样大。例如，以DOS系统为基础的PC系统，<code>short</code>是16位长的，而<code>int</code>是32位长的，以Windows 95为基础的系统会提供16位的<br><code>short</code>，而<code>long</code>与<code>int</code>类型是32位的。</p>
<p>如果你喜欢的话，你可以在任何有符号类型前使用<code>signed</code>关键字，将它们有符号这个事实显露出来。<br><strong>无符号整型：</strong><br>    这些类型只能从0到整数，因为去掉了符号位，这种类型的范围得到了扩大，使用关键字<code>unsigned</code>可以把你想要的类型变为无符号类型：比如<code>unsigned int, unsigned long, unisgned short.</code>单个的<code>unsigned</code>与<code>unisgned int</code>是一样的。<br><strong>字符：</strong><br>    它们是像<code>A, &amp;</code>这样的印刷字符。在定义上，字符类型会使用1个字节的内存来代表一个字符。在以往，字符字节大多数是8位，但现在它可以是16位或者更大，可以迎合使用的基准字符集的大小。<br>        <strong>char</strong> - 这种类型的关键字，一些实现中会使用有符号的<code>signed char</code>，但其他还是使用无符号字符。C语言允许你使用<code>signed</code>或者<code>unsigned</code>来划定你想要的类型。<br><strong>布尔类型：</strong><br>    布尔值代表<code>true</code>与<code>false</code>，C语言会使用0与1代表这两个值。<br>        <strong>_ Bool</strong> - 是这种类型的关键字，它是一个无符号整型，只需要保存0与1这两个值的内存。<br><strong>实数浮点型：</strong><br>    可以正数、负数或者零。<br>        [<code>float</code>] 是系统的基本浮点类型，可以至少呈现6位精确的有效数字。<br>        [<code>double</code>] 一种（可能是）更大的浮点储存单元，允许更大的有效数字位数（至少10位，通常会更多。）而且有可能比float也有更多的指数位数。<br>        [<code>long double</code>] 一种（可能是）更大的浮点储存单元，它可能允许更多的有效数字位数，也有可能有着比<code>double</code>类型更大的指数部分。<br><strong>复数与虚数浮点型：</strong><br>    虚数类型是可以选择的，实部与虚部是基于实数类型的：<br>        <code>float _Complex</code><br>        <code>double _Complex</code><br>        <code>long double _Complex</code><br>        <code>float _Imaginary</code><br>        <code>double _Imaginary</code><br>        <code>long double _Imaginary</code></p>
<p><img src="/img/Summary.png"></p>
<p><strong>总结：如何声明一个简单的变量</strong></p>
<ol>
<li>选择你需要的类型</li>
<li>使用允许的字符为你的变量起个名字</li>
<li>使用以下形式的声明语句<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//type-specifier variable-name;</span></span><br><span class="line"><span class="comment">//类型标识符 变量名;</span></span><br><span class="line"><span class="type">int</span> Iint1;</span><br></pre></td></tr></table></figure></li>
<li>你可以通过用逗号把变量名隔开来声明多个变量，下面就是一个例子。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> ch, init, ans;</span><br></pre></td></tr></table></figure></li>
<li>你可以在声明语句中对变量进行初始化：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> mass = <span class="number">6.0E24</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-4-9-类型大小"><a href="#3-4-9-类型大小" class="headerlink" title="3.4.9 类型大小"></a>3.4.9 类型大小</h3><p>表3.3与3.4展示了一些C语言环境下的类型大小（在一些环境中，你可以选择）你的系统是什么样子的？尝试运行例3.8中的程序，你会弄明白的。</p>
<p><img src="/img/Twotables.png" alt="表3.3与3.4"><br>（分别是整型与浮点型的大小。）</p>
<p>对于每一种类型，最上面的一行是有效数字的位数，第二行是指数的范围（十进制）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//(例 3.8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*C99为大小提供了%zd格式化符*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Type int has a size of %u bytes.\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Type char has a size of %u bytes.\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Type long has a size of %u bytes.\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Type double has a size of %u bytes.\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C语言有一种内置的运算符，它叫<code>sizeof()</code>，它会给出以比特为单位的大小范围。（一些编译器需要<code>%lu</code>而不是<code>%u</code>来打印<code>sizeof</code>数值，这是因为C语言对于<code>sizeof</code>用来报告的真实的无符号整型是有多个范围的。C99对于这种类型给出了<code>%zd</code>标识符，如果编译器支持的话你应该使用这个。）例3.8的输出是这个样子的。</p>
<p><img src="/img/sizes.png"></p>
<p>这个程序只发现了4种类型的范围，但是你可以简单修改一下这个程序来找寻你感兴趣的任何一种类型，要注意的是<code>char</code>类型的大小一定是1个字节，因为C语言对于<code>char</code>类型定义的就是一个字节。所以在有16位的<code>char</code>与64位的<code>double</code>的系统上，<code>sizeof</code>会报告<code>double</code>类型有4个字节的大小。你可以看看limits.h与float.h头文件来获取更多关于类型最大最小值的细节信息。（下一章会进一步阐述这两个文件。）</p>
<p>顺便一说。看看最后一行<code>printf()</code>是如何延伸到两行的，只要不是在双引号部分或者在一个单词的中间断开，你可以这样做。</p>
<h3 id="3-4-10-可用数据类型"><a href="#3-4-10-可用数据类型" class="headerlink" title="3.4.10 可用数据类型"></a>3.4.10 可用数据类型</h3><p>当你正在开发一个程序时，需要注意你需要的变量与它们应该使用的类型。大多数情况，你可以使用<code>int</code>或者<code>float</code>来表示一个数，用<code>char</code>来表示字符，在使用它们的函数的开头先声明好它们。为变量取一个能够暗示它们的意义的名字。初始化一个变量时，也要让变量类型与赋给的常量类型匹配。这里就是两个例子。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> apples = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> oranges = <span class="number">3.0</span>;</span><br></pre></td></tr></table></figure>

<p>C语言对于类型不搭配比起Pascal是很宽容的，C语言的编译器允许你进行二次初始化，但是它们有可能会引起报错，尤其是当你触发了一个高级警告时。最好不要养成这种马马虎虎的习惯。</p>
<p>当你使用其他类型的值给一个数字类型的值初始化时，C语言会将这个值进行转化，来让它与这个变量的类型相配。这也就意味着你有可能会失去一些数据，比如思考一下下面的初始化过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> cost = <span class="number">12.99</span>;        <span class="comment">/*使用double值来初始化int*/</span></span><br><span class="line"><span class="type">float</span> pi = <span class="number">3.1415926536</span>; <span class="comment">/*使用double值来初始化float*/</span></span><br></pre></td></tr></table></figure>

<p>第一个声明语句会将12赋给<code>cost</code>变量，当把浮点数转换为整数值时，C语言简单地把小数部分丢掉（截断），而不是四舍五入。第二行的声明会失去精度，因为<code>float</code>类型是只能呈现小数点后6位精确数的。如果进行这样的初始化，编译器有可能会发出一个警告（但不是一定会发），你有可能在编译例3.1的时候遇到这个问题。</p>
<p>许多的编程者与组织人员拥有设置变量名称的体系化传统方法，按照这种方式就可以显示出变量的类型。例如你可以使用<code>i_prefix</code>来表示这是个<code>int</code>类型变量，同理<code>us_</code>来表示<code>unsigned_short</code>，这样的话对于类型就好辨认一些。</p>
<h3 id="3-4-11-参数陷阱"><a href="#3-4-11-参数陷阱" class="headerlink" title="3.4.11 参数陷阱"></a>3.4.11 参数陷阱</h3><p>在这一章的前半部分，有一个关于<code>printf()</code>使用的警告还是很值得重复强调的。你可能还记得传递给函数的信息在术语上称为参数。例如，<code>printf(&quot;Hello, pal.&quot;)</code>就有一个参数：<code>&quot;Hello, Pal.&quot;</code>。我们把在双引号中的一系列字符叫做<em><strong>字符串</strong></em>，我们会在第四章讨论。现在的重点是，一个字符串，即使包含着好几个单词与标点符号，也仍然被算作是一个参数。</p>
<p>相似地，<code>scanf(&quot;%d&quot;, weight)</code>有两个参数：<code>&quot;%d&quot;</code>与<code>&amp;weight</code>。C语言会使用逗号来分开函数中的各个参数，<code>printf()</code>与<code>scanf()</code>函数还挺不寻常的，它的参数数量是不限的。例如，我们曾经在使用<code>printf()</code>时传递过一个、两个甚至是三个参数。对于一个恰当运行的程序，它需要知道参数的数量。<code>printf()</code>与<code>scanf()</code>函数会使用第一个参数来表达之后会有多少个其他的参数。这里的诀窍就是在最前的字符串中的每一个格式化符都代表着后面有一个参数，例如下面的语句就有两个格式化符：<code>%d</code>与<code>%d</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d cats ate %d cans of tuna\n&quot;</span>, cats, cans);</span><br></pre></td></tr></table></figure>

<p>这也就告诉程序后面要接收两个额外的参数，而且后面确实有两个——<code>cats</code>与<code>cans</code>。</p>
<p>作为一个编程人员，你的责任就是确保格式化符的数量与其他的参数的数量相同，类型相同。C语言现在已经有函数原型机制了，它能够检查一次函数调用是否使用了正确的数字与正确的参数类型，但是对于<code>printf()</code>与<code>scanf()</code>是不适用的，因为它们参数的数量是可变的。当你并没有接收程序员的负担会怎样呢？举个例子，假设你写了例3.9那样的程序。</p>
<p><img src="/img/Listing3.9.png" alt="例3.9"></p>
<p>下面是从微软VisualC++ 7.1（WinXP系统）上运行的结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">4 34603777</span><br><span class="line">0 0.000000</span><br></pre></td></tr></table></figure>

<p>这是在Digital Mars（WinXP系统）上运行的结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">4 4239476</span><br><span class="line">0 0.000000</span><br></pre></td></tr></table></figure>

<p>这是在Metrowerks Codewarrior Development Studio 9（MacOSX系统）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">4 3327456</span><br><span class="line">1075052544 0.000000</span><br></pre></td></tr></table></figure>

<p>你可以看到，使用<code>%d</code>来表示一个<code>float</code>类型的值并不会将它变成最近的<code>int</code>类型值，而是直接输出垃圾值。相似地，使用<code>%f</code>来表示一个<code>int</code>类型的值也并不会将整数转化为浮点数值。参数太少或者类型不对得到的结果不同的平台也不一样。</p>
<p>没有一个编译器对于这个代码有报错或者警告，在运行时也没有。一些编译器确实会捕捉到这种错误，但是C语言标准并没有要求它们这样做。因此，电脑就不一定能够补货到这种类型的错误，因为程序反而还能够正常地运行，你也不一定能够注意到这种错误。如果程序并没有打印正确的数值数量或者是数值，那就回去看看<code>printf()</code>的参数数量与类型是否使用正确。（顺便一说，Unix语法检测程序lint，它比Unix编译器检查得更加细致，能够对于<code>printf()</code>的参数错误进行报错）。</p>
<h2 id="3-5-又一个例子：转义序列。"><a href="#3-5-又一个例子：转义序列。" class="headerlink" title="3.5 又一个例子：转义序列。"></a>3.5 又一个例子：转义序列。</h2><p>让我们在程序中打印更多东西吧，这一次我们会使用C语言中的一些针对于字符的特殊转义序列。尤其地，例3.10中的程序显示了回车符(<code>\b</code>)，水平制表符(<code>\t</code>)以及回行符（<code>\r</code>）是怎么工作的。这些概念要追溯到电脑还在使用电传打字机的时代，它们并不总是会在现代的图形界面上正确地翻译。例如，例3.10在一些Mac系统的实现上就不能够按照想要的方式来运行。</p>
<p><img src="/img/Listing3.10.png" alt="例3.10"></p>
<h3 id="3-5-1-当程序运行的时候发生了什么？"><a href="#3-5-1-当程序运行的时候发生了什么？" class="headerlink" title="3.5.1 当程序运行的时候发生了什么？"></a>3.5.1 当程序运行的时候发生了什么？</h3><p>让我们一步步地浏览这个程序，好让它能够在ANSI实现下运行。第一个<code>printf()</code>函数语句（标<code>1</code>的那个）会发出警告信号（由<code>\a</code>引起），然后会打印如下的句子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter your desired monthly salary:</span><br></pre></td></tr></table></figure>
<p>因为在字符串最后没有<code>\n</code>符号，所以光标还是在冒号后面。</p>
<p>第二个<code>printf()</code>语句会接着第一句结束的地方开始，所以当它执行完毕时，屏幕上看起来是这个样子的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter your desired monthly salary: <span class="variable">$______</span></span><br></pre></td></tr></table></figure>

<p>在冒号与美元符号之间有一个空格，因为第二个<code>printf()</code>的字符串是以空格开始的，7个退格符的作用是把光标向左移动7个单位。这就会将光标移到下划线字符前面，正好放在美元符号后面。通常地，退格符并不会移除前面的字符，但是有一些实现是有可能移除的，那样这个小练习就没有用了。</p>
<p>现在，你会输入你的回答，比如说你输入了<code>2000.00</code>，那么这一行看起来就会是这个样子。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter your desired monthly salary: <span class="variable">$2000</span>.00</span><br></pre></td></tr></table></figure>

<p>你输入的字符将会覆盖换行符，而且当你点<code>Enter</code>键（或者<code>Return</code>）来输入你的回答时，光标就会跳转到下一行。</p>
<p>第三个<code>printf()</code>语句是以<code>\n\t</code>开始的，换行符将会将光标移动到下一行的最开始，而tab键通常会将光标移动到那一行的下一个制表位（但并不是一定），也就是第9列。然后字符串的剩余部分就会被打印下来。在这个语句执行之后，屏幕上看起来就会变成这样。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter your desired monthly salary: <span class="variable">$2000</span>.00</span><br><span class="line">	<span class="variable">$2000</span>.00 a month is <span class="variable">$24000</span>.00 a year.</span><br></pre></td></tr></table></figure>
<p>因为这个<code>printf()</code>语句并没有使用换行符，光标还是在这一句的最后位置。</p>
<p>第四个<code>printf()</code>使用了<code>\r</code>符号，它会将光标移动到一行的开头位置，这个语句执行之后屏幕上就成了这样。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter your desired monthly salary <span class="variable">$2000</span>.00</span><br><span class="line">Gee!    <span class="variable">$2000</span>.00 a month is <span class="variable">$24000</span>.00 a year.</span><br></pre></td></tr></table></figure>

<h3 id="3-5-2-输出清理"><a href="#3-5-2-输出清理" class="headerlink" title="3.5.2 输出清理"></a>3.5.2 输出清理</h3><p><code>printf()</code>函数什么时候才会将输出发送到屏幕上呢？首先，<code>printf()</code>语句会将输出发送到<em><strong>缓冲区</strong></em>，时不时地，在缓冲区的内容就会被发送到屏幕上。对于输出什么时候从缓冲区发送到屏幕上，基础的C语言规则已经很清晰了：当缓冲区被充满时，当遇到一个换行符的时候，以及当有即将发生的输出行为时。（从缓冲区发送输出信息到屏幕或者是文件上叫做<em><strong>刷新缓冲区</strong></em>），例如，最先的两个<code>printf()</code>函数语句并不会填充缓冲区，也并没有包含换行符。在那种情况下，你可以使用一个换行符来刷新缓冲区，那样的话代码就可以写成这个样子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter your desired monthly salary: \n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;salary);</span><br></pre></td></tr></table></figure>

<p> 不管即将到来的输入信息是不是会刷新缓冲区，这几行代码都是可以正常工作的。但是，它也会将光标移到下一行，防止你把数据与提示字符串写到一行。另一种方式是使用<code>fflush()</code>函数，它会在第13章，文件输入与输出中讲到。</p>
<h1 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h1><p>C语言有着许多种数字类型，这也反映了C语言避免让编程人员陷入障碍的目的。比起用一种类型包管全部数字类型，C语言尽力给予编程人员对于数字的特定种类（比如说有符号与无符号），以及最能够适合特定程序的数字范围大小的选择。</p>
<p>在一台电脑上，浮点数与整型的基础是不一样的。它们会被以不同的形式储存于处理。两个32位的内存单元能够保存相同的位形式（二进制数表示是一样的。）但是如果其中一个被理解为<code>float</code>而另一个被理解为<code>long</code>，这两个内存单元就会代表完全不同也不相关的两个数，例如在个人电脑上，如果你使用代表256.0的浮点储存单元，但是让它被理解为long，你就会得到113246208这个数。C语言确实允许你使用多种数据类型来书写表达式，但是它会自动进行类型转换，所以真正的运算只有一种数据类型。</p>
<p>在电脑内存中，字符是以数字编码的形式呈现的，ASCII码是美国最常用的数字代码标准，但是C语言也支持其他代码集。字符常量是电脑上数字编码的符号表示-它是由单引号框定的单字符，比如<code>&#39;A&#39;</code>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C语言有各种各样的数据类型，基本的数据类型可以分为两类：整型与浮点型，对于整型，两个最鲜明的区分就是分配给不同类型的储存空间，还有是否有符号。最小的整型是<code>char</code>，它可以有符号，也可以没有，这取决于不同的C语言实现，你可以根据自己的需求来选择<code>signed char</code>与<code>unsigned char</code>，但是那通常是在你使用范围比较小的数字的情况下，而不是使用字符编码时。其他的整型还有<code>short, int, long, long long</code>等。C语言确保了所有的类型都至少会与它前面的类型一样大，它们都是有符号类型，但你还是可以加上<code>unsigned</code>修饰符来创造相应的无符号类型：<code>unsigned short, unsigned int, unsigned long, unsigned long long</code>或者你也可以使用<code>signed</code>修饰符来明显地写出它是有符号的。最后，还有<code>_Bool</code>类型，一种无符号类型，它只能保存0与1，分别代表着<code>false</code>与<code>true</code>。</p>
<p>浮点类型有三种，分别是<code>float, double</code>与在ANSI C中的<code>long double</code>，每一个类型也是至少比它前面的那个类型一样大的。要是想的话，你也可以用<code>_Complex</code>与<code>_Imaginary</code>与浮点类型关键字连用，来使用虚数与复数类型。例如，有<code>double _Complex</code>与<code>float _Imaginary</code>类型。</p>
<p>整型可以被以十进制、八进制与十六进制的形式被输出，开头写0可以使一个数变为八进制数，写0x或者0X可以变为十六进制数。例如<code>32, 040</code>还有<code>0x20</code>就分别是十进制、八进制与十六进制的数字，但是它们代表的都是同一个值。另外使用<code>l</code>或者<code>L</code>符号可以声明一个<code>long</code>类型的常量值，<code>ll</code>或者<code>LL</code>可以声明一个<code>long long</code>类型的值。</p>
<p>字符常量是由单引号及其中的字符代表的：比如<code>&#39;Q&#39;, &#39;8&#39;</code>。字符还包括转义序列，比如<code>\n</code>，它们代表着不会被打印出来的特定字符，你可以使用类似<code>\007</code>的形式来使用ASCII码的形式来代表字符。</p>
<p>浮点数可以以十进制小数点的形式来表示，也可以以指数符号的形式来表示，例如<code>7.38E10</code>。</p>
<p><code>printf()</code>函数能够让你利用格式化转换符，以最简洁的方式打印各种各样的数值，它由一个百分号符<code>%</code>与一个表示类型的字符组成，比如<code>%d</code>或者<code>%f</code>。</p>
<h1 id="回顾问题"><a href="#回顾问题" class="headerlink" title="回顾问题"></a>回顾问题</h1><p>你会在附录A中找到这些问题的答案。<br>1.你对于这几种数据你会使用哪种数据类型？</p>
<blockquote>
<p>1.东斯普尔顿的人数 – int类型（16位即可）<br>2.在DVD上电影的价格–float类型<br>3.这一章最常见的字母–char类型<br>4.一个字母在这一章中出现的次数。– int类型（。）</p>
</blockquote>
<p>2.为什么有时候你会使用<code>long</code>而不是<code>int</code>。</p>
<blockquote>
<p>有些时候表示的范围会更大，但是并没有超过<code>long</code>，使用<code>long</code>类型可以保证数据因为存放不下而溢出，从而导致不同机型显示不一而且不会报错的问题。</p>
</blockquote>
<p>3.如果你想要得到一个32位有符号的整型，你会使用哪种可转移的类型，请写出所有类型，并说说每一种的合理性。</p>
<blockquote>
<p>1.在<code>&lt;inttypes.h&gt;</code>中的<code>int32_t</code>类型<br>2.基本类型中的<code>long</code>或者<code>int</code>类型（对于<code>int</code>来说不一定）</p>
</blockquote>
<p><code>long</code>合理，因为关键字更简洁容易记，格式化符也不容易弄错<br>（<code>int32_t</code>为<code>PRId32</code>,<code>long</code>为<code>%ld</code>）<br><code>int32_t</code>能够让编程人员选择适合的大小范围来进行编程，便于大小的记忆。</p>
<p>4.确认每种类型与它的含义。</p>
<blockquote>
<p>1.<code>&#39;\b&#39;</code>回车符（转义序列）<br>2.<code>1066</code>一个整数，一千零六十六<br>3.<code>99.44</code> 一个两位小数，九十九点四四<br>4.<code>0XAA</code>，十六进制数，10 * 16 + 10 &#x3D; 170.<br>5.<code>2.0e30</code>，指数形式的小数，2 * 10^30(10的30次方)</p>
</blockquote>
<p>5.Dottie Cawm 编造了这个满是错误的程序，请找到这个程序中问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">main</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> g; h;</span><br><span class="line">	<span class="type">float</span> tax, rate;</span><br><span class="line"></span><br><span class="line">	g = e21;</span><br><span class="line">	tax = rate * g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（实在是太明显了啊。。）<br>1.include前面忘了#<br>2.main。。。（int main(void)，或者void main()）<br>3.g后面用了分号来分隔，相当于h未规定类型。<br>4.应该是1e21，e21啥也不是。<br>5.tax类型与g的类型大小都太小了，应该用double，float表示不了精确的21位数，或者直接使用long long也可以，反正是整型。<br>6.忘了写<code>return 0;</code></p>
<p>6.确定下面几种常量数据的类型，与打印他们所使用的格式化标识符。<br><img src="/img/Identifytypes1.png"></p>
<blockquote>
<p>·····12为整型，（int（作为常量，默认为int）），输出可以使用<code>%d</code>,<code>%hd</code>,<code>%u</code>,<code>%LLu</code>,<code>%lu</code>。<br>·····<code>0X3</code>，十六进制数，<code>%X</code><br>·····<code>&#39;C&#39;</code>，字符常量，<code>%c</code><br>·····<code>2.34E07</code>,后面看成八进制，但仍然是7，小数的指数形式，用<code>%f</code>或者<code>%lf</code>都可以。<br>·····<code>\040</code>,十进制的040为32，此即<code>32</code>,即<code>&#39; &#39;</code>（空格字符）<br>·····<code>7.0</code>，一位小数，可以使用<code>%f</code>或者<code>%lf</code><br>·····<code>6L</code>,为<code>long</code>形式整型，可以使用<code>%ld</code>输出。<br>·····<code>6.0f</code>,为<code>float</code>形式小数，可以使用<code>%f</code>。</p>
</blockquote>
<p>7.同上<br><img src="/img/Identifytypes2.png"></p>
<blockquote>
<p>·····012，八进制数，十进制下为10，可以用<code>%o</code>输出。<br>·····2.9e05L，<code>long double</code>，2.9 * 10^5.<br>·····<code>&#39;s&#39;</code>,字符常量，用<code>%c</code>.<br>·····<code>100000</code>,<code>32</code>位的<code>int</code>，<code>%ld</code>，或者<code>%lu</code>或者更大的类型<code>long long</code>。<br>·····<code>&#39;\n&#39;</code>,转义序列换行符，直接打印即可。<br>·····20.0f，<code>float</code>类型，<code>%f</code>。<br>·····0x44，十六进制数，68.用<code>%x</code>输出。</p>
</blockquote>
<p>8.假设你的程序是以这几行声明语句开头的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> imate = <span class="number">2</span>;</span><br><span class="line"><span class="type">long</span> shot = <span class="number">53456</span>;</span><br><span class="line"><span class="type">char</span> grade = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">float</span> <span class="built_in">log</span> = <span class="number">2.71828</span>;</span><br></pre></td></tr></table></figure>

<p>在下面的<code>printf()</code>函数语句中填入适当的格式化符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The odds against the %__ were %__ to 1.\n&quot;</span>,imate, shot);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A score of %__ is not an %__ grade.\n&quot;</span>, <span class="built_in">log</span>, grade);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The odds against the %d were %ld to 1.\n&quot;</span>,imate, shot);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A score of %f is not an %c grade.\n&quot;</span>, <span class="built_in">log</span>, grade);</span><br></pre></td></tr></table></figure>

<p>9.假设<code>ch</code>是一个字符变量，展示一下如何将回行符通过转义序列、十进制数值与八进制及十六进制字符常量的形式赋给ch的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">ch = <span class="string">&#x27;\r&#x27;</span>;</span><br><span class="line">ch = <span class="number">13</span>;</span><br><span class="line">ch = <span class="string">&#x27;\0x0D&#x27;</span>;</span><br><span class="line">ch = <span class="string">&#x27;\015&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>10.纠正这个愚蠢的程序。<br><img src="/img/Perfect.png" alt="&quot;Perfect...&quot;"><br>（在C语言中<code>\</code>表示除）</p>
<p>1.未指定形式参数的变量名。（main(int a)）<br>2.注释符号没用对（要么<code>//</code>,要么<code>/**/</code>.)<br>3.声明变量使用关键字。（<code>int cows, legs;</code>）<br>4.<code>printf()</code>字符串缺少了右边的引号。<br>5.<code>scanf()</code>少了取地址符<code>&amp;</code>，而且legs的输入形式写错了，为<code>&#39;%d&#39;</code><br>6.<code>printf()</code>格式化符为<code>%d</code>。</p>
<p>11.说说下面的转义序列代表啥意思？</p>
<ol>
<li><code>\n</code>,换行符，10.</li>
<li><code>\\</code>,相当于<code>\</code>.</li>
<li><code>\&quot;</code>,相当于<code>&quot;</code>.</li>
<li><code>\t</code>,相当于tab键。</li>
</ol>
<h1 id="编程训练"><a href="#编程训练" class="headerlink" title="编程训练"></a>编程训练</h1><p>1.通过实验方式，弄清你的电脑是如何处理整型上溢、浮点数上溢以及浮点下溢的，也就是写一个拥有数据溢出问题的程序。</p>
<p><img src="/img/overnunder.png"></p>
<p>这个肯定会溢出，可以修改程序看看会发生什么。<br>我观察到的是：整型溢出会直接跳到它的最小范围开始加<br>比如2146483650 &#x3D; - 2147483646 </p>
<p>浮点上溢，会失去精度，但是只要未超过位数仍然可以表示，如果把指数调到40就会出INF（infinity），具体可以看上文对于浮点溢出的讲解。。</p>
<p>浮点下溢，会直接被看成0。</p>
<p>2.写一个能够根据你输入的ASCII码值返回对应字符的程序。</p>
<p><img src="/img/ASCIIout.png"></p>
<p>包含了转义序列，使用了<code>switch</code>与<code>if</code>嵌套的结构。</p>
<p>3.写一个能够发出警报声，并且能够打印以下句子的程序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Startled by the sudden sound, Sally shouted, <span class="string">&quot;By the Great Pumpkin,</span></span><br><span class="line"><span class="string">what was that!&quot;</span></span><br></pre></td></tr></table></figure>

<p>重点有两个，一个是掌握好换行，可以用一个printf加上一个换行符实现，也可以用两个。<br>另一个是如何在字符串内输出”，这也是我们周赛第一道题的考点</p>
<p><img src="/img/alarming.png"></p>
<p>4.书写一个能够读入浮点数据，然后将它先以十进制小数的形式输出，再以指数形式输出。输出类似下方，但指数形式的实数部分是视系统而变的。</p>
<p><img src="/img/decimalandexp.png"></p>
<p>5.一年大概有3.156 * 10^7秒，写一个要求你输入以年计数的年龄并将它转化为秒数的程序。</p>
<p><img src="/img/lifesecond.png" alt="My life..."></p>
<p>6.一分子水大概是3.0 * 10^23克， 一夸脱水是950克。写一个要求你输入夸脱单位的水量，返回水的分子数的程序。</p>
<p><img src="/img/quartmol.png" alt="Too much..."></p>
<p>7.一英寸是2.54厘米， 写一个要求你输入英寸高度，返回厘米高度的程序。你要是想的话也可以反过来转换。</p>
<p>1.inch to cm<br><img src="/img/inchtocm.png"></p>
<p>2.cm to inch<br><img src="/img/cmtoinch.png"></p>
<pre><code>End...
</code></pre>
]]></content>
      <tags>
        <tag>C_premier_plus</tag>
      </tags>
  </entry>
  <entry>
    <title>C premier plus Chapter 2</title>
    <url>/2023/11/28/C-premier-plus-Chapter-2/</url>
    <content><![CDATA[<h1 id="第二章-C语言介绍"><a href="#第二章-C语言介绍" class="headerlink" title="第二章 C语言介绍"></a>第二章 C语言介绍</h1><blockquote>
<p><strong>你将会在这一章学到</strong><br>    1.赋值运算符<br>    2.函数main()与printf()<br>    3.一个简单C语言程序的构成<br>    4.创造整型变量，赋值并在屏幕上显示它们的值<br>    5.换行符<code>&#39;\n&#39;</code><br>    6.如何在程序中添加注释，让你的程序中同时拥有多个函数<br>        并能找出程序中的错误。<br>    7.关键字是什么</p>
</blockquote>
<p>C语言的程序是什么样子的？如果你大体浏览过这本书，你会看到很多的例子的。几乎一致的是，你会觉得C语言程序看起来很怪异，有些需要用到类似<code>&#123;，cp-&gt;tort,*ptr</code>这样的符号。随着你通读完这本书，你就会慢慢觉得这些符号不是那么陌生了，会变得更加熟悉，甚至有可能会很高兴遇见它们。在这一章中，我们从给出并解释一个简单的实例起步。同时，我们也会强调一些C语言的基本特征。</p>
<span id="more"></span>

<h1 id="2-1-一个简单的例子"><a href="#2-1-一个简单的例子" class="headerlink" title="2.1 一个简单的例子"></a>2.1 一个简单的例子</h1><p>让我们先研究一个简单的C语言程序。在图2.1展示的这个程序，专门为了突出一些C语言编程的特征。在你将要读接下来对于程序的逐行解释之前，先看看图2.1，试试你是不是能够靠自己搞明白它会做什么事情。<br><img src="/img/example.png" alt="小例子"></p>
<blockquote>
<p>1.#include &lt;stdio.h&gt; 包含头文件<br>2.int main(void) 定义一个返回值为整数，输入值为空的主函数<br>{<br>int num; 定义一个名为num的整型变量<br>num &#x3D; 1; 给num赋值1</p>
<pre><code>printf(&quot;I am a simple &quot;); 输出一行字
printf(&quot;computer. \n&quot;);
输出一个词，接在刚才的一句话之后，并换行
printf(&quot;My favorite number is %d because it is first.\n&quot;,num);
return 0; 返回值0，表示结束。
</code></pre>
<p>}</p>
<p>注释中的三个部分：1.定义变量 2.赋值 3.使用函数</p>
</blockquote>
<p>如果你认为这个函数将会在你的屏幕上打印一些东西。是的，你是对的。但对于明确的什么东西将会被打印到屏幕上可能并不明显，所以我们运行这个程序，看看会发生什么。</p>
<ul>
<li>第一步，使用你最喜欢的编辑器<br>  或者你的编译器中最喜欢的编辑器</li>
<li>第二步，创造一个包括了图2.1中文本的文件，<br>  并且以<code>.c</code>为结尾，从而满足你的系统对于文件名的需要。<br>  举个例子<code>first.c</code>就是合法的名称。</li>
<li>第三步，编译并运行程序。<br>  查看第一章来得知这方面的详细过程。</li>
</ul>
<p>如果一切都运转良好的话，你会在屏幕上看到这样的输出。<br><img src="/img/%E8%BE%93%E5%87%BA.png" alt="输出"></p>
<p>总之，这个结果并不是很惊人，但是<code>\n</code>与<code>%d</code>的作用是什么呢？<br>程序中有几行也看起来很陌生，这就到解释的时候了。</p>
<h1 id="2-2-解释这个例子"><a href="#2-2-解释这个例子" class="headerlink" title="2.2 解释这个例子"></a>2.2 解释这个例子</h1><p>我们会对这个例子解释两遍，第一遍（Pass1：速览大纲），强调了每一行的意义，从而你能够大体上得知发生了什么。第二遍（Pass2：程序细节），探索了特定部分的含义，并且给出了细节以便你能够更深刻地理解。</p>
<p>图2.1总结了C语言程序的每一个部分，<br>除了我们第一个例子使用的，它们还包含着更多要素与步骤。</p>
<h2 id="Pass1：速览大纲："><a href="#Pass1：速览大纲：" class="headerlink" title="Pass1：速览大纲："></a>Pass1：速览大纲：</h2><p>这一部分包括了对于程序每一行的简短解释。<br>下一部分会更加充分地探索这些主题的内容。</p>
<blockquote>
<p>#include &lt;stdio.h&gt; 包含另一个文件。</p>
</blockquote>
<p>这一行告诉编译器要从文件<code>stdio.h</code>中收集信息，这个文件是所有C语言编译器安装包的基础部分，提供了对于键盘输入与显示输出的支持。</p>
<blockquote>
<p>int main(void) 一个函数名</p>
</blockquote>
<p><img src="/img/analysis.png" alt="对C语言程序的分析"></p>
<p>C语言包括一个或者多个<em><strong>函数</strong></em>，它是C语言程序的基本模块。这个程序由一个叫做<code>main</code>的函数组成，圆括号表示了<code>main()</code>是个函数的名字。<code>int</code>表明了<code>main()</code>函数会返回一个整数，<code>void</code>表明<code>main()</code>不会获取任何的参数，这些都是我们过会会深入研究的事情。现在，接受<code>void</code>与<code>int</code>是在ISO&#x2F;ANSI标准下定义<code>main()</code>函数的方法（如果你有在ISO&#x2F;ANSI标准之前的编译器，省略<code>void</code>就好，但你可能也想获取更新的版本来避免不协调。）</p>
<blockquote>
<p>&#x2F;* a simple program*&#x2F; 一条注释。</p>
</blockquote>
<p><code>/*</code>与<code>*/</code>符号框定了一条能够帮助阐明一个程序的注释，它们是只为阅读者准备的，会被编译器忽略掉。</p>
<blockquote>
<p>{    函数体的开头</p>
</blockquote>
<p>起始大括号<code>&#123;</code>标志着函数中语句的开始，<br>函数的定义由终止大括号<code>&#125;</code>结束。</p>
<blockquote>
<p>int num; 一个声明语句</p>
</blockquote>
<p>这个语句声明了你正在使用一个叫做<code>num</code>的变量，而且<code>num</code>会是<code>int</code>（integer-十进制整数）类型。</p>
<blockquote>
<p>num &#x3D; 1; 一个赋值语句</p>
</blockquote>
<p>这个语句<code>num = 1</code>把值<code>1</code>赋给叫做<code>num</code>的变量。</p>
<blockquote>
<p>printf(“I am a simple “); 一个调用函数的语句</p>
</blockquote>
<p>第一句使用了<code>printf()</code>函数来在屏幕上显示<code>I am a simple </code>这句话，把光标留在了同一行。这里的<code>printf()</code>函数是标准C语言库的一部分。它被称作一个<em><strong>函数</strong></em>，而在程序中使用一个函数叫<em><strong>调用函数</strong></em>。</p>
<blockquote>
<p>printf(“computer.\n”);  另一个函数调用语句</p>
</blockquote>
<p>第二次调用<code>printf()</code>函数是在上一句打印下来的话后面添加了<code>computer</code>，<code>\n</code>符号是告诉电脑要另起一行-也就是说把光标移到下一行的起始。</p>
<blockquote>
<p>printf(“My favorite number is %d because it is first.\n”);</p>
</blockquote>
<p>最后一次使用<code>printf()</code>是基于引用的语句把<code>num</code>的数值(1)打印到屏幕上，<code>%d</code>指示电脑从哪里，以什么方式输出<code>num</code>的数值。</p>
<blockquote>
<p>return 0;</p>
</blockquote>
<p>一个C语言函数是可以提供，或者说***return(返回)***，一个数值</p>
<blockquote>
<p>} 结束。</p>
</blockquote>
<p>正像说过的，程序以终止大括号结束。</p>
<h2 id="Pass2：程序细节"><a href="#Pass2：程序细节" class="headerlink" title="Pass2：程序细节"></a>Pass2：程序细节</h2><p>既然你已经大体了解了图2.1中的内容，我们要更详尽地研究一下它了。再一次，我们将会逐行地查看程序，为了能够培养一种更宏观的C语言编程视角，这一句我们会以每一行代码作为起点，然后一步步深入代码之后的细节。</p>
<h3 id="include-指示与头文件"><a href="#include-指示与头文件" class="headerlink" title="# include 指示与头文件"></a># include <strong>指示与头文件</strong></h3><h4 id="include"><a href="#include" class="headerlink" title="# include &lt;stdio.h&gt;"></a># include &lt;stdio.h&gt;</h4><p>这是一个程序的开始行，**#include &lt;stdio.h&gt;** 的作用就和你把<code>stdio.h</code>中所有的内容都打字写在程序#include的位置是一样的。因此，这是一个剪切粘贴的操作，在共享对于很多程序都一样的信息上，<strong>include</strong>文件提供了一种便利的方式。</p>
<p><code>#include</code>语句是C语言<strong>预处理指令</strong>的一个范例。大体上，C语言编译器会在编译之前对于源码做一些准备工作，这在术语中称为<em><strong>预处理</strong></em></p>
<p>在大部分上，头文件包含着编译器制作最终的可执行文件需要使用的信息。例如，它们可能会定义一些常量或者声明一些函数的名字，与它们应该被怎样使用，但是库中函数真正的代码-编译前代码，不是在头文件中的。编译器的一部分-连接器会负责找到你需要的这一部分库代码。简单地说，头文件会帮助引导编译器来正确地把程序组装起来。</p>
<p>ISO&#x2F;ANSI标准下的C语言必须提供头文件，有些程序需要包含<code>stdio.h</code>头文件，有些不需要。对于C语言实例的记录应该包含使用的C语言标准库函数的描述，这些函数描述就确认了需要什么头文件。例如对于<code>printf()</code>的描述就表明了需要使用<code>stdio.h</code>，省略恰当的头文件可能并不会影响特定的程序，但是最好不要依赖它。这本书每一次使用库函数时，我们都会为函数使用<code>include</code>来把ISO&#x2F;ANSI标准制定的的文件包括在程序内。</p>
<p><img src="/img/original.png" alt="为什么输入输出不是内建函数？"></p>
<p>为什么输入输出并不是内建函数？<br>你有可能想知道为什么像输入输出这样基本的东西并不会被自动包含进程序中。一种回答是，并不是所有的程序都要使用I&#x2F;O（input&#x2F;output）包，而且C语言的哲学中也说到要避免承担不必要的重量。这个经济学上资源利用的准则让C语言受到嵌入式编程的欢迎-例如，为控制自动燃油系统编写代码。顺带一说，#include这一行甚至不是C语言的语句。#符号阐述了这一行是在编译器之前被预处理器处理的代码。你会在后面学习预处理指令时遇到很多例子，而且在第16章对这个主题还有更加充分的讲述。</p>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a><code>main</code>函数</h3><h4 id="int-main-void"><a href="#int-main-void" class="headerlink" title="int main(void)"></a>int main(void)</h4><p>程序的下一行声明了一个名字为<code>main</code>的函数，<code>main</code>是个挺普通的程序，但是它是唯一的选择。一个C语言程序（有些我们无需担心的例外），通常是以名叫<code>main</code>的函数开始运行的，其他函数的名字是可以随意选择的，但是作为一切的开端，<code>main</code>函数必须存在。那么圆括号呢？它们是为了确定<code>main()</code>是个函数，你会很快学习学到关于函数的更多内容。现在，记住这个函数是C语言程序的基础模块。</p>
<p><code>int</code>是<code>main()</code>函数的返回值类型，它意味着<code>main()</code>返回的数值种类必须是十进制整数(integer)。那么返回到哪里？返回到操作系统-我们会在第六章讨论循环的时候回到这个问题上来。</p>
<p>跟随在函数名后面的圆括号大体上囊括了需要传递给函数的信息，举个简单的例子，没有东西被传递，那么这个括号就包含着<code>void</code>-空类型（在第11章，“字符指针与字符串函数”介绍了第二种从操作系统把信息传递给<code>main()</code>函数的形式）</p>
<p>如果你查看过很久以前的C语言代码，你会经常看到程序是以下面的形式开始的:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">main()</span><br></pre></td></tr></table></figure>

<p>C90标准勉强地包容了这个形式，但是C99没有，所以即使你现在的编译器让你写成这个样子，不要听。</p>
<p>下面是另一种你可能会看见的形式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>有一些编译器是允许这样写的，但是没有一个标准把它列为一种选择，<br>因此，编译器也没有必要接受这个形式，有几种确实也没有。再一次，坚守标准的形式，你就不会在更换编译器的时候陷入困境。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*a simple program*/</span></span><br></pre></td></tr></table></figure>

<p>这一部分由&#x2F; *  * &#x2F;符号框定起来的内容就是注释，使用注释可以让一些人（包括你自己）更好地理解你的程序。C语言的一个很好的特点就是注释可以放在任何地方，甚至与它们解释的“原文内容”放在一行。长一点的知识可以放在一行甚至延伸至多行，以&#x2F; * 开始并以 * &#x2F;结束的内容都会被编译器忽略。下面是注释的合法与非法写法。</p>
<p><img src="/img/comment.png" alt="注释示例"></p>
<h1 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h1><blockquote>
<p>（1.这是一行C语言注释）<br>（2.这个注释延伸到了两行）<br>（3.你也可以这样做）<br>（4.但是这是不合法的因为没有结束符号）</p>
</blockquote>
<p>C99添加了注释的另一种形式，它在C++与Java中很受欢迎，这种新形式使用<code>//</code>符号来生成只在一行内的注释。</p>
<p><img src="/img/newform.png" alt="新形式"></p>
<p>因为一行的结束标志这这行注释的结束，这种方式需要在注释开始的时候添加注释符号。</p>
<p>新形式的出现是为了响应旧形式的潜在问题，假设你有下面的代码。</p>
<p><img src="/img/ihope.png" alt="我希望这可以运行..."></p>
<p>下一次，我推断你要删除第四行<br>然后意外地把第三行删掉了，<br>然后这代码就会变成这个样子</p>
<p><img src="/img/hopeagain.png" alt="哦不..."></p>
<p>现在编译器把第一行的起始符与第四行的结束符进行配对，结果使这四行全部成为了注释，包括那本应该是代码的一部分的一行。因为<code>//</code>并不会延伸到另一行，它不会引起代码的“消失”。</p>
<p>一些编译器有可能并不支持C99的这个特点，还有些有可能需要改变一些编译器的设置才能够应用C99的特性。</p>
<h3 id="大括号、函数体与代码块"><a href="#大括号、函数体与代码块" class="headerlink" title="大括号、函数体与代码块"></a>大括号、函数体与代码块</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在图2.1，大括号划定了<code>main()</code>的界限。大体上，所有的C语言函数都需要使用大括号来标志着函数体的起始与结束。它们是必须出现的，所以一定不要漏了。只有大括号是起这个作用的，不要使用圆括号或者中括号。</p>
<p>大括号还可以被用来把语句聚集在一个函数中，形成一个单元或者语句块。如果你对于Pascal，ADA，Modula-2或者Algol熟悉的话，你就会意识到大括号划定起始与结束在这些语言里也是相似的。</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br></pre></td></tr></table></figure>

<p>程序的这一行术语中称为<em><strong>声明语句</strong></em>，声明语句是C语言的其中一个最重要的特点。这个特例声明了两件事，一是在函数的某一个部分有一个叫<code>num</code>的变量（好好笑啊哈哈，在那遥远的函数中，有个小变量。）第二，<code>int</code>声明了<code>num</code>是一个十进制整数-也就是说，没有十进制小数点。（<code>int</code>是<em><strong>数据类型</strong></em>的一个例子），编译器使用这些信息为<code>num</code>变量准备合适的内存空间。结尾的分号标志了这一行是C语言的语句或者指令。分号也是这个语句的一部分，并不只是像在Pascal里的语句之间的分隔符。</p>
<p>C语言中，<code>int</code>是一个确定了一种数据类型的<em>关键字</em>，关键字是我们用来表达语言的单词，而且你不能把它们强占用于其他目的。例如，你不能把<code>int</code>作为函数或者是变量的名称。这些限制在语言之外就会失去作用，反而你把一只猫或者你最喜欢的孩子叫做<code>int</code>是没有问题的。（除非本地官员或者法律不准用这个名字）。</p>
<p><code>num</code>是<em>标识符</em>的一个例子，也就是你为变量、函数或者其他实型取的名字。从而声明把特定的标识符与电脑的特定的内存区联系在了一起，而且它也建立了信息的类型，或者说数据的类型，来放在那个区域里。</p>
<p>在C语言中，<em>所有的</em>变量都需要在被使用之前先<em>声明</em>，这也就意味着你必须对于所有在一个程序中使用的变量列出包括数据类型的声明。人们也认为声明变量是一个优秀的编程技巧，而且，在C语言中，它是必须进行的。</p>
<p>通常来说，C语言要求在代码块的起始部分声明变量，而且其他的语句是不允许放在这之前的。也就是说，<code>main()</code>函数的函数体会是这个样子。</p>
<p><img src="/img/tradition.png" alt="传统方式"></p>
<p>C99标准学习了C++的时间，现在可以让你在代码块的任何地方声明变量。然而，你还是需要在第一次使用变量之前声明它。所以如果你的编译器支持的话，你就可以像下面这样写：</p>
<p><img src="/img/C99.png" alt="C99新方式(1)"><br><img src="/img/C992.png" alt="C99新方式(2)"></p>
<p>为了能够和更旧的系统兼容，这本书还是会坚持原来的标准。（一些更新的编译器只有当你设置之后才会支持C99的特点）。</p>
<p>就此，你很可能有三个问题：</p>
<ul>
<li>1.数据类型是什么？</li>
<li>2.在取名的时候我们可以怎么选择？</li>
<li>3.为什么你需要把变量全部声明出来。<br>那就让我们探究这些问题的答案吧。</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>C语言主要处理的是这几种数据：十进制整数、字符、浮点数，仅举几例。声明一个整型或者字符类型变量可以使电脑恰当地储存、抓取与翻译数据。你会在下一章研究到更多可用的数据类型。</p>
<h3 id="名字的选择"><a href="#名字的选择" class="headerlink" title="名字的选择"></a>名字的选择</h3><p>你应该为变量使用有意义的名字（像是<code>sheep_count</code>而不是<code>x3</code>如果你的程序是数羊的），如果名字不能达到表意的需求，那么就使用注释来解释变量代表了什么。以这种方式为程序做记录是其中一种优秀的编程技巧。</p>
<p>你可以使用的字符要视实际情况而定。C99标准要求不多于63个字符，除非是外部的标识符。（在第12章“内存分级、链接性与储存管理”中会提到），相比于分别只能识别31个字符与6个字符的C90，这是一个巨大的提升，而且老的C语言编译器最多只能接受8个字符。事实上你可以使用更多的字符的，但是编译器会忽略它们。因此，当一个系统有着8个字符的限制时，<code>shakespeare</code>与<code>shakespencil</code>就会被认为是一样的了，因为它们的前八个字符是一样的。（如果你想要63个字符的例子，可以自己造一个）。</p>
<p>你可以在大写字母、小写字母与下划线之间任意选择。第一个字符必须是一个字母或者一个下划线。下面是一些示范。<br><img src="/img/valid.png" alt="示范"><br>操作系统与C语言标准库通常会使用1或2个下划线字符，比如<code>_kcab</code>，所以最好避免自己使用它。以一个或者两个下划线字符开始的，标准的标签，比如库中的标识符，会被<em><strong>储存</strong></em>起来，也就是说，即使使用它们作为名字并没有任何的语义错误，它是会造成一些名字冲突的。</p>
<p>C的标识符是<em><strong>区分大小写</strong></em>的，也就意味着大学字母是被看做与对应的小写字母字符不同的。因此，<code>stars</code>与<code>Stars</code>和<code>STARS</code>是不同的。</p>
<p>为了让C语言能够更加国际化，C99使用通用字符名称机制(UCN)进行了巨大的扩充，在附录B中的参考单元VII“更广大的字符支持”，我们讨论了这些加入的部分。</p>
<h3 id="声明变量的四个好处"><a href="#声明变量的四个好处" class="headerlink" title="声明变量的四个好处"></a>声明变量的四个好处</h3><p>一些年代更远的语言，比如FORTRAN与BASIC语言的原型版本，可以让你在没有声明的情况下使用变量。那么为什么我们不能在C语言中使用这种简单易行的方法呢？这里就是一些原因：</p>
<ul>
<li>把所有的变量放在一个地方能够让阅读者更容易地知道程序是关于什么的。这点好处在你给变量取有意义的名称的时候尤其明显，（就像<code>taxrate</code>与<code>r</code>），如果名字不能达意就使用注释来解释，以这种方式给程序做记录是一种良好的编程技巧。</li>
<li>通过思考声明变量是为了什么鼓励你全心投入地去写程序之前做一些准备。程序开始需要什么类型的信息？我到底想要程序输出什么？呈现数据的最好方式是什么？</li>
<li>声明变量有助于我们预防编程中更多难以发现又狡猾的错误之一-也就是拼错了变量的名字。举个例子，假设在一些没有声明的语言中，你写下了这个语句。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">radius1 = <span class="number">20.4</span>;</span><br></pre></td></tr></table></figure>

<p>然后在另一个地方，你拼错了变量名。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt; circum = <span class="number">6.28</span> * radiusl;</span><br></pre></td></tr></table></figure>

<p>你无意地把数字<code>1</code>换成了<code>l</code>，那种语言也会创造一个<code>radiusl</code>的变量，然后用未知的值（或许是0，或许是垃圾值），<code>circum</code>就会被给予一个错误的值，而且你可能需要极其多的时间来搞清楚为什么，这在C语言是不可能出现的（除非你确实是笨到家了去定义两个这样相似的变量名），因为编译器会在radiusl出现的时候报错。</p>
<ul>
<li>如果你不声明变量的话，你的C语言程序是不会进行编译的。如果先前的原因没有动摇你的话，对于这一点你可就得好好想想了。</li>
</ul>
<p>既然你需要声明需要使用的变量，它们会到哪里呢？就像上文提过的，C语言在C99之前就要求声明需要在代码块之前完成，遵循这种把声明放在一起的做法，你就可以更容易地得知程序正在做什么。当然，把你的声明分布在各个地方也是有好处的，正像现在C99所允许的。这也就是在你赋值之前先声明变量。那让你更难以忘记给他们赋值。作为关键性的事情，许多的编译器还不支持C99的这个规则。</p>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">num = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>下一行的程序是一个<em><strong>赋值语句</strong></em>，C语言中的其中一种基础运算。这个例子的意思是“把值<code>1</code>赋给变量<code>num</code>，之前的<code>int num</code>”这一行在电脑内存中为<code>num</code>分配了空间，这一行也就在这个空间中储存值。如果想要的的话你可以过会给<code>num</code>赋另一个值，那也就是<code>num</code>被叫做<em><strong>变量</strong></em>的原因。需要注意的是赋值语句会把值从右边到左边传递。<br>同时，这一句也是以分号结尾的，就像图2.2中显示的。<br><img src="/img/assignment.png" alt="赋值图示"></p>
<h2 id="printf-函数"><a href="#printf-函数" class="headerlink" title="printf()函数"></a><code>printf()</code>函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I am a simple &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;computer.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;My favorite number is %d because it is first.\n&quot;</span>,num);</span><br></pre></td></tr></table></figure>
<p>这些行使用了一个C标准库中叫<code>printf</code>的函数，圆括号表明了<code>printf</code>是一个函数的名字，在圆括号之中的内容就是<code>main()</code>函数向<code>printf()</code>函数传递的信息。例如，第一行就传递了这句话 <code>I am a simple</code>这样的信息叫做<em><strong>参数</strong></em>，或者更加充分地，叫做函数的<em><strong>实际参数</strong></em>（见图2.3），那么<code>printf()</code>函数会对对这种语句做些什么呢？它会抓取在双引号之间的一切，然后把文本打印在屏幕上。</p>
<p><img src="/img/calling.png" alt="函数调用"></p>
<p>第一行<code>printf()</code>是你调用函数的一个很好的例子，你只需要打字写下函数的名称，把需要的参数放在圆括号内。当程序运行到这一行时，控制流就转换到已经定义的函数（在这个例子中是<code>printf()</code>）中，然后当函数已经完成了它需要做的事情之后，控制流就又回到原来的（<em><strong>调用</strong></em>）函数-在这个例子中是<code>main()</code>。</p>
<p>下一行的<code>printf</code>呢？它在引号中包含了<code>\n</code>这个字符，而且它并没有被打印下来？发生了什么？<code>\n</code>的作用其实是另起一行，<code>\n</code>的组合体（打印下来是两个字符）就组成了<code>\n</code>这个叫<em><strong>换行符</strong></em>的新字符。对于<code>printf()</code>它意味着“在左下角再起一行”。也就是说，打印换行符和你在常规键盘上按下<code>enter</code>键的作用是差不多的。那么为什么不在打字写<code>printf</code>的时候用<code>Enter</code>键呢？那是因为因为那只会被认为是对于你的编译器的即时的指令，而不是对于源码的指令，也就是说，当你按下<code>enter</code>键时编辑器会退出当前的行，然后另起一行。换行符，影响着程序是如何显示的。</p>
<p>换行符是<em><strong>转义字符</strong></em>的范例，<em><strong>转义字符</strong></em>是用来呈现难以或者几乎不能通过打印显示出来的字符的。其他的还有<code>\t</code>对应着<code>Tab</code>、<code>\b</code>对应着<code>Backspace</code>，每一个转义字符都会由<code>\</code>来起始，我们会在第三章：C语言与数据再回到这个话题深入研究。</p>
<p>这也就解释了为什么三个<code>printf</code>却只有两行文字了，第一个<code>printf()</code>命令没有换行符，但是第二个与第三个是有的。</p>
<p>最后的<code>printf()</code>又带来了另外一个异样的地方：当这行文字被打印的时候<code>%d</code>发生了什么？你应该还记得，输出是这个样子的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">My favorite number is 1 because it is first.</span><br></pre></td></tr></table></figure>
<p>啊哈，当被打印出来的时候，数字<code>1</code>就是<code>%d</code>的替换物，而且变量<code>num</code>的值就是<code>1</code>，<code>%d</code>是展示<code>num</code>的值在什么时候被打印的占位符，这一行与下面的BASIC语句是相似的：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PRINT</span> <span class="string">&quot;My favorite number is &quot;</span>; num; because it is first.<span class="string">&quot;</span></span><br></pre></td></tr></table></figure>
<p>事实上，C语言的版本比这个做的工作还要多一点，<code>%</code>告诉程序有一个变量需要在这个区域被输出，<code>d</code>表达了要把这个变量以十进制整数的方式输出。<code>printf</code>还可以以其他变量形式进行输出，包括十六进制数、带有十进制小数点的数。事实上，<code>printf()</code>中的<code>f</code>表明了它是一个<em><strong>格式化</strong></em>打印函数。每种数据类型都有自己的指示符，这本书也会在介绍新的数据类型的同时引入对应的指示符。</p>
<h3 id="返回语句"><a href="#返回语句" class="headerlink" title="返回语句"></a>返回语句</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>返回语句是这个程序的最后一个语句，在<code>int main(void)</code>中的<code>int</code>意味着<code>main()</code>函数应该返回一个十进制整数。<code>main()</code>函数这样返回是C语言标准要求的。返回值的C语言函数都会使用return语句来进行这个操作，return语句包含着关键字<code>return</code>与返回的值，以一个分号结束。如果你遗漏了这一句，大多数编译器会报错，但是它们仍然会对程序进行编译。这样的话，你可以把return语句看成为了增加逻辑的连贯性的东西，但是它对于一些操作系统是由实际用处的，包括DOS和Unix，我们在第11章会更深入地对于这个话题给出解释。</p>
<h1 id="2-3-简单程序的结构"><a href="#2-3-简单程序的结构" class="headerlink" title="2.3 简单程序的结构"></a>2.3 简单程序的结构</h1><p>既然你已经看过了具体的例子，你已经准备好了解C语言程序的一些基本规则了。<em><strong>程序</strong></em>由包含一个函数或者多个函数的组组成，其中一个必须叫<code>main()</code>对于函数的描述包括函数头与函数体，<em><strong>函数头</strong></em>包括预处理语句，如<code>#include</code>，与函数的名字。你可以通过看圆括号的方式来得知这是个函数，即使圆括号可能是空的。<em><strong>函数体</strong></em>是由大括号框定的，它包括了一系列的语句，每一个都是由一个分号结尾的（见图2.4）。在例子中有<em><strong>声明语句</strong></em>，它是用来声明变量的类型与名字的，还有<em><strong>赋值语句</strong></em>，它给予变量一个值。然后还有三个<em><strong>print语句</strong></em>，每一个都调用了<code>printf()</code>函数，这些print语句是<em><strong>函数调用语句</strong></em>的一些示范。最后<code>main()</code>函数以返回值结束。</p>
<p>简单来说，一个简单的、标准的C语言程序应该使用下面的格式。<br><img src="/img/function1.png" alt="图2.4"><br><img src="/img/structure.png" alt="标准格式"></p>
<h1 id="2-4-可读性建议"><a href="#2-4-可读性建议" class="headerlink" title="2.4 可读性建议"></a>2.4 可读性建议</h1><p>使你的程序变得更可读是一种优秀的编程实践。可读性高的程序很容易理解，也就很容易去修改、纠正。让一个程序变得可读的过程也帮助你理清你对于程序执行自己的概念。</p>
<p>你已经看过两种可以增加可读性的技巧了：选择变量名与使用注释。注意这两种技巧是相互补充的。如果你给一个变量注名<code>width</code>，你就不需要对于这个变量表示什么做任何解释了。但是叫做<code>video_routine_4</code>的变量就需要对于video routine 4的解释。</p>
<p>另一个技巧是使用空行来分隔函数中的概念模块。例如，简单的实例程序就使用了空行分开了声明部分与行动部分。C语言不需要空行，但是它能够提高可读性。</p>
<p>第四个技巧就是每行使用一个语句。再一次，这是一个针对于可读性的惯例，并不是C语言的要求。C语言的格式是<em><strong>形式自由</strong></em>的，你可以把几句话放在一行或者一直延伸到第二行。下面的代码是合法的，但是看起来很丑。<br><img src="/img/poorreadability.png" alt="丑"><br>分号向编译器指示了一个语句什么时候结束和下一句什么时候开始。但是如果你能够遵从这种在本章的例子中使用的传统手法，程序的逻辑会清晰很多。（见图2.5）<br><img src="/img/readable.png" alt="可读性规范"></p>
<h1 id="2-5-更进一步"><a href="#2-5-更进一步" class="headerlink" title="2.5 更进一步"></a>2.5 更进一步</h1><p>我们的第一个C语言例子还是很简单的，接下来的图2.2就是第二个例子，但也并不是非常难。</p>
<p><img src="/img/example2.png" alt="例子"></p>
<p>新在哪里呢？代码中提供了对于程序的描述（在注释中），声明了很多变量，做了一些乘法运算，然后把这两个变量的值打印下来，让我们把这些点深入地了解一下。</p>
<h2 id="记录-Documentation"><a href="#记录-Documentation" class="headerlink" title="记录 Documentation"></a>记录 Documentation</h2><p>第一，程序是以注释开始的（使用的是新的注释形式），它确定了文件名与程序的目的。这种程序的记录只花费一分钟就可以做，而且之后会在你浏览多个文件并打印它们的时候起到很大帮助。</p>
<h2 id="多行声明-Multiple-Declarations"><a href="#多行声明-Multiple-Declarations" class="headerlink" title="多行声明 Multiple Declarations"></a>多行声明 Multiple Declarations</h2><p>然后，程序在一行中声明了两个而不是一个变量。为了达成这个目的，可以把两个变量（<code>feet</code>与<code>fathoms</code>）的声明使用一个逗号隔开，也就是下面这样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> feet, fathoms;</span><br></pre></td></tr></table></figure>

<p>它和下面的形式是等价的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> feet;</span><br><span class="line"><span class="type">int</span> fathoms;</span><br></pre></td></tr></table></figure>

<h2 id="运算-Multiplication"><a href="#运算-Multiplication" class="headerlink" title="运算 Multiplication"></a>运算 Multiplication</h2><p>第三步，程序进行运算，它利用了计算机系统庞大的算力来计算2乘6。<br>在C语言中，同样也在很多语言中，<code>*</code>是乘法运算的符号。<br>因此，下面的语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">feet = <span class="number">6</span> * fathoms;</span><br></pre></td></tr></table></figure>

<p>它的意思就是：查看<code>fathoms</code>的值，乘以6，然后把这个运算的结果的值赋给变量<code>feet</code>。</p>
<h2 id="打印多个值-Printing-Multiple-Values"><a href="#打印多个值-Printing-Multiple-Values" class="headerlink" title="打印多个值 Printing Multiple Values"></a>打印多个值 Printing Multiple Values</h2><p>最终，程序更多样地使用了<code>printf()</code>如果你编译运行过这个例子，输出应该是这个样子的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">There are 12 feet <span class="keyword">in</span> 2 fathoms！</span><br><span class="line">Yes, I said 12 feet!</span><br></pre></td></tr></table></figure>

<p>这一次，代码在第一次使用<code>printf()</code>的时候，使用了两次替代符，在双引号中的第一个<code>%d</code>被在后面引用列表的第一个变量的值替换了(<code>feet</code>)然后第二个<code>%d</code>被第二个变量代替了。要注意的是待打印变量列表是在双引号部分后面，另外也注意每一个都是用括号分开的。</p>
<p>第二次使用<code>printf()</code>表明了打印的值并不一定是变量的，只是必须要指定一个值，就像<code>6 * fathoms</code>这样，可以是恰当类型的值。</p>
<p>这个程序受篇幅不长，但是它可以呈现把fathoms转换到feet的核心。我们需要的就是动态地去赋其他的值给<code>feet</code>我们会在以后的章节解释如何做。</p>
<h1 id="2-6-顺便一提：多重函数"><a href="#2-6-顺便一提：多重函数" class="headerlink" title="2.6 顺便一提：多重函数"></a>2.6 顺便一提：多重函数</h1><p>目前为止，这些程序已经使用过了基本的<code>printf()</code>函数。图2.3向你展示了如何把自己的函数-除了<code>main()</code>以外的函数-加到程序里。</p>
<p><img src="/img/twofunc.png" alt="两个函数的程序"></p>
<p>输出是这个样子的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">I will summon the butler <span class="keyword">function</span>.</span><br><span class="line">You rang, sir?</span><br><span class="line">Yes,Bring me some tea and writeable CD-ROMS.</span><br></pre></td></tr></table></figure>

<p><code>butler()</code>函数在程序中出现了三次，第一次出现是在<em><strong>原型</strong></em>中，那告诉了编译器要使用的函数。第二次出现是在<code>main()</code>函数中，在<em><strong>函数调用</strong></em>中出现，最终，程序呈现了<em><strong>函数的定义</strong></em>过程，那是函数本身的源码。让我们再来看看这三次出现。</p>
<p>C90标准添加了原型，老翻译器可能并不能识别它们（我们将会讲到当你使用那种编译器的时候要怎么做。）原型就是一种告诉编译器你正在使用一个特定的函数的声明。它也指定了函数的属性。例如，<code>butler()</code>函数的第一个词<code>void</code>指明了它没有返回值。（大体上，函数可以为了使用值而返回这些值，但<code>butler</code>没有），第二个<code>void</code>-在<code>butler(void)</code>-的意思是它没有参数。因此，当编译到达<code>main()</code>函数中<code>butler</code>被使用的这一行时，它会检查是否<code>butler</code>是被恰当地使用的。需要注意，<code>void</code>是被用来表示empty（空），而不是invalid（不合法、无效）。</p>
<p>早先的C语言支持的函数声明类型有限，那时你只能定下返回值的类型，但是对于参数的描述就被省略。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">butler</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>那时的C语言代码使用的函数声明就像是上述的样子，而不是函数原型，C90与C99标准都能够辨认出这种更老的形式，但是它们表示这种形式会随着时间被淘汰，所以不要用。如果你从一些更老的地方拿到了C语言代码，你有可能想要把老式的声明变成原型。以后的章节会回到原型制作、函数声明与返回值上。</p>
<p>接下来，你通过给出<code>butler</code>的名字与圆括号来援引函数。（调用），当<code>butler</code>完成了它的工作，程序就会移向<code>main()</code>函数中的下一行。</p>
<p>最终，函数<code>butler()</code>以与<code>main()</code>函数一样的形式被定义，有函数头与用大括号框定的函数体。函数头重复了你在原型中提供的信息：<code>butler</code>不使用信息，而且不返回值。对于老旧的编译器，省略第二个<code>void</code>。</p>
<p>有一点需要注意的，就是在<code>main()</code>函数中<code>butler()</code>被调用的位置-而不是<code>butler()</code>函数被定义的位置-决定了<code>butler()</code>函数的运行位置。比如，你可以把<code>butler()</code>函数的定义放在<code>main()</code>函数的前面，程序还是会照旧那样把<code>butler()</code>放在两个<code>printf()</code>中间运行。记住，所有的C语言程序都是以<code>main()</code>函数开始的，无论<code>main()</code>函数在程序文件的什么位置。然而，C语言实际上是先把<code>main()</code>函数列出来，因为它通常提供了基本的程序框架。</p>
<p>C语言标准建议你为所有你使用的函数提供原型，标准的<code>include</code>文件为标准库函数做这个工作，例如，在标准C语言下，<code>stdio.h</code>文件就有<code>printf()</code>函数的原型，第六章的最后一个例子会告诉你如何去更广泛地为非<code>void</code>的函数制作原型，第九章会全面地讲述函数。</p>
<h1 id="2-7-调试引入"><a href="#2-7-调试引入" class="headerlink" title="2.7 调试引入"></a>2.7 调试引入</h1><p>现在你已经可以写一个简单的C语言程序了，你有可能海域犯些简单的错误。程序的错误通常被叫做<em><strong>bugs</strong></em>，寻找与修复它们就叫做<em><strong>调试</strong></em>，图2.4就展现了有些bugs的程序，看看你是否能够找到。</p>
<p><img src="/img/nogood.png" alt="找找吧，有几处？"></p>
<h2 id="语法错误-Syntax-Errors"><a href="#语法错误-Syntax-Errors" class="headerlink" title="语法错误 Syntax Errors"></a>语法错误 Syntax Errors</h2><p>图2.4的例子犯了几个语法错误，当你没有遵循C语言的规则，你就会犯<em><strong>语法错误</strong></em>，这也可以类比到英语的语法错误。例如，思考一下这句话：<em><strong>Bugs frustrate be can.</strong></em> 这句话使用的单词是正确的，但是并没有遵循单词顺序的规律，而且使用的单词形式也不太对，不管怎样，C语言的语法错误就是在错误的地方使用了正确的C语言标志。</p>
<p>所以<code>nogood.c</code>这个程序究竟犯了什么错误呢？第一，它使用的是括号而不是大括号来标记函数体，也是把正确的C语言符号用在了错误的地方，第二，声明应该是这个样子的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n, n2, n3;</span><br></pre></td></tr></table></figure>

<p>或者这样</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> n2;</span><br><span class="line"><span class="type">int</span> n3;</span><br></pre></td></tr></table></figure>

<p>而且，这个例子遗漏了安置一条注释必须要使用的<code>*/</code>符号对（作为替换，你可以用<code>//</code>形式替换<code>/*</code>），最后，它遗漏了<code>printf()</code>后的本应作为语句结束标志的分号。</p>
<p>你如何来检查语法错误呢？第一，在编译之前，浏览你的源码，看你是否看到一些明显的错误。第二，你可以检查编译器找到的错误，因为它的一部分工作就是检查语义错误。当你编译程序的时候，编译器会反馈找到的所有错误，并且会明确错误类型与出错的位置。</p>
<p>然而，编译器有时也会混乱，实际上的一个区域内的语义错误有可能会让编译器错误地认为它找到了其他种类的错误。例如，因为这个例子没有恰当地声明<code>n2</code>与<code>n3</code>，所以编译器会认为它在被使用的地方找到了错误。事实上，与其试图一次把所有报告的错误修正过来，不如只修改一两个然后重新编译，这样的话有些其他种类的错误就会消失。继续这样做，直到程序正常运行。另一个常见的编译器“诡计”是它会在后面的行报错，但其实出错是在前面的行里。例如，编译器有可能直到下一行才能判断出上一行遗漏了分号。所以如果编译器报错说缺少分号，那么在这一行之前进行检查。</p>
<h2 id="语义错误-Semantic-Errors"><a href="#语义错误-Semantic-Errors" class="headerlink" title="语义错误 Semantic Errors"></a>语义错误 Semantic Errors</h2><p>语义错误是在意义上的错误，例如，思考这一句话: <em><strong>Furry inflation thinks greenly.</strong></em>  语法上是正确的，因为形容词、名词、动词、还有副词都在合适的位置上，但这句话就是一派胡言。在C语言中，当你遵循了C语言的规则但是导致了不合适的结果，这个例子中就有这样的错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n3 = n2 * n2;</span><br></pre></td></tr></table></figure>

<p>n3本应该是用来展现<code>n</code>的3次方的，结果程序把它算成了<code>n</code>的4次方。编译器是检测不出来语义错误的，因为它们并不违背C语言的规则。编译器没有能力去猜测你程序的意图。那也就只能由你来找到这些种类的错误了。一种方式是把程序做的事情与程序应该做的事情进行对比。例如，假定你已经找到了例子中的语法错误，那么它现在看起来是这个图2.5样子的。</p>
<p><img src="/img/stillbad.png" alt="还是错的..."></p>
<p>它的输出是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">n = 5, n squared = 25, n cubed = 625 </span><br></pre></td></tr></table></figure>

<p>如果你可以口算立方的话，那么你就会注意到625是个错误的值。下一阶段就是找到你是如何陷入这个错误的。例如，你有可能会通过观察找到错误。大体上，然而你还需要一些系统的方法。一种方法是假装你是电脑，然后一步步地跟着程序走，让我们现在就尝试一下那个方法。</p>
<p>程序体以声明三个变量<code>n1, n2与n3</code>开始，你可以通过画三个盒子并把它们各自标注名称来模拟这个情况。（看图2.6）然后，程序会把5赋给<code>n</code>，通过把数字5写在盒子里来模拟，然后，程序用<code>n</code>乘<code>n</code>然后把它的值赋给<code>n2</code>，所以看向盒子<code>n</code>，看着5乘5得到了25，然后把25放在盒子里。为了模拟下一句，也是同样，看向盒子2，然后用25乘25，然后把这个值给予<code>n3</code>，啊哈，你做乘法的时候使用的是<code>n</code>的平方而不是用<code>n</code>。</p>
<p>嗯，有可能这个过程对于这个程序有点过了，但是以这种方式一步步地浏览程序总会是得知发生了什么最好的方法。</p>
<h2 id="程序状态"><a href="#程序状态" class="headerlink" title="程序状态"></a>程序状态</h2><p>通过手工地一步步地追踪程序，追踪每一个变量，你监视了程序的状态，<strong>程序状态</strong>就是所有变量在一个时间点上被给予的一组值。它是运算状态的快照。</p>
<p><img src="/img/tracer.png" alt="追踪程序状态"></p>
<p>我们刚刚讨论了一种追踪程序状态的方法：通过自己一步一步地运行程序。在一个进行1000次迭代的程序中，你可能觉得并不能完成那个工作。然而，你还是可以经历一些迭代过程，看看你的程序是不是按你想要的方式来运行的。然而，通常是会有这种情况的，你会按照你想要的方式去“执行”它们，而不是真正把它们写下来，所以在写真正的代码的时候要努力做到正确。</p>
<p>另一个方法就是通过在程序的自始至终放置几个<code>printf</code>语句来定位语义问题。在程序运行的关键点监测选定变量的数值。看看数值是怎么变化的可以让你知道正在发生什么。在你让程序按照你满意的方式运行之后，你就可以去掉多余的语句去重新编译了。</p>
<p>第三种监测的方法就是使用调试器。<em><strong>Debugger</strong></em>是一种能够让你一步一步地运行程序并且查看程序变量的值的程序。它们使用的难易程度与复杂度都各有不同。更高级的编译器可以显示哪一行代码正在被运行。这对于多路径的程序是非常方便的，因为可以很容易地看到走的是哪一条路径。如果你的编译器中有调试器，那么花谢时间学学则呢么使用吧。比如像图2.4那样尝试使用它。</p>
<h1 id="2-8-关键字与内置标识符"><a href="#2-8-关键字与内置标识符" class="headerlink" title="2.8 关键字与内置标识符"></a>2.8 关键字与内置标识符</h1><p>关键字就是C语言中的词汇，因为它们对于C语言是特别的，所以你不能把它们作为标识符来使用。有一些关键字分别了多种多样的类型，比如说<code>int</code>，其他的比如说<code>if</code>是被用来控制程序运行语句的顺序的。在以下的C语言关键字的列表中，黑体表示在ISO&#x2F;ANSI C90标准下的关键字，斜体的是C99标准加入的新关键字</p>
<p><img src="/img/keywords.png" alt="关键字"></p>
<p>如果你尝试把关键字用于变量的名字，编译器会把它识别为语法错误，还有其他的标识符，它们叫做<em><strong>内建标识符</strong></em>，你也是不应该使用的，他们不会导致语法错误，因为它们是合法的名称，但是语言已经使用过或者还保留着使用它们的权利，所以如果你使用这些标识符来表示其他的东西会引起问题。内置的标识符包括以下划线开始的词还有库函数的名称，就像<code>printf()</code>.</p>
<h1 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h1><p>电脑编程是一项有挑战性的活动，它需要复杂与概念化的思考，而且还需要对于细节格外注意。你会发现编译器会强制你去注意细节。当你对朋友说话的时候，你可能会把几个词用错，犯几个语法错误，可能话没有说完，但是你的朋友仍然能够理解你在说什么。但是编译器不会允许这种情况。对于编译器来说，几乎对了也是错的。</p>
<p>编译器并不能在概念问题帮到你多少，比如在这里说的这些东西。所以这本书会尽力通过给出每一章关键概念的大纲来弥合那个差距。</p>
<p>对这一章，你的目标是你需要理解C语言程序是什么，你可以认为程序就是你对于想让电脑干什么的描述。编译器精细化地解决把你的描述变为含蓄的机器语言。（对于编译器做多少工作的测量显示，它可以从你1KB的源码文件创造出来60KB的可执行程序）即使一个简单的C语言程序也需要很多的机器语言来代表它们。）因为编译器并没有智能，你必须使用编译器的词汇来描述你的意思，而且这些词汇是由C语言标准设立的正规规则。（即使很受限制，还是比直接用机器语言来表达强的多了！）</p>
<p>编译器期望着收到以独特的形式写出的指令，这一章已经详细地描述了。你作为编程人员的工作就是表达在编译器框架下你对于程序应该如何运作的想法-由C语言标准所引导就可以正确地运行。</p>
<h1 id="回顾问题"><a href="#回顾问题" class="headerlink" title="回顾问题"></a>回顾问题</h1><ol start="4">
<li>Indiana Sloth准备了如下的程序，让你看一看是不是正确，请帮帮他吧。</li>
</ol>
<p><img src="/img/quest4.png" alt="问题4"></p>
<p>main函数用了{}来括起来，函数体用的是括号，是错的。<br>声明语句没加分号，赋值只需要一个&#x3D;号即可。<br>是printf而不是print。没加双引号，没加引用列表。最后没结束。stdio.h打错了而且#和&lt;&gt;，注释另一边写反了，导致全文为注释。</p>
<p>5.假设下面的每一个例子都是完整程序的一部分，它们每一个会打印什么呢?</p>
<p><img src="/img/quest5.png" alt="问题5"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#a.</span></span><br><span class="line">Baa Baa Black Sheep.Have you any wool?</span><br><span class="line"></span><br><span class="line"><span class="comment">#b.</span></span><br><span class="line">Begone!</span><br><span class="line">creature of lard!</span><br><span class="line"><span class="comment">#c.</span></span><br><span class="line">What?</span><br><span class="line">No/nBonzo?</span><br><span class="line"></span><br><span class="line"><span class="comment">#d.</span></span><br><span class="line">2 + 2 = 4</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>下面哪些是C语言关键字？ <code>main, int, function, char, =</code><br>int、char</p>
</li>
<li><p>你会如何把<strong>行数</strong>与<strong>字数</strong>打印出来？<br>在以下的形式中<code>There were 3020 words and 350 lines.</code></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">word = <span class="number">3020</span>;</span><br><span class="line">line = <span class="number">350</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;There were %d words and %d lines.&quot;</span>, word, line);</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>思考下面的程序<br><img src="/img/quest8.png" alt="问题8"><br>在第7行之后的程序状态是什么？<br>第八与第九行呢？</li>
</ol>
<blockquote>
<p>第7行 a &#x3D; 5，b &#x3D; 2</p>
</blockquote>
<blockquote>
<p>第8行 a &#x3D; 5， b &#x3D; 5</p>
</blockquote>
<blockquote>
<p>第9行 a &#x3D; 5， b &#x3D; 5</p>
</blockquote>
<h1 id="编程训练"><a href="#编程训练" class="headerlink" title="编程训练"></a>编程训练</h1><p>只是阅读是不够的，你得尝试写一两个简单的程序来看看是不是写程序和你看这一章的感觉一样流畅。下面有一些建议，但是你也确实需要独立思考一些问题。你会在网站上找到下面选出问题的答案。</p>
<ol>
<li>调用一次printf，把你的姓与名在一行中输出<br> 再调用一次printf，把你的姓与名在两行中输出。<br> 使用两次printf把你的姓和名在一行中输出。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简略一写</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Mike Smith\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Mike\nSmith\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Mike&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Smith\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>写一个打印你的姓名与地址的程序</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;My name is Ywx\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Address: Zhengzhou city in Henan province&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>写一个把你的年龄转换成天数的程序，展示两者的值。不必关心闰年和平年。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> age, days;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line">	days = age * <span class="number">365</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, age, days);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.写一个会打印出以下语句的程序</p>
<p><img src="/img/four.png" alt="语句"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;For he&#x27;s a jolly good fellow!\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Which nobody can deny!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.写一个程序，创建一个叫做<code>toes</code>的变量，把<code>toes</code>设为10，<br>计算toes的二倍和平方分别是什么，并把它们打印下来</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	toes = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>, toes, toes * <span class="number">2</span>, toes * toes);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.写一个会打印出如下的输出的程序</p>
<p><img src="/img/six.png" alt="Smile!"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i &gt;= <span class="number">1</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; i;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Smile&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.写一个叫做<code>one_three()</code>的函数，这个函数应该在一行内展现文字<code>one</code>然后调用函数<code>two()</code>，接着在另一行内显示文字<code>three</code>。<br><code>two()</code>把文字<code>two</code>在一行输出。以Stating now开始，像这样。</p>
<p><img src="/img/last.png" alt="数数"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">two</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;two\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">one_three</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;one\n&quot;</span>);</span><br><span class="line">	two();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;three\n&quot;</span>)l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;starting now:\n&quot;</span>);</span><br><span class="line">	one_three();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>End…</p>
</blockquote>
]]></content>
      <tags>
        <tag>C_premier_plus</tag>
      </tags>
  </entry>
  <entry>
    <title>C premier plus Chapter 1</title>
    <url>/2023/11/27/C-premier-plus-Chapter-1/</url>
    <content><![CDATA[<h1 id="第一章-学习准备"><a href="#第一章-学习准备" class="headerlink" title="第一章 学习准备"></a>第一章 学习准备</h1><blockquote>
<p><strong>你将会在这一章学到：</strong><br>    1. C的历史以及特点<br>    2. 写程序的步骤<br>    3. 关于代码连接器与编译器的一些知识<br>    4. C标准</p>
</blockquote>
<p>欢迎来到C语言的世界！C语言是一种充满活力的高级编程语言，它受到业余与商用编程者的喜爱。<br>这一章会为你学习与利用这种强大而又受欢迎的语言，而且会向你介绍几种你最有可能搭建C语言基础的环境。</p>
<p>首先，我们看向C语言的来源和它的一些特点（优点以及缺点）。接着，我们会了解编程的起源，查看编程的总体规则。<br>最终，我们会讨论如何在常见的系统中运行C程序。</p>
<span id="more"></span>

<h1 id="1-1-C语言的由来"><a href="#1-1-C语言的由来" class="headerlink" title="1.1 C语言的由来"></a>1.1 C语言的由来</h1><p>贝尔实验室的Dennis Richie在1972年创造了C语言，也就在那时，他和Ken Thompson正在致力于设计Unix系统。C语言的想法并不完全是在Richie的脑袋里冒出来的，而是来自Thompson的B语言，B语言来自哪里又是另一个故事了。重点是，C语言是作为工作中的编程人员的工具被创造出来的，所以它的首要目标就是成为一种有用易用的语言。</p>
<p>很多编程语言都有着类似的目标，但是它们又经常会有其他的顾虑，举几个例子，Pascal语言的主要目标，就是为了教授编程规则提供良好的平台。BASIC语言，被设计得与英语很相像，从而可以方便地让不熟悉电脑的学生们学习。这些目标都是很重要的，但是并不与实际使用协调，也并不是普遍都很易用。相比之下，C语言是为了编程人员而生的，而且成功地成为了现代编程语言的一种选择。</p>
<h1 id="1-2-为什么使用C语言？"><a href="#1-2-为什么使用C语言？" class="headerlink" title="1.2 为什么使用C语言？"></a>1.2 为什么使用C语言？</h1><p>在过去的30年来，C语言已经成为了最重要与最受欢迎的编程语言。它的成长，就是因为人们经过尝试之后，喜欢使用它。过去的10年里，许多人从C语言转到的更有规模的C++上，但C语言仍然是拥有权重的一种很重要的语言，C++也是从C语言迁移过来的。在学习C语言的过程中，你会意识到C语言的许多长处（见图1.1）让我们预先查看一下。<br><img src="/img/Chapter1.2.png" alt="插图"><br>（上图，左上为强大的控制结构，右上运行速度快，左下小型代码-小程序，右下是可以传输到不同的电脑）</p>
<h2 id="1-2-1设计特点"><a href="#1-2-1设计特点" class="headerlink" title="1.2.1设计特点"></a>1.2.1设计特点</h2><p>C语言是一种拥有在理论界以及计算机科学实践中令人满意的控制特色的现代编程语言。它的设计让它很自然地能自上而下地规划程序、结构化编程以及模块化设计，从而设计出的程序也更可靠，更易懂。</p>
<h2 id="1-2-2-效率"><a href="#1-2-2-效率" class="headerlink" title="1.2.2 效率"></a>1.2.2 效率</h2><p>C语言是一种高效的编程语言，它的设计很好地利用了现代电脑的性能。C语言编写的程序常常是小型的，并且运行速度很快。事实上，C表现了一些在汇编语言中好的控制方法，（汇编语言是对于特定的中央处理单元(Central Processing Unit,CPU)的内部指令设计的的助记语句，不同的CPU有着不同的汇编语言）。如果你选择C语言，你可以调节你的程序到达最快速度或者让程序对于内存的使用更有效。</p>
<h2 id="1-2-3-可传递性"><a href="#1-2-3-可传递性" class="headerlink" title="1.2.3 可传递性"></a>1.2.3 可传递性</h2><p>C语言是一种可传递的编程语言，那意味着在一个系统上的C语言程序也可以在其他系统经过少量的改动或者不改动运行。即使改动是必须的，也只是改动头文件与main程序里的几个词条而已。大多数也打算着有可传递性，但是任何想要把个人电脑IBM里的BASIC程序放到苹果BASIC（它们是近亲）或者尝试把主机上的IBM里的FORTRAN程序在Unix系统中运行都知道传递烦人透顶。C语言是可传递性的领头者。C语言的编译器（把你的C语言代码转换为电脑内部指令的程序）对于40种系统都是可以使用的。从微型处理器到超算。但需要注意的是，一部分程序对于不同的硬件设备是不一样的，比如显示器监控，或者因为在运算系统上的特殊点，比如WinXP与OS X，它们通常是不具有传递性的。</p>
<p>因为C语言与Unix操作系统关系紧密，Unix系统的安装包是自带C语言的编译器的，Linux安装时也通常带有C语言编译器，一些C语言编译器是可以在个人电脑上使用的，包括运行着各种版本的Windows系统的电脑，还有Mac。所以不论你是正在使用着家里的电脑，还是使用专业的工作站或者大型电脑，你都是有很大可能获得一个适用于你的系统的C语言编译器的。</p>
<h2 id="1-2-4能力与灵活性"><a href="#1-2-4能力与灵活性" class="headerlink" title="1.2.4能力与灵活性"></a>1.2.4能力与灵活性</h2><p>C语言既强大又灵活（在计算机文献中最受喜欢的两个词）。<br>举个例子，许多功能强大与灵活的操作系统是用C语言写的。许多的其他编程语言（如FORTRAN、Perl、Python、Pascal、LISP、Logo与BASIC）的编译器与翻译器是用C语言写的。结果，当你在Unix机上使用FORTRAN语言，最后是用C语言程序生成的exe文件。C语言程序被用作解决物理、工程问题甚至在电影如《角斗士》中栩栩如生地重现特殊的现象。</p>
<h2 id="1-2-5-以程序员为方向的"><a href="#1-2-5-以程序员为方向的" class="headerlink" title="1.2.5 以程序员为方向的"></a>1.2.5 以程序员为方向的</h2><p>C语言重视于满足程序员的需求，让我们轻松地触达硬件，而且让你独立地操纵内存中的每一个bit。它拥有非常多的运算符，能够让你简洁地表达自己。C语言比起，比如说Pascal语言就在限制着你可以做的事情。这种灵活性既是优势也很危险。优势在许多的任务，像是数据形式转换，在C语言中简单很多。危险就是用C语言，你有可能犯在其他语言中不可能犯的错误。C语言给予了你更大的自由，也让你承担了更多的责任。</p>
<p>另外，大多数C语言的实施都有着大量有用的C语言库函数。这些函数能够应对很多编程人员通常的需求。</p>
<h2 id="1-2-6-缺点"><a href="#1-2-6-缺点" class="headerlink" title="1.2.6 缺点"></a>1.2.6 缺点</h2><p>C确实有一些不足之处。通常，像人一样，不足与长处是同一个特点的两面。例如，我们提到了C语言的自由表达也需要更多的责任。C语言的指针（我们以后会学习到）使用特别地，意味着编程错误会更难跟踪到。曾经也提到了一台没有文字的电脑，解放的代价就是格外的警惕，</p>
<p>有着大量的运算符，C的简明也让有可能让我们写出极其难以理解的代码。你可能并不是必须要写晦涩的代码，但是可能性总在那儿。毕竟，其他语言哪个有每年一次的混乱的编程比赛？</p>
<p>还会有更多的长处，毫无疑问也会有更多的缺陷。与其在这个问题上挖的更深，还不如移到下一个话题。</p>
<h1 id="1-3-C语言的用处"><a href="#1-3-C语言的用处" class="headerlink" title="1.3 C语言的用处"></a>1.3 C语言的用处</h1><p>到 1980 年代初，C 语言已经是 Unix 系统小型计算机世界的主导语言了。从那时起，它就已经被传播到个人计算机（微型计算机）和大型主机（大型计算机）了。（参见图 1.2）许多软件公司把C语言作为制作文字处理程序、电子表格、编译器和其他产品的首选语言。它们知道C语言编写的程序代码量小而且高效。更重要的是，他们知道这些程序将易于修改，并易于适应新型号的计算机。<br><img src="/img/Chapter1.3.png" alt="图片"><br>（以上，C语言被用作编程Unix操作系统，被用作电影如Star wars，在电脑游戏、电脑语言处理、嵌入式系统与机器人工程中都有显著的作用）</p>
<p>C语言不仅对公司和老手有好处，对其他用户也有好处。越来越多的计算机用户已经开始使用 C 语言，它的优势也得到了确保。你不必是专业的计算机编程人员就可以使用C语言了。<br>在 1990 年代，许多软件公司开始转向 C++ 语言进行大型编程项目。C++ 将面向对象的编程工具嫁接到 C 语言中。（面向对象编程是一种思想体系，它试图使语言来适应问题，而不是让问题来适应语言。）C++ 几乎是 C 语言的超集，这意味着任何 C程序也是，或者它几乎也是一个有效的C++程序。通过学习 C语言，您还学习了许多 C++。<br>尽管 C++ 和 Java 等新型的编程语言很受欢迎，但 C语言在软件公司依然是核心技能，一直排在所需技能的前 10 名。特别的，C语言已成为在嵌入式系统编程中很受欢迎的一种语言，也就是说，它被用于编程越来越多的汽车、相机、DVD 播放器和其它现代便利设施中的常见的微型处理器。此外，C语言已经开始追赶在科技科学编程上具有长久的主导地位的FORTRAN语言。最后，作为为开发操作系统而生的语言，C语言在Linux系统的发展中发挥着重要作用。所以，在二十一世纪的第一个十年， C 语言的影响力仍然在变得更大。</p>
<p>简而言之，C 是最重要的编程语言之一，并将继续如此。如果你想要一份编程软件的工作，这应该是你能够回答“是”的第一个问题中的一个，“嗯，比如说，你会C语言吗？“</p>
<h1 id="1-4-计算机的作用"><a href="#1-4-计算机的作用" class="headerlink" title="1.4 计算机的作用"></a>1.4 计算机的作用</h1><p>既然你已经要开始学习如何运行C语言程序了，你很可能需要了解一下电脑是怎么工作的，这些知识能够帮助你了解C语言程序与最终运行程序后发生的事情之间的关联。</p>
<p>现代的电脑有几个组成部分，<em><strong>中央处理器</strong></em>，又叫<em><strong>CPU</strong></em>，做了电脑运转时的大部分工作。<em><strong>随机存取器</strong></em>，又叫<em><strong>RAM</strong></em>，作为保存文件与程序的工作区。永久存储器，比如硬盘，存储程序和文件，即使电脑已经关机。各种外设，比如键盘、鼠标还有显示器，在你与电脑交互中搭建了桥梁。CPU运行程序，所以我们集中于它的作用。</p>
<p>CPU的自始至终的工作，简单来说，其实是非常简单的。它从内存中依次抓取一条条的指令，然后执行它。（千兆赫CPU可以在一秒钟执行这个过程百亿次，所以CPU可以以一种惊人的速度运作），CPU也有自己的小工作区，有几个储存数的<em><strong>寄存器</strong></em>。每一个寄存器保存下一条指令的内存地址，然后CPU就使用这些信息来抓取下一条指令。接下来，CPU再把指令储存在另一个寄存器中，然后把上一个寄存器的命令更新到下一条。CPU能够理解的指令（也叫指令集）是有限的。而且这些指令都是各自分明的。很多指令都是要求电脑去把数字从一个地方移动到另一个地方。—例如，从内存到寄存器。</p>
<p>在这个过程中有几点很有趣。第一，在电脑中任何东西都是以数字的形式储存的，数字是以数字的形式储存的。字符（例如你在文本编辑中的英文字母），也是由数字的形式储存的，每一个字符都有一个数字编码。计算机储存进寄存器的指令也是数字的形式，指令集中的每一条指令都对应着一个数字编码。第二，电脑程序最终会被以数字指令的形式表达，这又叫<em><strong>机器语言</strong></em>。</p>
<p>计算机运行的一种结果就是，如果你想让计算机做些事，你需要提供一系列的指令或者是程序，来明确地告诉它要做什么和怎么做。你必须创建一个电脑能够直接理解（使用机器语言）的程序。这是个精细、单调、费劲的任务。一些像两个数相加的简单的任务可能会被分解成几步，可能会像下面几步。</p>
<blockquote>
<p>1.从内存区域2000把数字复制到寄存器1<br>2.从内存区域2004把数字复制到寄存器2<br>3.用数字二的数值加上数字一，在寄存器1留下答案。<br>4.把寄存器1中的数据复制到内存区域2008</p>
</blockquote>
<p>而且你还得把每一条指令用数字指令表述出来！</p>
<p>如果你是喜欢以这种方式写程序的，你会很难过地了解到机器语言编程的黄金时期已经远远地过去了。但是如果你更喜欢那些更愉快的编程，那就对高级编程语言打开怀抱吧！</p>
<h1 id="1-5-高级计算机语言与编译器"><a href="#1-5-高级计算机语言与编译器" class="headerlink" title="1.5 高级计算机语言与编译器"></a>1.5 高级计算机语言与编译器</h1><blockquote>
<p>高级编程语言，比如C语言，以很多方式简化了你的编程。<br>    第一，你不需要用数字的形式来表达你的指令。<br>    第二，你使用的指令与你对于程序的思考而不是与电脑使用的精确的指令</p>
</blockquote>
<p>与其关心某一个CPU为了完成某一个任务进行的某一步。你可以以一种更复杂的形式来表达你想做的事情，例如，你也许会写下面的东西。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">total = mine + yours;</span><br></pre></td></tr></table></figure>

<p>看到这样的代码，你能够很明白它是干啥的，<br>而看着机器语言以数字构成的替代指令，那就太不易读了。</p>
<p>不幸的是，机器语言才是适合电脑的，对于电脑来说，高级语言完全无法理解。这就到了编译器上场的时候了，<em><strong>编译器</strong></em>是把高级语言程序详细地翻译成电脑需要的机器语言指令的程序。你以高级的方式思考，编译器做这些令人生厌的工作。</p>
<p>编译器方法还有另一种好处。每台电脑都设计了各自的机器语言，所以比如说英特尔PentiumCPU的机器语言对于摩托罗拉PowerPC CPU可能没有任何意义，但是你可以根据特定的机器语言搭配编译器。所以，使用一系列的编译器或者合适的编译器，你就可以把同样的高级编程语言转化成一系列不同的机器语言程序。你只需要解决这个问题一次，然后让编译器把这个解法翻译成一系列机器语言程序。</p>
<p>简短地说，高级的编程语言，比如C语言、Java还有Pascal，它们以一种更加抽象、与特定的CPU并不绑定的方式来表述程序行为。而且，对于机器语言来说，高级语言学习起来简单而且也更容易编程。</p>
<h1 id="1-6-使用C语言的七步走"><a href="#1-6-使用C语言的七步走" class="headerlink" title="1.6 使用C语言的七步走"></a>1.6 使用C语言的七步走</h1><p>C语言，如你所见，是一种编译型的语言，如果你习惯于使用如Pascal或者FORTRAN的编译型语言，你应该已经对组成C语言程序的基本步骤很熟悉了。如果你的基础语言是如BASIC，或者面向接口的计算机图形语言（如Visual Basic）的翻译型语言，或者你还没有编程基础，你需要学习如何编译。我们一会就会研究那个过程，你会认识到这是很合理简单的。首先，为了让你宏观、大体上了解编程，让我们把编写C语言程序分解成7个步骤（见图1.3）。值得注意的是，这只是理想化的步骤，在编程实践中，你需要在步骤中来回切换，用后面一步了解到的来使之前的一步得到优化。<br><img src="/img/Chapter1.6.png" alt="七步走"></p>
<h2 id="1-6-1-确定程序目的"><a href="#1-6-1-确定程序目的" class="headerlink" title="1.6.1 确定程序目的"></a>1.6.1 确定程序目的</h2><p>很自然的，你需要明确地知道你想让程序做什么，思考你的程序需要什么信息，需要在计算与控制上完成什么样子的事情，而且程序内的信息需要对你有所反馈，在这一步的规划中，你应当以大体出发，而不是根据特定的编程语言来思考。</p>
<h2 id="1-6-2-设计程序"><a href="#1-6-2-设计程序" class="headerlink" title="1.6.2 设计程序"></a>1.6.2 设计程序</h2><p>在有了对于你的程序应该干啥的印象之后，你应该选择程序如何来运行它，用户的交互界面会是什么样子的？程序应该如何被组织起来？程序的目标人群是？你需要多长时间来做完这个程序？</p>
<p>你还要决定在程序中呈现数据，而且很可能的，在辅助文件里也要。要决定用什么方式来处理数据。在刚开始学习C语言时，可能选择会很简单，但是随着你应对更多复杂的情况后，你就会知道这些选择是需要更多的思考的。选择一种好的方式来呈现数据经常会让设计程序与处理数据简单很多。</p>
<p>再一次，你需要在大体层面上思考而不是在特定的代码上，但是有些选择可能是基于编程语言的大体特点的，举个例子，C语言编程人员就比，比如说，Pascal编程人员在数据呈现上拥有更多的选择。</p>
<h2 id="1-6-3-编写代码"><a href="#1-6-3-编写代码" class="headerlink" title="1.6.3 编写代码"></a>1.6.3 编写代码</h2><p>既然你已经对于你的程序有个清晰的设计了，你就可以通过写代码的方式来实现它了。也就是说，你可以把你的程序设计翻译为C语言。这就是你需要用上C语言知识的地方了，你可以在纸上画出你的想法，但最后你还是要把你的代码输入电脑。这个过程主要取决于你的编程环境，我们一会会呈现更多的常见的编程环境。总体上，你会使用文本编辑器来创造一份源码文件，它包含了你程序设计的C语言翻译，例1.1给出了C语言源码的一个例子。</p>
<p><img src="/img/listing1.1.png" alt="图例1.1"><br>在这一步，你应该记录你的工作，最简单的方式是使用C语言的注释功能，它包含着你对于源码的解释，我们会在第二章详细讲到如何注释你的代码。</p>
<h2 id="1-6-4-编译"><a href="#1-6-4-编译" class="headerlink" title="1.6.4 编译"></a>1.6.4 编译</h2><p>下一步就是编译源码，再一次，细节上的问题是与你的编程环境相关的，我们马上会研究几种常见的环境了。现在，让我们以更概念化的方式看看发生了什么。</p>
<p>我们已经知道编译器的工作就是把源码转化成可执行文件。<em><strong>可执行文件</strong></em>是以我们电脑的自然语言（或者说<em><strong>机器语言</strong></em>）写成的，这种语言是以精细的数字代码形式呈现的。而且你之前也了解到了，不同的电脑的机器语言是不一样的。C语言的编译器也包括着C语言库中的代码。C语言库包含着很多的基础的、日常使用的东西，比如<strong>Printf</strong>和<strong>scanf</strong>函数。（更精确地说，一个叫做连接器的程序把C语言库中的一组代码带到编译器，但是编译器在大多数系统都是可以运行连接器的），最终结果就是包含着电脑可理解的可执行文件的程序，你可以直接运行。</p>
<p>编译器还会检查你的程序是不是使用了符合语法的C语言，如果编译器发现了错误，它就会汇报给你，而且不会生成可执行文件，理解编译器提示的错误信息也是你会很快习得的另一项技能。</p>
<h2 id="1-6-5-运行程序"><a href="#1-6-5-运行程序" class="headerlink" title="1.6.5 运行程序"></a>1.6.5 运行程序</h2><p>通常的，可执行文件是你可以运行的程序，你可以在很多常见的环境中，包括MS-DOS、Unix、Linux控制台、只需要打字写下可执行文件的名称。其他的环境，比如VMX、VAX可能需要一些运行指令或者其他的机制方法。<em><strong>集成开发环境（IDE）</strong></em>，像很多在Windows系统或者Mac系统上的，使你能够在IDE内部通过菜单选项或者按几个按键来编辑与运行你的C语言程序。最终生成的文件也可以通过双击文件名或者图标的方式从你的操作系统直接运行。</p>
<h2 id="1-6-6-测试与Debugging"><a href="#1-6-6-测试与Debugging" class="headerlink" title="1.6.6 测试与Debugging"></a>1.6.6 测试与Debugging</h2><p>你的程序能够运行是个好迹象，但是有可能你的程序并没有正确地运行。因此，你应该检查下是否它做到了它应该做的事情。你会发现有些程序是会有问题（在计算机领域内的行话叫bugs）的。调试是查找与修复程序错误的过程，学习的过程中犯错误是自然且正常的。看起来编程“天生”需要调试，所以当你把学习到的与编程实际结合起来的时候，你最好准备好在犯错的时候提醒自己。随着你成为一个更加强大与巧妙的编程人员，你也会不断地犯错，但你也因此不断地变得更加强大与巧妙。</p>
<p>你会有很多机会犯错，基础的设计层面错误，实现过程出错，忽略了可能会搞砸你的程序的输入。你可能会不恰当地使用C语言，你可能会拼写错误，可能会把括号放错了位置等等等等。你会有自己的错误方式来丰富这一列的。</p>
<p>幸运的是，这种情况并不是无望的，即使有时候你会这样认为啦。<br>编译器会捕捉到很多种类的错误，而且还会有工具来帮助你找到许多种编译器没有办法捕捉的错误。继续读下去，这本书也会给到你一些调试的建议。</p>
<h2 id="1-6-7-维护与修改程序"><a href="#1-6-7-维护与修改程序" class="headerlink" title="1.6.7 维护与修改程序"></a>1.6.7 维护与修改程序</h2><p>当你为自己或者别人创造了一个程序，你可能会发现程序是可以有更多的用处的。如果是的，你可能会发现是有理由做出些修改的。可能有个小bug只有别人把名字以Z&#x2F;z开头的时候才会发生，或者你会想出一种能够解决问题的更好的方式，可以聪明地加入一些的新功能，你可能需要改写程序以便它能够在不同电脑系统中运行。如果你明确地注释了这些程序，所有这些任务都会被极度地简化。</p>
<h2 id="1-6-8-注释"><a href="#1-6-8-注释" class="headerlink" title="1.6.8 注释"></a>1.6.8 注释</h2><p>编程的过程并不总是像这个过程描述的那样线性。有的时候你需要在步骤中前后切换。例如，当你在写代码的时候，你有可能发现你的计划并不实际。你有可能发现了一种更好的方式来做事，或者在看到程序是怎么运行的之后，你会想要改变你的设计，记录你的工作能够帮助你在不同的等级之间前后切换。</p>
<p>许多学习者通常会忽略掉第一步与第二步（确定程序目的与设计程序）直接进入第三部（写程序），你写的第一个程序或许可以直接在脑中看到完全的流程，如果犯错也很好定位错误。但是随着你编写的程序越来越复杂，越来越冗长，心智的视觉化就开始失效了，而且错误也会更难以发现。最终，那些忽略了规划步骤的人就陷入数小时的时间浪费、困惑还有沮丧，因为他们写出的丑陋的，无法实现功能而又深奥的程序。这项工作越是复杂，需要的规划工作就越多。</p>
<p>道理就是你需要养成在写代码之前做规划的习惯，使用这种古老但是可敬的笔尖技术来记下你程序的目的，给程序设计做出大纲。如果你这样做的话，你最终会收获节省时间与满足感的巨大红利。</p>
<h2 id="1-6-9-编程技术"><a href="#1-6-9-编程技术" class="headerlink" title="1.6.9 编程技术"></a>1.6.9 编程技术</h2><p>你生成程序的明确步骤是取决于你的电脑系统的，因为C语言是可传输的，它是可以适用于很多的系统环境的，包括Unix，Linux，MS-DOS（是的，很多人仍然在用），Windows与Mac OS，其实还有很多只不过没有足够的空间留给它们了，这尤其是因为各自的产品不是演化、消亡，就者被取代。</p>
<p>首先，即使如此，让我们先来研究许多C语言运行环境的共有特点，包括我们刚才已经提到的五种系统，你不需要明确地知道是什么引导了C语言程序的运行，但这是良好的基础，它也能够帮助你更好地理解为什么你需要经历一些特定的步骤来得到一个C语言程序。</p>
<p>当你在写C语言程序的时候，你会在源码文件中储存你在文本文件中写下的东西。大多数由C语言编程的系统，也包括我们提到的那一些，需要以<code>.c</code>结尾的文件（举个例子，<code>wordcount.c</code>与<code>budget.c</code>）在<code>.c</code>之前的那部分名字叫做<em><strong>基准名（Basename）</strong></em><br>在这一段后面的名称叫做<em><strong>拓展名（Extension）</strong></em>，因此，<code>budget</code>是基准名，<code>.c</code>是拓展名。它们的混合就是文件名。文件名也必须要复合特定的电脑操作系统的需要。例如，IBM-PC与[克隆机？]上的MS-DOS系统，它就要求你的文件名不能多于8个字符长。所以，<code>wordcount.c</code>在DOS系统中就不是合法的文件名。一些Unix系统在整个文件名上有14个字符的限制，包括拓展名，其他Unix系统也允许更长的名称，不多于255个字符即可。Linux、Windows与MacOS也允许更长的文件名。</p>
<p>让我们假设我们拥有一份名字叫<code>Concrete.c</code>的源文件储存着例1.2的C语言源码。<br><img src="/img/listing1.2.png" alt="Concrete.c"><br>不需要担心在源码文件中的一些细节，在第二章你会学到的。</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="1-7-1-目标代码文件、可执行文件和库"><a href="#1-7-1-目标代码文件、可执行文件和库" class="headerlink" title="1.7.1 目标代码文件、可执行文件和库"></a>1.7.1 目标代码文件、可执行文件和库</h2><p>C语言编程的一个基本本领就是把你的源代码文件转化成保存着即时就可运行的可执行文件。要实现这个过程需要两个步骤：编译与连接。编译器可以把源代码转换成中间代码，然后连接器再把中间代码与其他代码组合，由此创造出可执行文件。C语言利用这两部分结合的方法让程序易于模块化生成。你可以把每一个模块分开来编译，再用连接器把每一个编译过的模块结合起来。以那种方式，如果你想改变其中的一个模块，你就不需要再重新编译其他的模块，而且连接器也会把你的程序与预先编译好的库代码结合起来。</p>
<p>要生成中间文件的方法还有几种，最流行的而且能够实施的在这里已经提到了，就是把源代码文件转化成机器语言代码，把结果放在目标代码文件中或者简短地说，目标文件。（假设你的源码是由单一文件组成的），虽然目标文件包括了机器语言代码，它还没准备好运行。目标文件包含了对于源代码的翻译版本，但是它还不完整。</p>
<p>缺失的第一个部分就是起始代码，它作为你的程序与操作系统的接口。举个例子，你可以在在DOS或者Linux之下协调地运行BM PC，它们的硬件都是类似的，所以同样的目标文件对于两种系统都是可以起作用的，但是你需要在DOS与Linux不同的起始代码，因为不同的系统是以不同的方式处理程序的。</p>
<p>第二个缺失的部分就是常用库的代码。几乎所有的C语言程序都需要利用C语言的库函数。比如<code>Concrete.c</code>使用的<code>printf()</code>。目标代码文件并不包括这个函数的代码。它只包含了<code>printf</code>函数的声明指令，实际的代码是在另一个文件中储存的，它叫<em><strong>库文件</strong></em>。库文件包含了很多函数的代码。</p>
<p>连接器的作用就是把这三个部分连接在一起-你的目标代码、起始代码和库代码，然后把三者整合为一个文件，即可执行文件。对于库代码，连接器只提取需要使用的函数在C语言库中对应的代码。<br>（见图1.4）<br><img src="/img/listing1.4.png" alt="图1.4"><br>（可见，上图中，由源代码经过编译器生成目标代码文件，再由目标代码文件与起始代码、库代码通过连接器转化为可执行文件<code>concrete.exe</code>）.</p>
<p>简短来说，一份目标文件与可执行文件都由机器语言指令组成。然而，可执行文件只把你使用的代码翻译为机器语言，但可执行文件还由常用库与起始代码的机器语言翻译组成。</p>
<p>在一些系统中，你必须把编译与连接的过程分开。另外的一些系统中，编译器会自动启动连接器，所以你只需要编译即可。</p>
<p>现在我们就针对于特定的系统来研究一下。</p>
<h2 id="1-7-2-Unix系统"><a href="#1-7-2-Unix系统" class="headerlink" title="1.7.2 Unix系统"></a>1.7.2 Unix系统</h2><p>因为C的流行始于Unix系统，我们就从它开始。</p>
<h3 id="在Unix系统中进行编辑"><a href="#在Unix系统中进行编辑" class="headerlink" title="在Unix系统中进行编辑"></a>在Unix系统中进行编辑</h3><p>Unix系统并没有独立的C语言编译器。你反而需要一些多功能的Unix编辑器，例如emacs、jove、vi或者一个X Window系统文本编辑器。</p>
<p>你的最主要的两个目的就是正确地书写程序，并且为储存程序的文件起个名字。正像已经提到的，文件的名称必须以<code>.c</code>。注意到Unix系统会以大小写来区分文件，所以<code>BUDGET.c</code>、<code>budget.c</code>还有<code>Budget.c</code>是三个各自不同的C源文件名称，但是<code>BUDGET.C</code>是不合法的，因为它的扩展名使用了大写。</p>
<p>使用vi编辑器，我们把下面的程序保存在名叫<code>inform.c</code>的文件中。<br><img src="/img/informc.png" alt="inform.c"><br>这些文本就是源代码，而<code>inform.c</code>是源文件，重点就在源文件只是一个过程的起点，而不是结尾。</p>
<h3 id="在Unix系统中进行编译"><a href="#在Unix系统中进行编译" class="headerlink" title="在Unix系统中进行编译"></a>在Unix系统中进行编译</h3><p>我们的程序，虽然已经不可否认地很精致了，对于电脑仍然是一派胡言，电脑是不理解什么是<code>#include</code>和<code>printf</code>的（现在你可能也不理解，但是我们很快就会学习，然而电脑并不会），正像我们之前讨论过的。我们需要编译器的帮助来把我们的代码（源代码）翻译为电脑的代码（机器语言）。这些工作的结果就是可执行文件，它会包含所有可以让电脑完成工作的代码。</p>
<p>UnixC编译器叫<code>cc</code>，为了编译<code>inform.c</code>程序，你需要把下面的指令打下来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cc inform.c</span><br></pre></td></tr></table></figure>

<p>几秒之后，Unix系统的命令提示符就会给出反馈，告诉你这件事已经做完了，如果你没有正确地编写代码的话可能会得到警告或者错误信息，但我们先假设一切都是正确的。（如果你的编译器对于<code>void</code>这个词进行报错，那是你的编译器还没有更新到 <strong>ANSI C</strong> 的编译器，我们会在不久提到更多的标准，即使这样，你从例子中删掉void就好）。如果你使用<code>ls</code>指令来把你的文件列出来的话，你会发现产生了一个新文件叫<code>a.out</code>（见图1.5）这就是包含了程序中翻译后指令（或编译后指令）的可执行文件。想要运行的话直接打下<code>a.out</code>即可。</p>
<p>然后，文件中的指令执行，智言倾泻而出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">A .c is used to end a C program filename.</span><br></pre></td></tr></table></figure>
<p>如果你想要吧可执行文件保存下来，你需要重新命名它，<br>否则，这个文件在你下一次编译时就会被新的同名文件代替。<br><img src="/img/process.png" alt="The process"><br>（从源码到程序的过程）</p>
<h2 id="Linux-系统"><a href="#Linux-系统" class="headerlink" title="Linux 系统"></a>Linux 系统</h2><p>Linux也是个很受欢迎的开源的，与Unix类似的多平台操作系统，它包括IBM与Mac的兼容。在Linux上设计程序与Unix系统的过程大部分是相似的，除了你需要使用公用C语言编译器，它叫gcc，是由GNU提供的，在那里面，编译的指令是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc inform.c</span><br></pre></td></tr></table></figure>
<p>注意到在Linux安装的时候安装gcc的时候可能是可选的，所以你（或者其他人）有可能如果之前没装的话必须得自己安装gcc。通常这会让cc成为gcc的一个别名，所以你喜欢的话可以用cc来代替gcc。</p>
<p>你可以在下面的网站中获取关于gcc获取更多的信息，包括最新的版本。<br><a href="http://www.gnu.org/software/gcc/gcc.html">http://www.gnu.org/software/gcc/gcc.html</a>.</p>
<h2 id="集成开发环境（Windows）"><a href="#集成开发环境（Windows）" class="headerlink" title="集成开发环境（Windows）"></a>集成开发环境（Windows）</h2><p>C编译器并不是Windows安装包中的一部分，所以你也有可能需要安装一个C语言编译器。很多供应商，比如Microsoft, Borland, Metrowerks, 还有Digital Mars, 提供了以Windows系统为基础的集成开发环境（<em><strong>IDE</strong></em>）（近来，很多已经把C语言与C++编译器结合在一起了。）它们都有快速且集成的环境，可以方便地生成C语言程序。值得注意的是，每一个程序都有一个嵌入式的编辑器，你可以用它来编写C语言程序。都有可以让你命名、保存、编译、运行的菜单。每一次编译运行如果编译器发现错误了你都可以回到编辑器，而且出错的代码行都会被突出显示出来，并搭配上适当的错误信息。</p>
<p>Windows IDE通常是可以一同处理C与C++的，你需要声明你需要一个C++程序。使用一些产品，比如Metroworks或者CodeWarrior里你需要用项目类型来区分你使用的语言。其他的产品比如Visual C++你是使用<code>.c</code>的扩展名来表示你想要使用C语言而不是C++。然而，大多数C语言程序也作为C++程序运作，可以参考“Differences Between C and C++”，那里对C与C++进行了比较。</p>
<p>你有可能遇到的一个问题是当程序停止的时候程序运行的窗口也随之关闭，如果你也遇到这种情况，你可以让程序直到你输入一个字符再结束。只要在代码结尾，return语句前加上一行代码即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">getchar();</span><br></pre></td></tr></table></figure>
<p>这一行代码读取一个键盘输入，所以直到你输入下一个字符之前程序都是暂停着的。一些时候，受到程序运行方式的影响，可能在最后已经有一个键入数据等待了，这种情况下你就得输入两次。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">getchar();</span><br><span class="line">getchar();</span><br></pre></td></tr></table></figure>

<p>例如，如果程序做的最后一件事是要求你输入你的体重，你已经输入完体重了然后输入enter来输入数据，程序会读取你的体重，第一个<code>getchar</code>会读取回车符，第二个<code>getchar</code>直到你再打一个字符才会有，如果你现在还不太能够理解，你学习完C语言输入就会明白了。</p>
<p>即使多种多样的IDEs普遍有着比较类似的标准，但是细节方面还是各自不同的，不仅在一行程序内，还在编译器的不同版本。你需要做些实验，来获知你的编译器是怎么工作的，你还有可能需要阅读使用手册或者尝试网上教程。</p>
<h2 id="IBMPC上的DOS编译器"><a href="#IBMPC上的DOS编译器" class="headerlink" title="IBMPC上的DOS编译器"></a>IBMPC上的DOS编译器</h2><p>对于很多人来说，在个人电脑上运行DOS是很过时的事情，但是它对于那些电脑资源与预算受限、喜欢更简单的，没有[响铃、哨音]与令人分心的事物的操作系统。很多Windows IDEs额外提供了命令行工具，这就然你能够在DOS命令行环境下编程。Comeau的C&#x2F;C++编译器在很多系统中是适用的，包括几种Unix、Linux的变体，它就拥有一个命令行DOS的版本。并且，它还有免费与共享的DOS系统编译器，例如，GNU gcc编译器就有一个以DOS为基础的版本。</p>
<p>源码文件应该以文本文件形式存在，而它们并不是文字处理文件。（文字处理文件包括了很多额外信息，比如字体和格式）你应该使用一个文本编辑器如Windows Notepad或者与一些版本的DOS一同发布的EDIT程序。文件的扩展名需要是<code>.c</code>，一些处理器会自动在文本文件后面加上<code>.txt</code>的扩展名。如果你遇到了这种情况，你需要改变文件名，把<code>.txt</code>改为<code>.c</code>。</p>
<p>电脑上的C语言编译器通常，但并不总是，生成带有<code>.obj</code>后缀的中间目标代码，不像Unix编译器，C语言编译器通常不会在编译完成之后删除这些文件。有些编译器也会生成带有<code>.asm</code>扩展名的汇编语言文件，或者使用它们自己的特殊形式。</p>
<h2 id="Mac上的C语言"><a href="#Mac上的C语言" class="headerlink" title="Mac上的C语言"></a>Mac上的C语言</h2><p>最广受闻名的Mac C&#x2F;C++编译器就是Metrowerks CodeWarrior 编译器（Windows与Mac版本的CodeWarrior有相似的界面），它提供了与Windows编译器相似的以项目为基础的IDE。从文件菜单选择新文件开始，一系列的项目类型选择将会陈列在你眼前。在最新的CodeWarrior版本中，使用Std C控制台即可（不同的发布版本需要经过不同的步骤才到达选择这一步），你还有可能在68KB版本（适于摩托罗拉 680 * 0 系列的处理器），PPC版本（适于PowerPC处理器）或者Carbon版本（适于OS X系统）</p>
<p>新的项目在最初项目中会有一个很小的源码文件，你可以尝试编译或者运行它来获知你的系统是否设置好了。</p>
<h1 id="1-8-语言标准"><a href="#1-8-语言标准" class="headerlink" title="1.8 语言标准"></a>1.8 语言标准</h1><p>现在，很多C语言实例都是可行的，理想化情况下，当你在写C语言程序时，在任何的实例中都是一样运作的（假设你没有使用特殊机器来编程），为了这件事情能够实现，不同的实例需要有一个确定的、可识别的标准。</p>
<p>最初，C语言官方并没有语言标准，但是，由Brian Kernighan和Dennis Ritchie（1978）编纂的最初一版的<em><strong>C Programming Language</strong></em>确立了被接受的标准，它通常被称作为<em><strong>K&amp;R C</strong></em>或者<em><strong>classic C</strong></em>。特别的是，那本书附录中的“C Reference Manual”作为了C语言实例的指导。但是，比如编译器，就会要求一个完整的K&amp;R实例，因为即使附录中定义了C语言，它还没有定义C语言库。C比其他的大多数语言都要更加依赖于C语言库，所以库标准还需要确立。没有任何的官方标准的情况下，Unix实例中提供的库就成为了实际的标准。</p>
<h2 id="第一个ANSI-ISO-C语言标准"><a href="#第一个ANSI-ISO-C语言标准" class="headerlink" title="第一个ANSI&#x2F;ISO C语言标准"></a>第一个ANSI&#x2F;ISO C语言标准</h2><p>随着C语言的进步与在不同系统中的广泛使用，C语言社区意识到它需要一个更加综合、与时俱进并且严格的标准。为了满足这种需求，美国国家标准研究院在1983年成立了X3J11委员会，开发了一种新的标准，它在1989年被正式使用，这种新型标准（ANSI C）不仅定义了语言而且还定义了基础的C语言库，国际标准化组织采用了在1990年一种C语言标准（ISO C）。ISO C与ANSI C本质上是一样的标准。ANSI&#x2F;ISO标准的最后一种版本通常被称作<em><strong>C89</strong></em>（因为那是ANSI同意的时候）或者<em><strong>C90</strong></em>（那是ISO同意的时候），而且因为ANSI版本是先推出的，人们更经常用的是ANSI C。</p>
<p>这个协会有几项指导准则，可能最有趣的就是这一项：保持C语言的精神<br>委员会在阐述这种精神的时候列出了以下的几点。</p>
<ul>
<li>相信编程人员。</li>
<li>不要阻止编程人员做需要做的事情。</li>
<li>保证简单、小型地使用这种语言。</li>
<li>一项操作只提供一种方式。</li>
<li>即使传输性会下降，也要尽力让C语言程序运行变快。</li>
</ul>
<p>在最后一点中，委员会的意思是实例必须界定一种对于目标电脑的运转最好的操作，而不是试着强加抽象的、统一的定义。在学习语言的同时，你也会体会到这种哲学的。</p>
<h2 id="C99标准"><a href="#C99标准" class="headerlink" title="C99标准"></a>C99标准</h2><p>在1994年，他们开始重新审视这个标准，这也导致了C99标准的产生，一个ASIO&#x2F;ISO联合委员会，也被称作<em><strong>C9X</strong></em>委员会批准了C90标准的准则，包括保持语言的小型与简洁，委员会的目的并不是向语言中添加新的特性，而是按需去达到新的目标。其中一个主要目标就是，通过比如提供解决国际字符集的方法，来支持国际编程。另一个目标就是“把现存的实践编程化来解决明显的缺陷”。因此，当在达成把C语言移植到64位的处理器上的需要时，委员会 以在真实生活中应对过这种问题的人的经验为基础来添加标准。第三个目标就是改善C语言执行科学与工程项目时做关键数字运算时的合适度。</p>
<p>这三点-国际化，纠正缺陷与对于计算可用度的改善是最主要的以改变为方向的目标，其他的改变计划自然更加保守，例如，把与C90与C++的不协调降到最低，并且让这个语言概念上是简洁的。用委员会人员的话来说，“委员会在让C++变得更加重要，更加有发展动力。</p>
<p>C99改变的结果，就是它保持了C语言的必要的基本特征，C语言仍然是一个小型的，简洁并高效的语言，这本书指出了很多C99的变化，因为现在的大多数编译器还没有完全实现所有的C99的改变，你可能会发现有些在你的系统上不能实施，或者你会发现一些C99特征只有你改变了一些编译器的设置才可以实现。</p>
<p>#注意<br>这本书将会使用ISO&#x2F;ANSI C这些词来表示这些特征来表示均为两种标准均适用的特征，使用C99来指明新的特征。偶然的，当一种特性是第一次加入C语言时，它也指C90标准。 </p>
<h1 id="1-9-本书的组织架构"><a href="#1-9-本书的组织架构" class="headerlink" title="1.9 本书的组织架构"></a>1.9 本书的组织架构</h1><p>组织信息的方式有很多。其中一种最直接的方式就是把每一个话题的所有相关信息全部列出来，这对于参考书是极其实用的，因为你就可以在一个地方找到所有关于给定主题的信息。但是它对于学习项目并不是最好的顺序。例如，如果你从开始学习名词开始学习英语，你的表达能力就会被严重地限制。当然，学习好了名词你随便找到某个东西就能说出它的名字，但是如果你能够学一些名词、动词、形容词等等，还有一些关于这些部分如何相互连接的规则，你就会有更大的能力来表达自己。</p>
<p>为了让你能够更均衡地消化信息，这本书使用了一种螺旋上升的方式，在初期的时候先提到这个主题，然后在后文给予更充分的讨论。例如，对于理解C语言，理解函数是极其关键的，因此，在前面的几章就会包括对于函数的一些讲述，以便于你能够在第九章全面讲述函数的时候，已经能够使用函数获得到一些轻松了。相似的早期的篇章也会预先讲述字符串和循环，那样你就可以在还没有细致地地了解它们之前，在你的程序中先使用那些有用的工具。</p>
<h1 id="1-10-例子的使用"><a href="#1-10-例子的使用" class="headerlink" title="1.10 例子的使用"></a>1.10 例子的使用</h1><p>我们已经差不多要开始学习C语言了，这一单元已经包括了我们在陈述材料的时候的一些例子了。</p>
<h2 id="字体-Typeface"><a href="#字体-Typeface" class="headerlink" title="字体 Typeface"></a>字体 Typeface</h2><p>对于呈现文字的程序与电脑的输入输出，我们使用你很可能在屏幕上或者在输出的时候看到的相似的字体。我们已经使用过几次了。为了防止你没有注意到，字体看起来是下面这样的</p>
<p><img src="/img/typeface.png" alt="字体示例"></p>
<p>相同的等宽字体也被用作是与编程相关的词汇，比如<code>main()</code>，也用作文件名，比如<code>stdio.h</code>，对于用来替换特殊词汇的占位字符，我们是用斜体的等宽字符来写的，比如下面的描述。<br><em>type_name variable_name;</em><br>例如，你有可能用<em>type_name</em>来替换<code>int</code>，用<em>variable_name</em>来替换<em>zebra_count</em></p>
<h2 id="程序输出-Program-Output"><a href="#程序输出-Program-Output" class="headerlink" title="程序输出 Program Output"></a>程序输出 Program Output</h2><p>电脑中的输出是以与我们书中相同的形式被印出来的，但输入是以粗体字被显示出来的。例如，下面就是在14章“结构体与其他数据类型”中的输出。</p>
<p><img src="/img/output.png" alt="输出示例"></p>
<p>以正常电脑字体打印出来的是程序的输出，黑体字是用户的输入。<br>你与你的电脑交互的方式有很多，我们假设你是用键盘在键入指令的，在屏幕上阅读反馈。</p>
<h2 id="特别的按键-Special-Keystrokes"><a href="#特别的按键-Special-Keystrokes" class="headerlink" title="特别的按键 Special Keystrokes"></a>特别的按键 Special Keystrokes</h2><p>通常，你会通过一个标签为Enter的按键，c&#x2F;r，返回或者其他的方式输入一行指令，我们在文中称这些按键为<em><strong>Enter key</strong></em>，自然也就会默认你会在每一行输入之后按下Enter键。然而，为了阐明特定的观点，一些例子可能会明示出Enter键，以[enter]的形式来呈现它，这个括号就表示你需要按下一个按键而不是打字<strong>enter</strong>。</p>
<p>控制字符中的特殊按键，比如CTRL+D，这种标记指在你按下Ctrl标志的按键（或者可能是Control）时按下D键。</p>
<h2 id="准备学习这本书使用的系统"><a href="#准备学习这本书使用的系统" class="headerlink" title="准备学习这本书使用的系统"></a>准备学习这本书使用的系统</h2><h2 id="Systems-Used-in-Prepare-This-Book"><a href="#Systems-Used-in-Prepare-This-Book" class="headerlink" title="Systems Used in Prepare This Book"></a>Systems Used in Prepare This Book</h2><p>C语言的一些部分，比如储存数字时使用的空间，是取决于系统的。当我们举例子并且指的是我们的系统，“我们提的是一台在WinXP专业版下有奔腾处理器的电脑，并且使用Metrowork的CodeWarrior开发工作室9.2版本和微软的Visual C++ 7.1（这个版本Microsoft Visual Studio .NET 2003也开发完成）,或者gcc 3.3.3。在编写的时候，对C99的支持并不完全，而且没有编译器能够支持C99的全部特性。但是，在它们之间，这些编译器已经包含了许多的新标准下的东西了。大多数实例是在Mac G4上通过Metrowerks CodeWarrior Development Studio 9.2来测试的。</p>
<p>这本书有的时候也参考在Unix系统中运行的结果，Unix系统是在Berkley’s BSD 4.3 version的Unix系统中，在VAX 11&#x2F;750电脑上运行的。而且，一些程序也是在Linux系统下使用gcc 3.3.1与Comeau 4.3.3在奔腾处理器的电脑上测试的。</p>
<p>样本代码，对于在这本书中陈述的完整程序是可以在Sams网址 (<a href="http://www.samspublishing.com/">www.samspublishing.com</a>) 中找到的，搜索这本书的ISBN号（不带连字号）就会显示这本书的昵称，点击昵称，进入网址，你就可以下载代码了。你还可以在这个网站上找到编程训练的解决方法。</p>
<h2 id="你的系统-你需要的-Your-System"><a href="#你的系统-你需要的-Your-System" class="headerlink" title="你的系统-你需要的 Your System"></a>你的系统-你需要的 Your System</h2><p>你需要有一个C语言编译器，或者至少可以使用一个。C可以在很多中电脑中运行，所以你有很多的选择。一定要确保使用的编译器是专门为了你的系统而设计的。这本书中的一些实例需要C99标准支持，但是大多数实例在C90标准下的编译器都是可以运行的。如果你使用的是在ANSI&#x2F;ISO标准之前的，你就需要做出一些调整了，很可能得通常鼓励你去找寻些新的东西了。</p>
<p>大多数编译器的供应商会为学生与教育者特价，如果你是那类人，那就看看供应商的网站。</p>
<h2 id="特殊元素-Special-Element"><a href="#特殊元素-Special-Element" class="headerlink" title="特殊元素 Special Element"></a>特殊元素 Special Element</h2><p>这本书包含了几部分特殊元素，强调了特别的重点：补充、建议、警告、笔记。</p>
<p><img src="/img/four_kinds.png" alt="四种特殊信息类型"></p>
<ul>
<li>Sidebar(补充)<br>  为阐明内容提供了更深刻的见解或者更多的背景信息</li>
<li>Tip(建议)<br>  对于特定的编程情况提供了简短，使用的建议。</li>
<li>Caution(警告)<br>  警告潜在的陷阱</li>
<li>Note(笔记？)<br>  提供了综合的注释，不符合其他的特殊类型的信息。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C语言是一种强大、简洁的编程语言。<br>因为提供了使用的编程工具、对于硬件设备的控制良好，<br>并且是最容易从一种设备传输到另一种设备的语言，<br>它受到很多人的欢迎。</p>
<p>C语言是一种编译型的语言，<br>需要C语言编译器与连接器来把C语言源代码转化成可执行程序。</p>
<p>C语言的编程可能是费力、困难甚至令人沮丧的，<br>但是它也可以是有趣的、令人振奋与满足的。<br>我们希望你能够像我们一样找到C语言的乐趣与魅力。</p>
<h1 id="回顾问题"><a href="#回顾问题" class="headerlink" title="回顾问题"></a>回顾问题</h1><p>你会在<strong>附录A-回顾问题答案</strong>中找到问题的答案。<br>(以下为我本人的想法)</p>
<p>1.在编程中，<em><strong>传输性</strong></em>指的是什么?<br>    编程得到的文件在不同类型的操作系统中几乎不需要修改或者只需要修改一点就可以顺利地进行转移。<br>2.解释源码文件、目标代码文件与可执行文件。<br>    源码文件是我们通过编辑器输入的代码，目标代码文件是源码文件经过编译器处理之后生成的包含库文件函数声明与我们输入的代码的机器语言翻译的文件，一般是asm的汇编文件或者obj，不具有执行的能力。<br>    可执行文件是把库文件与目标代码文件结合起来之后翻译成的最终文件，它包含了程序运行需要的一切函数声明、变量、指令的翻译。<br>3.编程的七步走。<br>    首先在纸上想这个问题可以怎么解决，然后结合具体的语言来想实现方法，然后写代码，然后编译，然后运行，然后检查正误，进行修改与调试。<br>    ×<br>    第一步，明确程序目的，你想要程序做什么<br>    第二步，设计程序，包括目标人群，用户界面与交互方式，实现时间，数据处理方式<br>    第三步，使用C语言知识写代码<br>    第四步，编译<br>    第五步，运行程序<br>    第六步，通过输出过程量等方法来调试，输入多个值来测试。<br>    第七步，维护与修改程序。<br>4.编译器做了什么工作？<br>    把源码文件中你输入的代码转变为机器语言。<br>5.连接器做了什么工作。<br>    把你代码中缺少的库函数内容补充完整，并且针对系统添加起始代码。</p>
<h1 id="编程训练"><a href="#编程训练" class="headerlink" title="编程训练"></a>编程训练</h1><p>我们现在还不期望你开始写C语言代码，所以这一次锻炼就集中于编程过程的早期阶段吧。</p>
<p>1.你被MacroMusic公司录取了，这个公司正在进入欧洲市场，想要一个能够把英尺换算成厘米的程序（1 inch &#x3D; 2.54cm）公司想要让这个程序能够提示使用者去输入一个英尺值，你的任务就是找出这个程序的目的，并且设计这个程序。</p>
<p>程序目的：我想要设计一个通过乘除法来把输入的数值变作2.54倍的程序，输入是英尺值，2.54倍是厘米值。</p>
<p>程序设计：<br>首先输出一行：请输入英尺值<br>然后向用户获取输入值。<br>接着经过把值 * 2.54来获取厘米值<br>然后在屏幕上输出数值。</p>
<p>交互方式就是输入输出，因为目标人群是欧洲人，所以需要英语，需要更多的UI设计等。</p>
<blockquote>
<p>END..</p>
</blockquote>
]]></content>
      <tags>
        <tag>C_premier_plus</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数学小整理</title>
    <url>/2023/11/27/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%B0%8F%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p><img src="/img/page1.png" alt="第一页"><br><img src="/img/page2.png" alt="第二页"><br><img src="/img/page3.png" alt="第三页"></p>
]]></content>
      <tags>
        <tag>大学学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言练习7讲解</title>
    <url>/2023/11/24/C%E8%AF%AD%E8%A8%80%E7%BB%83%E4%B9%A07%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<p>可能因为课题的深入吧，我们的题目难度也与日俱增。今天关于数组的题目有些很值得讲的，今天和大家分享一下我的看法。</p>
<span id="more"></span>

<h2 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h2><p>因为今天上午已经学过并且讲过，所以这题没啥好说的。<br>从0到n - 1输入数组，从n - 1到0输出数组。<br>两个for循环搞定。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="type">int</span> <span class="built_in">array</span>[<span class="number">11</span>];     <span class="comment">//1-10 略大一点，留有余地。</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;<span class="built_in">array</span>[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>;i &gt; <span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>,<span class="built_in">array</span>[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组最小值"><a href="#数组最小值" class="headerlink" title="数组最小值"></a>数组最小值</h2><p>审题得：题目的要求是求最小值以及其下标，然后输出下标最小的一个<br>最小值我们知道怎么求，一个for循环搞定。<br>其实因为你找到了第一个值，把它设置为最小值之后，<br>就算另一个值与它相等，我们找的是比它小的数，而不是相等，<br>相当于没关系了。</p>
<p>那么开写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n, min, iPosit;</span><br><span class="line">	<span class="type">int</span> <span class="built_in">array</span>[<span class="number">1001</span>]</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;<span class="built_in">array</span>[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	min = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(min &gt; <span class="built_in">array</span>[i])</span><br><span class="line">		&#123;</span><br><span class="line">			min = <span class="built_in">array</span>[i];</span><br><span class="line">			iPosit = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,min,iPosit);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组n个输入的模版-仅供参考。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> <span class="built_in">array</span>[<span class="number">101</span>]</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;<span class="built_in">array</span>[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除元素："><a href="#删除元素：" class="headerlink" title="删除元素："></a>删除元素：</h2><p>在直播中我们只讲函数，思路今天上午已经讲过了。</p>
<p>一个是PrintArr，相信不太用多说</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PrintArr</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		print(<span class="string">&quot;%d&quot;</span>, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个就是我们的del函数，用的是覆盖的思路。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k = i;k &lt; n - <span class="number">1</span>;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[k] = a[k + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>今天下午看到我们小伙伴有对调用时数组的形式不太理解的，<br>这里说一下。<br>我们调用函数的时候参数填入的是数组的名称<br>比如我们调用del函数时，我们是这样写的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">del(<span class="built_in">array</span>, n, k);</span><br><span class="line"><span class="comment">//array为数组名，n为长度，k是要删除的下标。</span></span><br></pre></td></tr></table></figure>

<p>不需要加中括号，那样的话指向的就是数组中的元素了。<br>比如array[10]，甚至我们数组中没有这个元素，那样就会导致<strong>运行错误</strong><br>余下就执行函数就好，注意PrintArr在覆盖之后输出n - 1的值。<br>因为数组在覆盖之后最后一个值与倒数第二个值是相等的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> i)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintArr</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">    del(<span class="built_in">array</span>, n, k);</span><br><span class="line">    PrintArr(<span class="built_in">array</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = i;k &lt; n - <span class="number">1</span>;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[k] = a[k + <span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintArr</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组元素</p>
<p>下一题，加入一个find函数，在主函数中加入一个if判断找不找的到就好<br>找的到，返回i，找不到，返回-1.</p>
<p>[find函数]</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x == a[i]) <span class="keyword">return</span> i; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面判断一下find的值是不是大于0即可。</p>
<h2 id="路旁的树"><a href="#路旁的树" class="headerlink" title="路旁的树"></a>路旁的树</h2><p>一条数轴，相当于一个一维数组。<br>维度这个概念其实是与数轴相关的。<br>如果平面直角坐标系的话一般就会用二维数组，<br>像天梯赛模拟题的炎爆那道题</p>
<p>思路是，首先把每个元素初始化成2<br>注意今天上午老师讲的那个错误，<br>如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">1001</span>] = &#123;<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<p>不要犯这种错误。<br>正确的是用for循环把n个元素的值赋为2</p>
<p>这题应该挺简单的。<br>也就是多次下把这个区间上的元素全部<strong>降为0</strong>。<br>（注意不是-2，这样区间重叠就成负的了。）</p>
<p>然后再定义一个sum变量，再一个一个地加。<br>最后输出值即可。<br>代码如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, N, sum = <span class="number">0</span>, x, y;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">1001</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">array</span>[i] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x - <span class="number">1</span>;i &lt;= y - <span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">array</span>[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += <span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="按分数段统计学生人数"><a href="#按分数段统计学生人数" class="headerlink" title="按分数段统计学生人数"></a>按分数段统计学生人数</h2><p>简单的循环题，但是被强行地转成了数组题。<br>如果输入的t在输入成绩之前这就是循环了，我们都比较擅长。<br>直接输入数据，然后用for循环一个一个比对，<br>造一个初始值为0的变量，然后如果大于等于那个值就加一。<br>最后输出就好。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, gradelimit, num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">101</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;gradelimit);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i] &gt;= gradelimit) num += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="两道比较难的题目"><a href="#两道比较难的题目" class="headerlink" title="两道比较难的题目"></a>两道比较难的题目</h1><h2 id="1-区间元素和"><a href="#1-区间元素和" class="headerlink" title="1.区间元素和"></a>1.区间元素和</h2><p>这道题难在判断的条件多，<br>我在做的时候没有想到left与right小于0的情况，<br>所以没有做对，但是后来结合志鹏的解答也给出了简单点的答案。<br>但是不太好理解，你们要是觉得不好懂看志鹏的就好。<br>虽然用的是C++，你们看条件就好。</p>
<p><img src="/img/22cf517c3686de1119cf1f156160bd4.jpg" alt="志鹏同学的答案"><br>（std::cin就相当于我们的scanf，std::cout就相当于我们的printf）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, left, right;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">101</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;left, &amp;right);</span><br><span class="line">    <span class="keyword">if</span>(left &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = left;i &lt;= right;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; n &amp;&amp; i &gt;= <span class="number">0</span>)</span><br><span class="line">                sum += <span class="built_in">array</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确保left是小于n的，那么两个集合就一定有交集。<br>然后保证加的是在0到n - 1上的元素（数组内的）。</p>
<h2 id="找出旷课的人"><a href="#找出旷课的人" class="headerlink" title="找出旷课的人"></a>找出旷课的人</h2><p>先放代码，直播讲</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i;j &lt; n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                t = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m, n, flag, count = <span class="number">0</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> array1[<span class="number">10001</span>];</span><br><span class="line">    <span class="type">int</span> array2[<span class="number">10001</span>];</span><br><span class="line">    <span class="type">int</span> array3[<span class="number">10001</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m, &amp;n);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;array1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;array2[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(array1[i] == array2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            array3[l] = array1[i];</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;good\n&quot;</span>); </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Sort(array3, l);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; l;i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, array3[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一次模块化的实践，但我当时很怕时间超限。。<br>由几个部分组成<br>判断相等-加入数组-排序（冒泡）-输出。</p>
<h2 id="宿舍的选择"><a href="#宿舍的选择" class="headerlink" title="宿舍的选择"></a>宿舍的选择</h2><p>很简单的一道题，关于long long，只是为了防止越界吧。<br>判断宿舍可住人数与目前的人数的差，然后与学长的人数相比就好。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,n,p,q;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;p,&amp;q);</span><br><span class="line">        <span class="keyword">if</span>((q - p) &gt; n)</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后说说，这几道题还是很好地帮助我们锻炼了循环那边的知识<br>也帮我们抓起来了现在刚学的数组，<br>通过写题也得到了一些数学模型上的思考，挺好的。</p>
]]></content>
      <tags>
        <tag>C语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Kiss记录(From 2024.2.19)</title>
    <url>/2023/11/20/Kis/</url>
    <content><![CDATA[<h1 id="总体网站集合"><a href="#总体网站集合" class="headerlink" title="总体网站集合"></a>总体网站集合</h1><blockquote>
<p>1.菜鸟教程 <a href="http://www.runoob.com/">www.runoob.com</a><br>2.空梦博客 <a href="http://www.kmar.top/">www.kmar.top</a><br>3.昨日学长的B站号 [@zyoobn]<br>学长的CSDN [@郑轻大不知名]<br>4.编程爱好者协会 <a href="http://www.godyu.com/">www.godyu.com</a><br>B站直播号 [@郑轻编程爱好者协会]</p>
</blockquote>
<p>看来我作为一个新人菜狗是不配加入郑轻编程爱好者协会了<br>那网站上没法发帖子，所以我还是自己想办法建个博客吧。</p>
<span id="more"></span>

<p>————–分割线——————-</p>
<blockquote>
<p>发现这个记录的你算是获得了我每天生活的窥视权，<br>可以借鉴，当然不建议你抄，每个人都有自己的生活。<br>下面的记录来自于A是传奇老师的Kiss模型。<br>也就是Keep、Improve、Start、Stop这四个方面，<br>用来记录并评估我日常的生活状态，找到我们生活中所展现的能力。<br>记录开始时间为2.19日，是打卡，<br>但是不希望因为外面人能看到所以给到自己压力，打卡不下去。<br>另外我的目标是游戏行业，我深思熟虑过，调研了很多东西。<br>另外需要通过考研路径来更换城市到上海（Mihoyo！）<br>要是想聊一聊来找我也好 :)</p>
</blockquote>
<h2 id="二月十九日-大风、有雨、清爽"><a href="#二月十九日-大风、有雨、清爽" class="headerlink" title="二月十九日 大风、有雨、清爽"></a>二月十九日 大风、有雨、清爽</h2><p><img src="/img/Feb19th.jpg" alt="小茶杯到货咯"></p>
<p><strong>坚持</strong>：</p>
<ul>
<li>坚持学习C++。</li>
<li>坚持学习练习吉他。</li>
<li>坚持今日一个主线的游戏时间。<br><strong>改进</strong>：</li>
<li>改进只有编程与游戏的生活。</li>
<li>改进每天晚睡的生活。 - 23：00之前必须睡。<br><strong>开始</strong>：</li>
<li>开始投入额外精力在执行学习路径上。<br><strong>停止</strong>：</li>
<li>停止意淫</li>
</ul>
<p>另附前一天的调整：<br>尽快推进C++学习进度到STL，<br>尽快应用其中的数据结构。</p>
<h2 id="二月二十日-早阴天，晚冰雹，寒风吹。"><a href="#二月二十日-早阴天，晚冰雹，寒风吹。" class="headerlink" title="二月二十日 早阴天，晚冰雹，寒风吹。"></a>二月二十日 早阴天，晚冰雹，寒风吹。</h2><p><img src="/img/Feb20th.jpg" alt="外边还是挺冷的。"></p>
<p><strong>坚持</strong><br>坚持学习C++语言<br>坚持练习吉他弹唱《童年》</p>
<p><strong>改进</strong><br>改进了之前的学习方式，<br>加入回顾与总结知识点。</p>
<p><strong>开始</strong><br>开始总结之前的编程知识点<br>开始6点之内起床。<br>开始玩崩坏三</p>
<p><strong>结束</strong><br>结束肝原神，会有很长一段时间</p>
<h2 id="二月二十一日-大雪覆地，美不胜收。"><a href="#二月二十一日-大雪覆地，美不胜收。" class="headerlink" title="二月二十一日 大雪覆地，美不胜收。"></a>二月二十一日 大雪覆地，美不胜收。</h2><p><img src="/img/Feb21st.jpg" alt="大雪，想必郑州也是这样吧，快开学了。"></p>
<p><strong>坚持</strong><br>坚持学习C++<br>坚持练习吉他</p>
<p><strong>改进</strong><br>有走出去感受天气，不再困在家里</p>
<p><strong>开始</strong><br>开始原神与崩三一起玩，原神完任务，崩三攒钻石<br>开始加快学习C++的脚步。</p>
<p><strong>停止</strong><br>停止23点之前睡：为了改娜维娅PPT<br><img src="/img/nvyppt.png" alt="受凹凸世界动画启发搞的"></p>
<h2 id="二月二十二日-雪冰交加，寸步难行"><a href="#二月二十二日-雪冰交加，寸步难行" class="headerlink" title="二月二十二日 雪冰交加，寸步难行"></a>二月二十二日 雪冰交加，寸步难行</h2><p><img src="/img/Feb22nd.jpg" alt="my studio"></p>
<p><strong>坚持</strong><br>坚持晚上23点之前睡觉<br>坚持学习C++<br>坚持练习吉他</p>
<p><strong>改进</strong><br>改进玩游戏缺乏目标<br>+游戏时间，-空白时间</p>
<ul>
<li>原神: 角色突破养成</li>
<li>崩3: 多赚钻石抽角色</li>
</ul>
<p>改进学习C++没有针对于原初目的：<br>学习STL。</p>
<p><strong>开始</strong><br>开始以准确的方式记录KISS。<br>以平面直角坐标系来，x轴好与不好，y轴持续与非持续<br>1-4象限 keep improve stop start</p>
<p>开始参照网课自我学习吉他。</p>
<p>开始问学长问题，对自己学的知识反思，加深理解。</p>
<h2 id="二月二十三日-比较开心的一天"><a href="#二月二十三日-比较开心的一天" class="headerlink" title="二月二十三日 比较开心的一天?"></a>二月二十三日 比较开心的一天?</h2><p><img src="/img/Feb23rd.jpg" alt="Fireworks!"></p>
<p><strong>坚持</strong><br>坚持晚上23点之前睡觉<br>坚持晚上规律洗漱<br>坚持学习C++<br>坚持练习吉他</p>
<p><strong>改进</strong><br>改进只学习少实践的学习风格:学完STL去做了题。</p>
<p><strong>开始</strong><br>开始接触并学习STL模板库<br>开始做编程题<br>开始用笔记笔记，记忆效果要好于打字</p>
<p>开始从外界回应中找到内心的平衡：<br>别人对你的表现或者问题严格或者冷漠，是因为他们期望你做得更好，<br>但不要反过来认为自己不好。</p>
<h2 id="二月二十四日-元宵，但在家的最后一天"><a href="#二月二十四日-元宵，但在家的最后一天" class="headerlink" title="二月二十四日 元宵，但在家的最后一天"></a>二月二十四日 元宵，但在家的最后一天</h2><p><img src="/img/Feb24th.jpg" alt="* 温暖的感觉"></p>
<p><strong>坚持</strong><br>坚持晚上23点睡觉<br>坚持晚上规律洗漱<br>坚持学习C++(STL)<br>坚持练习吉他</p>
<p><strong>开始</strong><br>开始深度学习STL<br>开始晚上22:30之前学习<br>开始准备以后的学习生活</p>
<p><strong>结束</strong><br>结束寒假在家。</p>
<h2 id="二月二十五日-挺自律的一天"><a href="#二月二十五日-挺自律的一天" class="headerlink" title="二月二十五日 挺自律的一天"></a>二月二十五日 挺自律的一天</h2><p><img src="/img/Feb25th.jpg" alt="收拾好的小桌子"></p>
<p><strong>坚持</strong><br>坚持晚上23点之前睡觉<br>坚持晚上规律洗漱<br>坚持练习吉他<br>坚持学习C++(STL)</p>
<p><strong>改进</strong><br>改进莫名感到自卑的内心想法: </p>
<blockquote>
<p>想要放松下就放松下<br>方向明确，在做该做的事情，就没有啥好自卑的<br>各个人的方向不一样。<br>坚持做自己要做的事情，慢慢地改进生活。</p>
</blockquote>
<p>优化了找人提问的步骤：优先使用AI找寻问题的答案。	</p>
<p><strong>开始</strong><br>开始即时查看微Q信息<br>开始筹备预习明天课程<br>开始积极社交<br>开始学习PS</p>
<p><strong>结束</strong><br>结束在家模式<br>结束即时的不开心</p>
<h2 id="二月二十六日-Well-Assembled-Day"><a href="#二月二十六日-Well-Assembled-Day" class="headerlink" title="二月二十六日 Well-Assembled Day"></a>二月二十六日 Well-Assembled Day</h2><p><img src="/img/Feb26th.jpg" alt="温暖的茶水"></p>
<p><strong>坚持</strong><br>坚持预习课程<br>坚持练习吉他<br>坚持规律洗漱<br>坚持学习Ps</p>
<p><strong>改进</strong><br>根据老师的上课建议改进了英语学习方案：<br>加入听写，写作方式。</p>
<p><strong>开始</strong><br>开始以中国大学MOOC为平台学习电子技术<br>开始听写单词并预习英语。<br>开始规划当下课程预习方案。</p>
<p><strong>结束</strong><br>结束23点睡觉: 玩原神与讨论游戏，明日改回来</p>
<h2 id="二月二十七日-忙碌的一天"><a href="#二月二十七日-忙碌的一天" class="headerlink" title="二月二十七日 忙碌的一天"></a>二月二十七日 忙碌的一天</h2><p><img src="/img/Feb27th.jpg" alt="体育课随手拍"></p>
<p><strong>坚持</strong><br>坚持学习Ps<br>坚持练习吉他<br>坚持预习课程<br>坚持规律洗漱<br>坚持23点睡觉<br>坚持每日早晨英语学习</p>
<p><strong>开始</strong><br>开始跑步:今日约2.4Km，13000步数，很棒。<br>开始规划决策树。</p>
<p><strong>结束</strong><br>结束编程学习</p>
<h2 id="二月二十八日-差点就输过了情绪"><a href="#二月二十八日-差点就输过了情绪" class="headerlink" title="二月二十八日 差点就输过了情绪"></a>二月二十八日 差点就输过了情绪</h2><p><img src="/img/Feb28th.jpg" alt="早晨三个闹钟没给我叫起来，也可能是没响"></p>
<p><strong>坚持</strong><br>坚持23点之前睡觉，并规律洗漱。<br>坚持练习吉他：目前想要尝试新曲子。<br>坚持预习明日课程，复习知识，画思维导图。<br>坚持学习PS</p>
<p><strong>改进</strong><br>改进之前对于安全边际给予太少的缺点：<br>今天因为晚起很多事没有很早做，一些事没做，导致情绪有波动，很多事心态上有阻碍。<br>无需绷紧脑弦，只是最近确实事情有点多，做自己能做的就好。</p>
<p><strong>开始</strong><br>开始写入党申请书<br>开始有意向去主动社交<br>开始感到焦虑：竞争与对比焦虑、</p>
<h2 id="二月二十九日-写了一天入党申请书"><a href="#二月二十九日-写了一天入党申请书" class="headerlink" title="二月二十九日 写了一天入党申请书"></a>二月二十九日 写了一天入党申请书</h2><p><img src="/img/Feb29th.png" alt="累。"></p>
<p><strong>坚持</strong><br>坚持练习吉他<br>坚持23点之前睡觉，规律洗漱</p>
<p><strong>改进</strong><br>改进了最近的比较想法:<br>脑子里不需要想那么多，我们的方向真的不一样。</p>
<p><strong>开始</strong><br>开始主动社交</p>
<p><strong>结束</strong><br>结束写入党申请书<br>结束预习课程<br>结束PS学习<br>（事情多尽量周末或者明天开始拾起来）</p>
<h2 id="三月一日-调整好了心态，一身轻松"><a href="#三月一日-调整好了心态，一身轻松" class="headerlink" title="三月一日 调整好了心态，一身轻松"></a>三月一日 调整好了心态，一身轻松</h2><p><img src="/img/Mar2nd.png" alt="为&quot;挑战杯&quot;做的游戏场景"></p>
<p><strong>坚持</strong><br>坚持进行课程预习复习<br>坚持规律洗漱<br>坚持练习吉他</p>
<p><strong>改进</strong><br>再次改进最近的心态问题：<br>从自己的想法后面推演心理，<br>然后使用事实与观点的观点来判断这件事该不该这样想</p>
<p><strong>开始</strong><br>开始主动社交<br>开始尝试新曲子<br>开始准备“挑战杯”比赛</p>
<p><strong>结束</strong><br>结束23点睡觉：<br>原因今晚准备挑战杯累 - 玩星穹 - 整理物理课程内容<br>明日改进一下。</p>
<h2 id="三月二日-做了不少事情，很累也很充实"><a href="#三月二日-做了不少事情，很累也很充实" class="headerlink" title="三月二日 做了不少事情，很累也很充实"></a>三月二日 做了不少事情，很累也很充实</h2><p><img src="/img/Mar2nd1.png" alt="挑战杯PPT的封面"></p>
<p><strong>坚持</strong><br>坚持规律洗漱<br>坚持练习吉他<br>坚持推进挑战杯的进程</p>
<p><strong>开始</strong><br>开始去澡堂洗澡<br>开始体会协作的乐趣<br>开始画像素画</p>
<p><img src="/img/Mar2nd2.png" alt="可莉可爱捏"></p>
<p>开始设计PPT封面<br>开始P图</p>
<p><strong>结束</strong><br>结束对于英语的早晨学习：明天的重点要移到作业以及学习上</p>
<h2 id="三月三日-化急为友"><a href="#三月三日-化急为友" class="headerlink" title="三月三日 化急为友"></a>三月三日 化急为友</h2><p>今天没有配图，因为是非常充实与繁忙的一天。</p>
<p><strong>坚持</strong><br>坚持练习吉他<br>坚持规律洗漱<br>坚持23:30之前睡觉<br>坚持推进挑战杯：PPT设计、文本写作</p>
<p><strong>改进</strong><br>改进了自己对于C++做题的态度：<br>因为以后的就业需要使用相关算法<br>以及对C++的理解也能够帮助对于C#的学习<br>最后，这是第一次突破一件事情，可以作为未来自学的参考</p>
<p><strong>开始</strong><br>开始做C语言题<br>开始预习单词以及做U校园题目</p>
<p><strong>结束</strong><br>制定完毕了“闲时学习指南”的参考框架。</p>
<h2 id="三月四日-有情绪波动，有点大，但用学习度过了。"><a href="#三月四日-有情绪波动，有点大，但用学习度过了。" class="headerlink" title="三月四日 有情绪波动，有点大，但用学习度过了。"></a>三月四日 有情绪波动，有点大，但用学习度过了。</h2><p><img src="/img/Mar4th.png" alt="小游戏快做完了"></p>
<p><strong>坚持</strong><br>坚持规律洗漱<br>坚持推进挑战杯<br>坚持复习与预习课程</p>
<p><strong>结束</strong><br>结束练习吉他<br>结束学习C语言<br>结束23:30之前睡觉</p>
<h2 id="三月五日-彻底摆脱负担。"><a href="#三月五日-彻底摆脱负担。" class="headerlink" title="三月五日 彻底摆脱负担。"></a>三月五日 彻底摆脱负担。</h2><p><img src="/img/Mar5th.png" alt="Mile Stone."></p>
<p><strong>坚持</strong><br>坚持规律洗漱<br>坚持尽早睡觉<br>坚持推进挑战杯课程<br>坚持预习课程</p>
<p><strong>改进</strong><br>改进过去会因为一些原因心态不平稳的情况：<br>别人的看法咋样我不管，我要过好自己的生活。</p>
<p><strong>开始</strong><br>开始跑步 - 步数12000步</p>
<h2 id="三月六日-挺愉快的一天"><a href="#三月六日-挺愉快的一天" class="headerlink" title="三月六日 挺愉快的一天"></a>三月六日 挺愉快的一天</h2><p><img src="/img/Mar6th.jpg" alt="在微信读书上发现了这本书，真的好有意思"></p>
<p><strong>坚持</strong><br>坚持尽早睡觉<br>坚持规律洗漱<br>坚持预习课程</p>
<p><strong>改进</strong><br>学会维持专注状态，不会因为自我觉察而打破。</p>
<p><strong>开始</strong><br>开始阅读书籍<br>开始练习编程题<br>开始练习吉他</p>
<h2 id="三月七日-有时不知道做啥，有时就突然知道了"><a href="#三月七日-有时不知道做啥，有时就突然知道了" class="headerlink" title="三月七日 有时不知道做啥，有时就突然知道了"></a>三月七日 有时不知道做啥，有时就突然知道了</h2><p><img src="/img/Mar7th.jpg" alt="折花，一个小时，没折出来"></p>
<p><strong>坚持</strong><br>坚持23:30之前睡觉<br>坚持练习吉他<br>坚持学习编程<br>坚持学习课程</p>
<p><strong>改进</strong><br>改进了最近无所事事的心态，开始做自己方向上的事情。</p>
<p><strong>开始</strong><br>开始玩折纸。<br>开始学习算法</p>
<p><strong>结束</strong><br>结束意淫</p>
<h2 id="三月八日-有点难受，做着自己喜欢的事情，总体称之为幸福。"><a href="#三月八日-有点难受，做着自己喜欢的事情，总体称之为幸福。" class="headerlink" title="三月八日 - 有点难受，做着自己喜欢的事情，总体称之为幸福。"></a>三月八日 - 有点难受，做着自己喜欢的事情，总体称之为幸福。</h2><p><img src="/img/Mar8th.jpg" alt="与周围格格不入的白玫瑰花。"></p>
<p>C++与学算法之间的抉择 – 明早写文预告。</p>
<p><strong>坚持</strong><br>坚持23:30之前睡觉<br>坚持规律洗漱<br>坚持练习吉他<br>坚持学习编程题目<br>坚持预习课程<br>坚持读有趣的书</p>
<p><strong>改进</strong><br>改进了这几天安排不好自己的事情的缺点，<br>开始使用思维导图列出选项。</p>
<p>改进老是熬夜的缺点：开22:00的闹钟</p>
<p><strong>开始</strong><br>开始体素建模，参考滚动的天空。</p>
<p><img src="/img/Mar8th2.png" alt="薯条"></p>
<p><img src="/img/Mar8th.png" alt="冰激凌球投掷机"></p>
<h2 id="三月九日-三月十日-遇到了一些有趣的人，做了一些有趣的事。"><a href="#三月九日-三月十日-遇到了一些有趣的人，做了一些有趣的事。" class="headerlink" title="三月九日 - 三月十日 遇到了一些有趣的人，做了一些有趣的事。"></a>三月九日 - 三月十日 遇到了一些有趣的人，做了一些有趣的事。</h2><p><img src="/img/Mar10th.jpg" alt="昨晚在干的事情，持续四次，每次一小时，睡不着。"></p>
<p><strong>坚持</strong><br>坚持练习吉他<br>坚持3D建模<br>坚持学习课程<br>坚持规律作息（除九日这一天）</p>
<p><strong>改进</strong><br>心态开始好起来，改进了原来害怕交往的态度。<br>大胆起来，敢喝酒了。</p>
<p><strong>结束</strong><br>结束肝原神与星穹，开始怀旧。<br>结束学C语言编程(调整心态ing)</p>
<p><img src="/img/Mar9th.jpg" alt="参与了一个party, 昨晚的奥尔良鸡腿"></p>
<h2 id="三月十日-A-busy-day-with-heavy-heart"><a href="#三月十日-A-busy-day-with-heavy-heart" class="headerlink" title="三月十日 A busy day with heavy heart"></a>三月十日 A busy day with heavy heart</h2><p>在学习，暂时没图喽。</p>
<p><strong>坚持</strong><br>坚持练习吉他<br>坚持学习课程<br>坚持规律作息与喝牛奶</p>
<p><strong>改进</strong><br>改进心情，这几天因为想谈恋爱所以心里老是胡思乱想（你不会想知道我在想什么的。）<br>心里想法一直影响我的心态，上课也上不安稳。<br>上了教学楼的阳台开导自己，终于把心情回回来了。</p>
<p><strong>开始</strong></p>
<p>开始阅读《被讨厌的勇气》，<br>《云边有个小卖部》还会看，但是有点刀，也快看完了，不太舍得看了。</p>
<p>开始尝试22:30之前睡</p>
<p><strong>结束</strong><br>结束建模：做的事情是浮动的，这周课很多，好好安排。</p>
<h2 id="三月十一日-Things’re-getting-harder-and-harder"><a href="#三月十一日-Things’re-getting-harder-and-harder" class="headerlink" title="三月十一日 Things’re getting harder and harder"></a>三月十一日 Things’re getting harder and harder</h2><p>在学习，暂时没图喽。</p>
<p><strong>坚持</strong><br>坚持练习吉他<br>坚持预习课程<br>坚持规律作息与喝牛奶<br>坚持读书与调整心态</p>
<p><strong>改进</strong><br>改进心情，在《被讨厌的勇气》中获得了很多的启发<br>情绪是自己捏造出来的。<br>愤怒是交流的一种工具，你可以使用也可以不用。<br>避免幻想，想想怎么用好自己已经有的。<br>摆脱竞争，避免权利之战，把所有人看成伙伴，就可能摆脱人际交往的烦恼。<br>一切烦恼都来自人际交往。</p>
<p><strong>开始</strong><br>尝试玩魔方<br>开始主动社交</p>
<h2 id="三月十二日-The-last-tiring-day"><a href="#三月十二日-The-last-tiring-day" class="headerlink" title="三月十二日 The last tiring day."></a>三月十二日 The last tiring day.</h2><p><strong>坚持</strong><br>坚持预习课程<br>坚持喝牛奶<br>坚持读书以及调节心态</p>
<p><strong>改进</strong><br>改进上课状态：不再紧绷状态，减轻竞争压力。<br>改进心态：共同体意识以及划分课题。</p>
<p><strong>开始</strong><br>开始主动交往<br>开始学习编程题</p>
<p><strong>结束</strong><br>结束练习吉他。</p>
<blockquote>
<p>读书：</p>
</blockquote>
<ol>
<li><p>横向关系与向别人学习有关系吗？<br>我向别人学习是我的课题，别人教我是他的课题。<br>我们都有自己的选择，都有权利决定这个事件要不要发生。<br>向他人学习不代表一种纵向。</p>
</li>
<li><p>如何做出贡献？</p>
</li>
<li><p>如何面对冲突？</p>
</li>
<li><p>如何面对主观孤独感</p>
<ol>
<li>活出自我的代价 - 敢于被讨厌、被评价。</li>
<li>信赖、共同体意识与相处和睦之间没有关系。</li>
<li>重要的是，你怎么看待与解释自己现在的状态。</li>
</ol>
</li>
<li><p>认为不喜欢一个人，你觉得这个人是错的吗？<br> 一个人首先做事没有纯粹做坏事的。<br> 不喜欢的理由 - 对方目的。<br> 不开心是因为这个人 - 这个想法是在推脱责任。<br> 没有人需要按照你的期待生活。<br> 这种想法不是在挑起权力之争，你与他都是平等的横向关系。</p>
<p> 讨厌的感觉是一种借口。<br> 认为某些东西没有了、消失了、改变了，事情就会全盘转变。<br> 没有活在当下，想想要达到事情转变的效果需要怎么办。</p>
</li>
<li><p>如何谈论平等？<br>平等的选择权利，平等地看待自己现在状态，平等地按照自己的想法生活。</p>
</li>
</ol>
<h2 id="三月十二日-得到启发，开始应用与实践。"><a href="#三月十二日-得到启发，开始应用与实践。" class="headerlink" title="三月十二日 得到启发，开始应用与实践。"></a>三月十二日 得到启发，开始应用与实践。</h2><p><strong>坚持</strong><br>坚持学习课程<br>坚持阅读</p>
<p><strong>改进</strong><br>改进了自己看待事物的方式，注重当下而不是其他时候，注重当下的动作而不是以后、过去怎么样。</p>
<p><strong>开始</strong><br>开始玩Terraria灾厄模组。</p>
<h2 id="三月十七日-Happily-doing-myself"><a href="#三月十七日-Happily-doing-myself" class="headerlink" title="三月十七日 Happily doing myself"></a>三月十七日 Happily doing myself</h2><p><img src="/img/Mar172.png" alt="在一首歌的歌词里看到的，很有感慨"></p>
<p><strong>坚持</strong><br>坚持规律作息与洗漱<br>坚持练习吉他<br>坚持学习编程<br>坚持预习课程<br>坚持读书与调整心态</p>
<p><strong>改进</strong><br>主动社交<br>强化了自己梦想的决心</p>
<p><strong>开始</strong><br>开始学习PS</p>
<p><img src="/img/Mar17th.png" alt="做的霓虹灯，但是没到想的效果"></p>
<p>开始早睡早起</p>
<h2 id="三月十八日-有点小失落，仍然胡思乱想"><a href="#三月十八日-有点小失落，仍然胡思乱想" class="headerlink" title="三月十八日 有点小失落，仍然胡思乱想"></a>三月十八日 有点小失落，仍然胡思乱想</h2><p><img src="/img/Mar18th.jpg" alt="感冒喽，999"></p>
<p><strong>坚持</strong><br>坚持早睡规律作息<br>坚持学习课程<br>坚持预习<br>坚持读书与调整心态</p>
<p><strong>结束</strong><br>结束学习编程<br>结束练习吉他<br>结束学习PS</p>
<h2 id="三月十九日-进大学以来第一次发烧"><a href="#三月十九日-进大学以来第一次发烧" class="headerlink" title="三月十九日 进大学以来第一次发烧"></a>三月十九日 进大学以来第一次发烧</h2><p><img src="/img/Mar19th.jpg" alt="处方全是没见过的药"></p>
<p><strong>坚持</strong><br>坚持早睡早起<br>坚持课后复盘<br>坚持读书与调整心态</p>
<p><strong>结束</strong><br>结束上形势与政策课<br>结束预习课程：今晚的感冒症状严重，很难受。</p>
<h2 id="三月二十日-总归过去了这一天，以后就好多了"><a href="#三月二十日-总归过去了这一天，以后就好多了" class="headerlink" title="三月二十日 总归过去了这一天，以后就好多了"></a>三月二十日 总归过去了这一天，以后就好多了</h2><p><strong>坚持</strong><br>坚持实践阿德勒理论与调整心态<br>坚持课后复盘<br>坚持预习课程<br>坚持读书</p>
<p><strong>改进</strong><br>改变了对世界的看法：<br>世界对我是安全的，我要无条件地信赖他人，无论他人配不配合</p>
<h2 id="三月二十一日-尝试活出自我的一天"><a href="#三月二十一日-尝试活出自我的一天" class="headerlink" title="三月二十一日 尝试活出自我的一天"></a>三月二十一日 尝试活出自我的一天</h2><p><strong>坚持</strong><br>坚持读书与调整心态<br>坚持学习课程</p>
<p><strong>开始</strong><br>开始早晨听写英语<br>开始练习吉他<br>开始学习编程算法</p>
<p><strong>结束</strong><br>结束读《获得幸福的勇气》</p>
<h2 id="三月二十二日-事多，但总体放松，能活出自己，能放开"><a href="#三月二十二日-事多，但总体放松，能活出自己，能放开" class="headerlink" title="三月二十二日 事多，但总体放松，能活出自己，能放开"></a>三月二十二日 事多，但总体放松，能活出自己，能放开</h2><p><img src="/img/Mar21st.jpg" alt="今日偶然想到，特别好听"></p>
<p><strong>坚持</strong><br>坚持读书与调整心态<br>坚持预习与学习课程</p>
<p><strong>改进</strong><br>意识到自己很多动作是应激反应，开始调整提醒。</p>
<p><strong>开始</strong><br>开始读《你要像鸟飞往你的山》</p>
<p><strong>结束</strong><br>结束学习算法<br>结束练习吉他</p>
<h2 id="三月二十六日-生日快乐，亲爱的我"><a href="#三月二十六日-生日快乐，亲爱的我" class="headerlink" title="三月二十六日 生日快乐，亲爱的我"></a>三月二十六日 生日快乐，亲爱的我</h2><blockquote>
<p>手机停机了，图片传不过来，没拍蛋糕的照片</p>
</blockquote>
<p><strong>坚持</strong><br>坚持读书与调整心态<br>坚持练习吉他<br>坚持学习课程<br>坚持复盘</p>
<p><strong>改进</strong><br>调节自己对于应激反应的认识，<br>开始从自己身体的微反应来认识自己</p>
<p><strong>开始</strong><br>开始尽力按照自己意愿生活<br>开始理解自己，开始接受自己，开始解决问题。</p>
]]></content>
      <tags>
        <tag>学习资源</tag>
      </tags>
  </entry>
  <entry>
    <title>直播内容复盘-排序与交换</title>
    <url>/2023/11/20/%E7%9B%B4%E6%92%AD%E5%86%85%E5%AE%B9%E5%A4%8D%E7%9B%98-%E6%8E%92%E5%BA%8F%E4%B8%8E%E4%BA%A4%E6%8D%A2/</url>
    <content><![CDATA[<p>昨天晚上的重点是归并排序的算法，虽然我们还没有学到函数递归<br>我还需要再联系联系，不太能独立写出来。<br>那就整理一下昨天晚上听到的一些点.</p>
<span id="more"></span>

<h2 id="qsort函数的用法以及swap函数"><a href="#qsort函数的用法以及swap函数" class="headerlink" title="qsort函数的用法以及swap函数"></a>qsort函数的用法以及swap函数</h2><blockquote>
<p>首先声明，需要添加stdlib库</p>
</blockquote>
<p>上定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">void</span> *base, <span class="type">size_t</span> nitems, <span class="type">size_t</span> size, <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span>*))</span></span><br></pre></td></tr></table></figure>

<p>这个定义有点太复杂，我们可以把它特殊化处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(排序数组,排序个数，<span class="keyword">sizeof</span>(数组数据类型)，排序规则(cmp))</span>;</span><br></pre></td></tr></table></figure>

<p>这样的话就明了了，我们输入一个数组，经过qsort函数的的一通操作，返回一个排过序的数组。</p>
<p>因为我们学习过全局变量，所以这个注意事项也好懂</p>
<blockquote>
<p>这个数组必须是全局的，即必须在预处理之后，主函数之前定义。</p>
</blockquote>
<p>因为这样数组才对qsort函数“可见“。</p>
<p>cmp函数需要自己写，写的思路用到了指针，不过照抄就好。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span> <span class="params">(<span class="type">const</span> <span class="type">void</span> * a, <span class="type">const</span> <span class="type">void</span> * b)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">   <span class="keyword">return</span> ( *(<span class="type">int</span>*)a - *(<span class="type">int</span>*)b );  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先强转为对应类型的指针，然后再相减，</span></span><br><span class="line"><span class="comment">//a-b为从小到大，b-a为从大到小</span></span><br></pre></td></tr></table></figure>

<p>如果是字符串排序的话，需要用到strcmp函数，之前已经讲过。</p>
<p>所以这就是qsort库函数的用法。</p>
<p>还有是swap函数，可以在我们写排序的时候用到。<br>可以交换数组内的数据，非常好用。<br>形式如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">swap(&amp;a,&amp;b);</span><br></pre></td></tr></table></figure>
<p>到用的时候可以把a和b换成数组的元素，如array[1].<br>可以便捷地实现交换。<br>这个函数实际上自己写也可以。</p>
<p>这就是昨天晚上在学长的直播中学到的除了归并排序外的东西。</p>
]]></content>
      <tags>
        <tag>C语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>输入与输出</title>
    <url>/2023/11/20/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p>从字符串那里，包括之前听C语言群里大佬说<br>也获取到了一些关于printf与scanf的更多形式与更多玩法的知识。<br>今天也一并分享给大家。<span id="more"></span></p>
<h2 id="1-stdio-h中的更多的函数"><a href="#1-stdio-h中的更多的函数" class="headerlink" title="1.stdio.h中的更多的函数"></a>1.stdio.h中的更多的函数</h2><p>(关于stream与参数列表的不讲，还没学到。)</p>
<p>类似的，应该你们也听说过，这里列一下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="一-函数定义读法"><a href="#一-函数定义读法" class="headerlink" title="一.函数定义读法"></a>一.函数定义读法</h3><p>这里是纯纯的函数函数定义，看起来可能很抽象，<br><strong>没关系，我会出手。</strong></p>
<p>总体上一讲，以后见到<strong>前面带f</strong>的一般是有关<code>stream</code>的<br><strong>带v的</strong>一般是有关<code>参数列表</code>的，<br>以后看到学长写类似的函数就知道该多学习了!😂</p>
<p>对于以后看这样的函数定义，首先看[返回值类型]，<br>一般是，返回处理的结果或者返回一个数值（int&#x2F;double)</p>
<p>然后如果看不懂函数名的话，<br>先看[括号中的形式参数]，知道我们需要输入的是什么东西。</p>
<blockquote>
<p>比如这两个函数中<br><strong>const</strong>是数据类型的修饰符，表示常量。<br>char* 表示字符串、后面的是形式参数名，不需要管。</p>
</blockquote>
<p>最后，通过[看实例]与函数的[概述]得知函数的作用。<br>在菜鸟教程里都一条一条地列出来的，每一条都有实例。</p>
<p>在最后一篇文章的最后会给大家列出来用过的这些网站。</p>
<h3 id="二-浅谈没讲过的sscanf-函数"><a href="#二-浅谈没讲过的sscanf-函数" class="headerlink" title="二.浅谈没讲过的sscanf()函数"></a>二.浅谈没讲过的sscanf()函数</h3><p>上一篇我们已经讲过sprintf函数了，知道了它可以用来写入字符串。<br>现在就来讲一讲相对的sscanf函数。</p>
<p>不多说，直接上函数定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>首先看<strong>返回值</strong><br>这个函数返回的是一个数值，也就像scanf一样<br>函数返回的是成功赋值与匹配的个数。<br>如果到达文件末尾或者错误返回EOF。</p>
<p>然后看<strong>形参</strong><br>获取的是字符串常量(<code>const char *str</code>)，<br>    这个字符串，是包含着我们想要赋值数据的字符串。<br>写入形式(<code>const char *format</code>)<br>    写入形式相当于格式化符，相当于赋值的顺序）<br>    尽量不要加新的形式。<br>与参数列表(<code>...</code>)。<br>    对应之前的格式化符。<br>关于参数列表，其实简单的说<br>就是我们printf中标准符后边逗号中的内容<br>见下方。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="comment">//后面的a,b,c就是参数列表</span></span><br><span class="line"><span class="comment">//%d的这个字符串就是写入形式的一种形式</span></span><br></pre></td></tr></table></figure>

<p>所以这个函数的<strong>功能</strong>就是</p>
<blockquote>
<p>1.从字符串中获取数据，<br>2.然后赋给格式化符的对应的变量。</p>
</blockquote>
<p>sscanf不需要我们自己输入，在字符串中有就好。</p>
<p>所以更多的惯例自己去菜鸟教程上查就好，<br><strong>建议立即行动，不然一定会忘记。</strong></p>
<h2 id="二-关于我们的输入输出"><a href="#二-关于我们的输入输出" class="headerlink" title="二.关于我们的输入输出"></a>二.关于我们的输入输出</h2><blockquote>
<p>以下内容取自空梦大大的博客<br><a href="https://kmar.top/posts/51c9b0a0/">如何理解c&#x2F;c++中的输入&#x2F;输出函数？ | 山岳库博</a><br>我们这里梳理的是，我们这个阶段可以用到的符号。</p>
</blockquote>
<h3 id="1-关于格式化符与printf、scanf修饰符"><a href="#1-关于格式化符与printf、scanf修饰符" class="headerlink" title="1.关于格式化符与printf、scanf修饰符"></a>1.关于格式化符与printf、scanf修饰符</h3><p>格式化符我们需要知道的如下，之前在题中也出过。<br>    1. %d&#x2F;%lf&#x2F;%f&#x2F;%c 整数、字符、浮点数<br>    2. %s 字符串输入与输出。<br>    3. %x&#x2F;%X - 十六进制整数 或者 %o 八进制整数<br>    4. %%两个百分号一起用可以输出%号，相当于转义了。<br>%%<br>掌握了这些我们就不太用怕需要的数据表示不出来了。<br>现在看来老师教的还是不是很够，第一个都用过时了。</p>
<h2 id="printf修饰符"><a href="#printf修饰符" class="headerlink" title="printf修饰符"></a>printf修饰符</h2><ol>
<li>加数字，右对齐字符宽度。-实例：<code>printf(&quot;%4d&quot;,n);</code></li>
<li>.数字，对于小数表示小数后位数，比如<code>%.3lf</code><br> 对于字符串是打印字符的最大数量<br> 只使用点%.f与%.0f相同。</li>
<li>使用ll表示long long <code>%lld</code></li>
<li>使用l，对于整型表示long int，对于浮点型表示double</li>
<li>各种标记：<ol>
<li>在数字前加符号为左对齐</li>
<li><ul>
<li>是为了把在有符号数开头加’+’或者’-‘。</li>
</ul>
</li>
<li>加0对于多于的字段宽度填充0，如<code>%04d</code><br> 对于1，返回的是0001.<br> 4.加入 * 决定填入数字，<br> 需要在参数列表中新加入一个变量。<br>  常见形式为<code>%*lf</code></li>
</ol>
</li>
</ol>
<h2 id="scanf修饰符"><a href="#scanf修饰符" class="headerlink" title="scanf修饰符"></a>scanf修饰符</h2><ol>
<li><ul>
<li>只读取不赋值，这对于无用数据是有用处的 形式为类似<code>%*d</code><br> d可以任意换，以下的所有实例中的d都可以换成其他类型</li>
</ul>
</li>
<li>同样的加数字为取字段的宽，有多长取多长，别的截掉。</li>
</ol>
<p>这就是最近关于输入输出想和大家分享的内容。</p>
]]></content>
      <tags>
        <tag>C语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>千奇百怪的字符串处理函数</title>
    <url>/2023/11/20/%E5%8D%83%E5%A5%87%E7%99%BE%E6%80%AA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>最近的周赛与直播都涉及了很多我们大多没有学习过的C语言细节问题<br>今天学习了一些关于字符串、输入输出函数的知识，<br>以及整理了一下昨天晚上直播的重点内容 @21级学长zyb<br>希望能够帮到大家</p>
<span id="more"></span>

<h2 id="千奇百怪的字符串处理函数"><a href="#千奇百怪的字符串处理函数" class="headerlink" title="千奇百怪的字符串处理函数"></a>千奇百怪的字符串处理函数</h2><blockquote>
<p>首先声明，此处使用的函数（如图），需要加入<strong>string.h</strong>标准库<br>加入方式如下</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><img src="/img/1.png" alt="图片"></p>
<pre><code> 参考来自菜鸟教程
(https://www.runoob.com/cprogramming/c-strings.html)
</code></pre>
<p>这是我们在平时做题时常用的几个函数，比较易懂。<br>除此之外我还在string.h中为大家多找了几个关于<strong>搜索匹配字符</strong>的。<br>是下面这两个</p>
<p><img src="/img/2.png" alt="图片1"><br><img src="/img/3.png" alt="图片2"><br>（看起来可能参数与返回值都有点吓人，但也就那样。）</p>
<pre><code> 参考来自菜鸟教程
 (https://www.runoob.com/cprogramming/c-standard-library-string-h.html)
</code></pre>
<p>相信作为已经学习过函数知识的我们，已经能够学习这些新的函数了<br>要学习字符串，我们得先拥有一个字符串，字符串的定义方式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义方式</span></span><br><span class="line"><span class="type">char</span> 标识符[字符串长度];</span><br><span class="line"><span class="comment">//标识符即为名字，字符串长度可以省略。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为字符串赋值的方式</span></span><br><span class="line"><span class="type">char</span> <span class="built_in">string</span>[] = <span class="string">&quot;I&#x27;m a string!&quot;</span>;   <span class="comment">//第一种方法</span></span><br><span class="line"><span class="type">char</span> string2[<span class="number">6</span>] = <span class="string">&quot;Hello!&quot;</span>;        <span class="comment">//第二种方法</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> string3[<span class="number">10</span>];                  <span class="comment">//第三种方法</span></span><br><span class="line">gets(string3);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);                    <span class="comment">//第四种，应该是最常用的一种方法</span></span><br><span class="line"><span class="type">char</span> <span class="built_in">string</span>[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;<span class="built_in">string</span>[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//sprintf(被写入字符串,&quot;写入字符串&quot;，格式化符列表)</span></span><br><span class="line"><span class="comment">//括号的后半部分与printf类似，但是它不是为了输出的。</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="built_in">sprintf</span>(string1,<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串输出的方式</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="built_in">string</span>[i]);</span><br><span class="line">	<span class="comment">//此处n也可以不定义，在使用第一或者第二种方式时</span></span><br><span class="line">	<span class="comment">//可以使用strlen函数或者sizeof运算符 - 1来代替</span></span><br><span class="line">	<span class="comment">//len代表length sizeof代表大小，sizeof包含最后的\0，那个不</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所谓的<strong>字符串</strong>，其实就是[由字符组成，以’ \0‘为结束的一维数组]。<br>’\0’标志着字符串输出的结束，\是<strong>转义符号</strong>，为了提示它不是数字0</p>
<blockquote>
<p>注意，对于字符串的scanf都不需要加取地址符&amp;。<br>包括sscanf()，虽然它是把字符串内的东西赋给变量或者其他。<br>和字符串本身无关。</p>
</blockquote>
<p>上面的函数给出了几种给字符串赋值的方式，<br>我觉得你们可能不太好理解的是以下内容：</p>
<ul>
<li>gets()与puts()函数的用法</li>
<li>1000是可以随机的吗</li>
<li>strlen函数以及sizeof的用法</li>
</ul>
<p>这里简单一说</p>
<ol>
<li>gets()就是获取一段字符串，在括号中需要加入参数，<br> 参数为字符串（字符数组）<br> puts是把字符串打印出来<br> 其实这两个相似于字符的getchar与putchar</li>
<li>1000看题目要求，看字符串的最大容量。</li>
<li>strlen是返回字符串的长度，不包含结尾的\0符号，<br> sizeof运算符对于字符串来说，是返回包括\0的长度。<br> 所以sizeof要减一。</li>
</ol>
<p>下面再说一下这些函数的效果。（看图也可。）</p>
<blockquote>
<p>1.strcpy(s1,s2);</p>
</blockquote>
<p>s1与s2是形式参数，代表两个字符串，<br>通过这个函数我们能够覆盖式地把s2复制粘贴到s1上<br>甚至长度不允许也没关系。</p>
<p>关于记忆，str是string的缩写，cpy是copy的缩写，所以strcpy嘛。<br>对于很多的函数是可以通过这种方式记忆的<br>其实用多了就自然记住了。</p>
<blockquote>
<p>2.strcat(s1,s2);</p>
</blockquote>
<p>s1,s2作用不再赘述。<br>把s2连接到s1的末尾，改变s1。<br>可以通过输出看s1的变化，</p>
<blockquote>
<p>3.strlen(s1)<br>返回s1的去掉结尾符号的长度，已经讲过。</p>
</blockquote>
<blockquote>
<p>4.strcmp(s1,s2);<br>从第一个字符开始比较，找到不一样的字符，看哪一个更大，哪个字符串就更大。<br>昨晚在直播中学长讲过了。<br>大小与返回值的关系请见图。</p>
</blockquote>
<blockquote>
<p>5.strpbrk(const char* str1, const char* str2);</p>
</blockquote>
<pre><code>关于常量字符串为什么这样写我还不太明白，我想让群里的大佬给我解释解释。
</code></pre>
<p>分析第一个字符串的字符，与第二个字符串内的字符比对<br>只要找出两个字符串都包含的字符就返回那个字符。</p>
<pre><code>很好理解。
比如，&quot;AABB&quot;与&quot;BCDE&quot;，就会返回B。
</code></pre>
<blockquote>
<p>6.strspn(const char* str1, const char* str2);</p>
</blockquote>
<p>也是分析两个字符串的字符，逐对分析，直到找到两字符串位置一样但不一样的字符。<br>返回那个字符的下标，注意不是字符。</p>
<p>想要给大家说这些的原因是，有些数字的位数处理用字符串可能会更快，<br>比如在周五的练习六题解里的那一道题，去第一位与最后一位为素数。<br>这在我刚开始学习C语言的时候就感觉到了。<br>Python中的字符串处理有很多的内建函数，处理起来很方便。<br>但是C语言中竟然连字符串变量都不能定义，而且定义与赋值起来很麻烦。<br>所以学好字符串还是很有必要的。</p>
<p>还有一个是 @空梦Kmar 的建议<br>尽量使用C标准库函数，这样能够极大地优化程序的效率。<br>详细的建议在他的博客里，第一条就是优先使用库函数。<br><a href="https://kmar.top/posts/51979312/">关于C语言编码的一些建议 | 山岳库博 (kmar.top)</a><br>包括昨晚学长提到的qsort函数，就解决了我们排序数组的问题<br>还有用于交换数组排序的swap函数。<br>所以学习C语言标准库而不是自己写还是很好的，而且很省事。</p>
]]></content>
      <tags>
        <tag>C语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ中的那些小丑行为</title>
    <url>/2023/11/20/OJ%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E5%B0%8F%E4%B8%91%E8%A1%8C%E4%B8%BA/</url>
    <content><![CDATA[<p>在平时做OJ的时候，我们会经常遇到很多不经意间犯的错误，<br>有些时候错得自己像小丑一样。</p>
<p><img src="/img/OJclown.png" alt="My feelings"></p>
<p>我想的是把寻找错误的思路与错误会导致的结果总结一下，给自己以指导。<span id="more"></span></p>
<ol>
<li>编译错误引火线</li>
</ol>
<ul>
<li>复制到做题平台上时复制漏了一些东西。 -不必多讲。</li>
<li>if语句后加了分号，导致出现对于else语句的错误。</li>
<li>变量重名，或者没改完一些变量的名字。</li>
<li>忘了一些分号。</li>
<li>int mian（int main）或者stdio打错了</li>
<li>修改程序的时候忘了关黑框，有时候会不能编译新的文件。</li>
<li>for循环中分号用成逗号</li>
<li>函数声明与定义部分，都需要对于形式变量的数据类型进行设置。</li>
</ul>
<ol start="2">
<li>运行错误引火线</li>
</ol>
<ul>
<li>for循环中计数的变量（比如i,j）从小数到大数的时候用了减，从大数到小数的时候用了加<br>  死循环，for循环变量改变没有朝着限定条件来改，永远不会达到那个条件，退出。</li>
</ul>
<ol start="3">
<li>程序结果错误引火线</li>
</ol>
<ul>
<li><p>scanf没有加取址符，printf加了取址符<br>  scanf不加的话，就不会对于变量进行赋值操作<br>  printf加的话，返回的是变量的储存地址，垃圾数据。</p>
</li>
<li><p>部分需要累加或者累乘的数据，比如sum等，没有在开始的时候设置为0（+）或者1（ * ）<br>  数据起始值不知道，一定不能够经过累加或者累乘得到相应的结果。</p>
</li>
<li><p>循环完一次的结果归零。<br>  有些循环比如while进行多实例检测的时候，会执行多个循环，<br>  如果某些计数的变量没有归零，会导致数据很离谱。</p>
</li>
<li><p>判断相等运算符 &#x3D;&#x3D; 写成赋值运算符 &#x3D;<br>  建议把变量放后面，值放前面，这样如果犯这个错的话会报错</p>
</li>
<li><p>赋值运算符&#x3D;的结合性不清楚。<br>  用变量给变量赋值时，有可能反而用没有赋值的变量给赋过值的变量赋值，数据一定错。</p>
</li>
<li><p>double转int的坑<br>  double储存的数据是近似值，切去小数点后有可能数据-1<br>  届时答案对不对完全看你运气。</p>
</li>
<li><p>数据类型对应的格式化符在更改变量类型的时候没有改变。</p>
</li>
<li><p>switch语句中漏写了一个break。<br>  直接不受控地向下面的case进发，全部执行，直到遇到新的break。</p>
</li>
<li><p>scanf中的格式加空格就算了，别的不要轻易加。</p>
</li>
<li></li>
<li><p>多字符输入的时候，注意处理回车与空格，一般用getchar来解决</p>
</li>
</ul>
<p>检查的思路：</p>
<ol>
<li>首先基本问题，不要出编译错误，对于一些常见符号要打对<br> 比如，scanf中的&amp;符号，各个语句后面的分号，大括号不要漏一边。</li>
<li>然后，看修改变量的时候有没有注意类型，<br>相应的标识符还有对应的在scanf中或者printf中的格式化%符有没有改</li>
<li>接着看循环，<br>对于for，看它的循环变量是否能够达到那个限定条件，是不是会死循环<br>对于while，看它程序结束后是否真的能够得到你想要的结果。也要注意死循环。<br>看分支，看if语句的限定是否满足自己想要的条件，是否存在&#x3D;&#x3D; 写成&#x3D;的情况。<br>看switch语句的break。</li>
<li>最后，再检查一下自己是不是一些形式上的错误，复制粘贴等不合适。</li>
</ol>
]]></content>
      <tags>
        <tag>C语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/11/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2023/11/07/%E6%95%B0%E7%BB%84-1/</url>
    <content><![CDATA[<h1 id="数组概论（Ver-2）"><a href="#数组概论（Ver-2）" class="headerlink" title="数组概论（Ver 2）"></a>数组概论（Ver 2）</h1><p>战友们晚上好！今晚因为电脑的原因本来写好的稿子不能提前交上了，抱歉。<br>今天大体讲一下关于数组的内容，看完就可以使用来做题了。</p>
<p>目录请见群里发送的图片</p>
<span id="more"></span>

<h2 id="1-数组基本用法"><a href="#1-数组基本用法" class="headerlink" title="1.数组基本用法"></a>1.数组基本用法</h2><h3 id="1-1-数组的初始化"><a href="#1-1-数组的初始化" class="headerlink" title="1.1 数组的初始化"></a>1.1 数组的初始化</h3><p>我们知道，要使用一个变量，我们需要先“声明”才能够使用，<br>数组也是这样的，但作为一个数据容器，它还有大小这个参数。<br>大体格式是这样的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;数据类型&gt; &lt;标识符&gt;[长度];</span><br><span class="line"><span class="comment">//也可以在长度后面加上=&#123;&#125;，但是数组不确定的时候，没必要。</span></span><br></pre></td></tr></table></figure>
<p>这里的<strong>数据类型</strong>就是我们常用的int,double,char等等，<br>表示数组内元素的数据类型</p>
<p><strong>标识符</strong>是数组的名称，命名时也符合变量的命名规范<br>比如这样</p>
<blockquote>
<p>不能以数字、标点符号（很多标点符号如，或者括号都是运算符）开头，<br>不能使用关键字（会语法高亮的字比如int）<br>最好使用这种形式 数据类型的首字母加上名称，如iArray1</p>
</blockquote>
<p><strong>长度</strong>是可以省略的，但只在数组完全确定的时候。<br>但是我们在做题的过程中一般不使用确定的数组<br>（数组可以预先指定好元素的值，如下例）<br>一般是题目告诉我们最多的时候数据有多少个，<br>我们一般取很大的数，如1000、10000等。<br>像iArray0这样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> iArray0[<span class="number">1000</span>]; <span class="comment">//相信我，这会是你们用的频率最多的那种。</span></span><br><span class="line"><span class="type">int</span> iArray1[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">//确定数组</span></span><br><span class="line"><span class="type">int</span> iArray2[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;      <span class="comment">//int与double类型都是空位补零。</span></span><br><span class="line"><span class="type">int</span> iArray3[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;   <span class="comment">//省略长度，相当于iArray1</span></span><br></pre></td></tr></table></figure>

<p>其中，对于iArray3，规定了长度，但是没有确定完5个元素，<br>其他的元素对于int类型数组用0填上<br>但对于char类型的数组，用的是一个字符<code>\0</code>，以后学字符串的时候会接触到<br>这个字符提前，那么输出的时候就会提前结束。</p>
<h3 id="1-2-数组的数据储存输出"><a href="#1-2-数组的数据储存输出" class="headerlink" title="1.2 数组的数据储存输出"></a>1.2 数组的数据储存输出</h3><p>已经声明完了，那么接下来就是往容器里加入数据<br>方式依旧是我们惯用的scanf函数。<br>但是这里就要到一个很容易错的点了：<strong>下标</strong><br>先看下面的演示，我们这样来写入数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这也是一种惯用模式吧，像今天下午老师总结的那个</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;iArray0[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里拿iArray来举例子，长度为n，n的定义与赋值这里省略掉</span></span><br></pre></td></tr></table></figure>

<p>相信聪明的你已经看到了，我们的<strong>i是从0开始取的</strong>，<br>那么<code>iArray0[0]</code>也就表示在<code>iArray0</code>数组里的第一项，所以最后的一项的下标是n - 1。<br>这个特性一定要记好，要好好练习啊！<br>（不然以后写for循环的时候用了0-n，错在哪都不知道，找谁哭去？）</p>
<p>那么也像储存一样，我们也是用printf函数加上for循环来输出的<br>（这比起某种语言真的太麻烦啦！差评）</p>
<p>所以这就是数组使用的几乎全部，其他都是一些形式上的改变，已经可以开始上手了。</p>
<h2 id="2-多维数组"><a href="#2-多维数组" class="headerlink" title="2.多维数组"></a>2.多维数组</h2><p>也是简单一说，在平常做题的时候这种数组不会很频繁地用到。<br>如果一维数组只有一个长度参数的话，二维就有两个，相当于平面直角坐标系。<br>就像下面这样<br>    0   1   2<br>0<br>1<br>2<br>二维数组用两个参数确定一个值，<br>也就是说在<strong>scanf输入、声明、printf输出</strong>的时候也需要两个括号。<br>几维数组就是几个括号，其他的表示方式其实与一维数组差不多。</p>
<blockquote>
<p>1.空位自动补上对应的数值<br>2.在数组确定的时候是可以省略长度参数的<br>3.确定的时候稍有不同，可以有两种确定方式，如下。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> iArray4[<span class="number">1000</span>][<span class="number">1000</span>];  <span class="comment">//最常用的,等待输入</span></span><br><span class="line"><span class="type">int</span> iArray5[<span class="number">2</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//或者int iArray5[2][5] = &#123;1,2,3,4,5,2,3,4,5,6&#125;;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-数组的应用场景"><a href="#3-数组的应用场景" class="headerlink" title="3.数组的应用场景"></a>3.数组的应用场景</h2><p>从这几次周赛的题目来看，我们使用数组的目的是<strong>储存数据</strong>，<br>也就是当我们<strong>需要不止一次地遍历数据，而且数据很多</strong>的时候，我们就可以使用数组。<br>（不多的时候，两三个直接用变量存就好了）<br>这里拿出两种题，<br>一种是n个数求和，我们定义一个sum变量，<br>直接输入一个加一次就可以，每一个数据加完就不再用了，不需要用数组。<br>但是，这次周赛的群友发言计数器那道题就需要对于ID统计出现次数，<br>这就需要遍历数组了，需要在输入之后再次使用所有数据。</p>
<p>所以这就是数组我了解的大致内容，如果有不懂的地方欢迎交流提问。<br>我的分享到此结束！谢谢大家的时间！</p>
]]></content>
      <tags>
        <tag>C语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>流程控制方法</title>
    <url>/2023/08/30/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>今天，在大多数编程语言中，都提供两种循环结构，一种是<strong>以数据容器为基础的</strong>，一种是<strong>以条件为基础的</strong>。</p>
<span id="more"></span>


<h1 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a><strong>if语句</strong></h1><p>你其实能发现，这一页可以构成一个粗略的if嵌套循环。</p>
<p>if语句的最简单构成是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression:</span><br><span class="line">	statements</span><br></pre></td></tr></table></figure>
<p>如果expression返回值为真，则执行statements，否则执行下面的语句。</p>
<p>如果想让它对两种互补的情况操作，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression:</span><br><span class="line">	statements_for_true</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	statements_for_false</span><br></pre></td></tr></table></figure>
<p>如果有更多的情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression1:</span><br><span class="line">	statements_for_expresson1_True</span><br><span class="line"><span class="keyword">elif</span> expression2:</span><br><span class="line">	statements_for_expression2_True</span><br><span class="line"><span class="keyword">elif</span> expression2:</span><br><span class="line">	statements_for_expression3_True</span><br></pre></td></tr></table></figure>
<p>其中，<em>elif</em>是<em>else if</em>的缩写，用法相同。</p>
<h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a><strong>for循环</strong></h1><p>用来对于数据容器(<strong>尤其是有序容器</strong>)中的数据逐个操作的循环<br>for循环是以集合为基础的循环。<br>for后的‘for i in is’，如果<code>i in is</code>为<em>False</em><br>即<strong>i无值或is为空的</strong><br>则下面的语句不会被执行。</p>
<p>#continue #break #pass</p>
<h1 id="Continue、Break和Pass语句"><a href="#Continue、Break和Pass语句" class="headerlink" title="Continue、Break和Pass语句"></a>Continue、Break和Pass语句</h1><p><em>Continue</em>语句将忽略其后的语句开始下一次循环。<br><em>Break</em>从此结束循环。<br><em>Pass</em>什么也不干，是用来占位的。</p>
<h1 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h1><p>while循环的格式如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> expression:</span><br><span class="line">	statements</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python学习</category>
      </categories>
  </entry>
</search>
